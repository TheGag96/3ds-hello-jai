//
// This file was auto-generated using the following command:
//
// jai generate.jai
//

// #load "libc_3ds.jai";

size_t :: u32;
ssize_t :: s32;
ptrdiff_t :: s32;
wchar_t :: s32;
wint_t :: u32;

FILE :: void;

time_t :: s64;
suseconds_t :: s32;

timeval :: struct {
    tv_sec:  time_t; /* seconds */
    tv_usec: suseconds_t; /* and microseconds */
}

in_port_t :: u16;
in_addr_t :: u32;

_LOCK_T :: s32;

_LOCK_RECURSIVE_T :: struct {
    lock: _LOCK_T;
    thread_tag: s32;
    counter: s32;
}

CUR_PROCESS_HANDLE :: 0xFFFF8001;

ARBITRATION_SIGNAL_ALL :: -1;

CUR_THREAD_HANDLE :: 0xFFFF8000;

SYSCLOCK_SOC :: 16756991;

SYSCLOCK_SYS :: SYSCLOCK_SOC * 2;

SYSCLOCK_SDMMC :: SYSCLOCK_SYS * 2;

SYSCLOCK_ARM9 :: SYSCLOCK_SYS * 4;

SYSCLOCK_ARM11 :: SYSCLOCK_ARM9 * 2;

SYSCLOCK_ARM11_LGR1 :: SYSCLOCK_ARM11 * 2;

SYSCLOCK_ARM11_LGR2 :: SYSCLOCK_ARM11 * 3;

SYSCLOCK_ARM11_NEW :: SYSCLOCK_ARM11_LGR2;

CPU_TICKS_PER_MSEC :: SYSCLOCK_ARM11 / 1000.0;
CPU_TICKS_PER_USEC :: SYSCLOCK_ARM11 / 1000000.0;

OS_HEAP_AREA_BEGIN :: 0x08000000;
OS_HEAP_AREA_END :: 0x0E000000;

OS_MAP_AREA_BEGIN :: 0x10000000;
OS_MAP_AREA_END :: 0x14000000;

OS_OLD_FCRAM_VADDR :: 0x14000000;
OS_OLD_FCRAM_PADDR :: 0x20000000;
OS_OLD_FCRAM_SIZE :: 0x8000000;

OS_QTMRAM_VADDR :: 0x1E800000;
OS_QTMRAM_PADDR :: 0x1F000000;
OS_QTMRAM_SIZE :: 0x400000;

OS_MMIO_VADDR :: 0x1EC00000;
OS_MMIO_PADDR :: 0x10100000;
OS_MMIO_SIZE :: 0x400000;

OS_VRAM_VADDR :: 0x1F000000;
OS_VRAM_PADDR :: 0x18000000;
OS_VRAM_SIZE :: 0x600000;

OS_DSPRAM_VADDR :: 0x1FF00000;
OS_DSPRAM_PADDR :: 0x1FF00000;
OS_DSPRAM_SIZE :: 0x80000;

OS_KERNELCFG_VADDR :: 0x1FF80000;
OS_SHAREDCFG_VADDR :: 0x1FF81000;

OS_FCRAM_VADDR :: 0x30000000;
OS_FCRAM_PADDR :: 0x20000000;
OS_FCRAM_SIZE :: 0x10000000;

OS_SharedConfig :: cast(*osSharedConfig_s)OS_SHAREDCFG_VADDR;

WRITE_DATA_TO_FAULTING_STACK :: cast(*ERRF_ExceptionData)1;

GSP_SCREEN_TOP :: 0;
GSP_SCREEN_BOTTOM :: 1;
GSP_SCREEN_WIDTH :: 240;
GSP_SCREEN_HEIGHT_TOP :: 400;
GSP_SCREEN_HEIGHT_TOP_2X :: 800;
GSP_SCREEN_HEIGHT_BOTTOM :: 320;

CONSOLE_COLOR_BOLD :: 1<<0;
CONSOLE_COLOR_FAINT :: 1<<1;
CONSOLE_ITALIC :: 1<<2;
CONSOLE_UNDERLINE :: 1<<3;
CONSOLE_BLINK_SLOW :: 1<<4;
CONSOLE_BLINK_FAST :: 1<<5;
CONSOLE_COLOR_REVERSE :: 1<<6;
CONSOLE_CONCEAL :: 1<<7;
CONSOLE_CROSSED_OUT :: 1<<8;
CONSOLE_FG_CUSTOM :: 1<<9;
CONSOLE_BG_CUSTOM :: 1<<10;

CSND_NUM_CHANNELS :: 32;

FRIEND_SCREEN_NAME_SIZE :: 0xB;
FRIEND_COMMENT_SIZE :: 0x21;
FRIEND_LIST_SIZE :: 0x64;

scanKeys :: hidScanInput;

keysHeld :: hidKeysHeld;

keysDown :: hidKeysDown;

keysUp :: hidKeysUp;

touchRead :: hidTouchRead;

circleRead :: hidCircleRead;

hidCstickRead :: irrstCstickRead;

HTTPC_RESULTCODE_DOWNLOADPENDING :: 0xd840a02b;

HTTPC_RESULTCODE_NOTFOUND :: 0xd840a028;

HTTPC_RESULTCODE_TIMEDOUT :: 0xd820a069;

UDS_MAXNODES :: 16;

UDS_BROADCAST_NETWORKNODEID :: 0xFFFF;

UDS_HOST_NETWORKNODEID :: 0x1;

UDS_DEFAULT_RECVBUFSIZE :: 0x2E30;

UDS_DATAFRAME_MAXSIZE :: 0x5C6;

SOL_SOCKET :: 0xFFFF;

PF_UNSPEC :: 0;
PF_INET :: 2;
PF_INET6 :: 23;

AF_UNSPEC :: PF_UNSPEC;
AF_INET :: PF_INET;
AF_INET6 :: PF_INET6;

SOCK_STREAM :: 1;
SOCK_DGRAM :: 2;

MSG_OOB :: 0x0001;
MSG_PEEK :: 0x0002;
MSG_DONTWAIT :: 0x0004;
MSG_DONTROUTE :: 0x0000;
MSG_WAITALL :: 0x0000;
MSG_MORE :: 0x0000;
MSG_NOSIGNAL :: 0x0000;

SHUT_RD :: 0;
SHUT_WR :: 1;
SHUT_RDWR :: 2;

SO_REUSEADDR :: 0x0004;
SO_LINGER :: 0x0080;
SO_OOBINLINE :: 0x0100;
SO_SNDBUF :: 0x1001;
SO_RCVBUF :: 0x1002;
SO_SNDLOWAT :: 0x1003;
SO_RCVLOWAT :: 0x1004;
SO_TYPE :: 0x1008;
SO_ERROR :: 0x1009;

SO_BROADCAST :: 0x0000;

INADDR_LOOPBACK :: 0x7f000001;
INADDR_ANY :: 0x00000000;
INADDR_BROADCAST :: 0xFFFFFFFF;
INADDR_NONE :: 0xFFFFFFFF;

INET_ADDRSTRLEN :: 16;

IPPROTO_IP :: 0;
IPPROTO_UDP :: 17;
IPPROTO_TCP :: 6;

IP_TOS :: 7;
IP_TTL :: 8;
IP_MULTICAST_LOOP :: 9;
IP_MULTICAST_TTL :: 10;
IP_ADD_MEMBERSHIP :: 11;
IP_DROP_MEMBERSHIP :: 12;

SOL_CONFIG :: 0xfffe;

ROUTING_FLAG_G :: 0x01;

TCP_STATE_CLOSED :: 1;
TCP_STATE_LISTEN :: 2;
TCP_STATE_ESTABLISHED :: 5;
TCP_STATE_FINWAIT1 :: 6;
TCP_STATE_FINWAIT2 :: 7;
TCP_STATE_CLOSE_WAIT :: 8;
TCP_STATE_LAST_ACK :: 9;
TCP_STATE_TIME_WAIT :: 11;

MVD_STATUS_OK :: 0x17000;
MVD_STATUS_PARAMSET :: 0x17001;
MVD_STATUS_BUSY :: 0x17002;
MVD_STATUS_FRAMEREADY :: 0x17003;
MVD_STATUS_INCOMPLETEPROCESSING :: 0x17004;
MVD_STATUS_NALUPROCFLAG :: 0x17007;

MVD_DEFAULT_WORKBUF_SIZE :: 0x9006C8;

NFC_ERR_INVALID_STATE :: 0xC8A17600;

NFC_ERR_APPDATA_UNINITIALIZED :: 0xC8A17620;

NFC_ERR_AMIIBO_NOTSETUP :: 0xC8A17628;

NFC_ERR_APPID_MISMATCH :: 0xC8A17638;

NFC_ERR_DATACORRUPTION0 :: 0xC8C1760C;

NFC_ERR_DATACORRUPTION1 :: 0xC8A17618;

NFC_STARTSCAN_DEFAULTINPUT :: 0;

GPUREG_0000 :: 0x0000;
GPUREG_0001 :: 0x0001;
GPUREG_0002 :: 0x0002;
GPUREG_0003 :: 0x0003;
GPUREG_0004 :: 0x0004;
GPUREG_0005 :: 0x0005;
GPUREG_0006 :: 0x0006;
GPUREG_0007 :: 0x0007;
GPUREG_0008 :: 0x0008;
GPUREG_0009 :: 0x0009;
GPUREG_000A :: 0x000A;
GPUREG_000B :: 0x000B;
GPUREG_000C :: 0x000C;
GPUREG_000D :: 0x000D;
GPUREG_000E :: 0x000E;
GPUREG_000F :: 0x000F;
GPUREG_FINALIZE :: 0x0010;
GPUREG_0011 :: 0x0011;
GPUREG_0012 :: 0x0012;
GPUREG_0013 :: 0x0013;
GPUREG_0014 :: 0x0014;
GPUREG_0015 :: 0x0015;
GPUREG_0016 :: 0x0016;
GPUREG_0017 :: 0x0017;
GPUREG_0018 :: 0x0018;
GPUREG_0019 :: 0x0019;
GPUREG_001A :: 0x001A;
GPUREG_001B :: 0x001B;
GPUREG_001C :: 0x001C;
GPUREG_001D :: 0x001D;
GPUREG_001E :: 0x001E;
GPUREG_001F :: 0x001F;
GPUREG_0020 :: 0x0020;
GPUREG_0021 :: 0x0021;
GPUREG_0022 :: 0x0022;
GPUREG_0023 :: 0x0023;
GPUREG_0024 :: 0x0024;
GPUREG_0025 :: 0x0025;
GPUREG_0026 :: 0x0026;
GPUREG_0027 :: 0x0027;
GPUREG_0028 :: 0x0028;
GPUREG_0029 :: 0x0029;
GPUREG_002A :: 0x002A;
GPUREG_002B :: 0x002B;
GPUREG_002C :: 0x002C;
GPUREG_002D :: 0x002D;
GPUREG_002E :: 0x002E;
GPUREG_002F :: 0x002F;
GPUREG_0030 :: 0x0030;
GPUREG_0031 :: 0x0031;
GPUREG_0032 :: 0x0032;
GPUREG_0033 :: 0x0033;
GPUREG_0034 :: 0x0034;
GPUREG_0035 :: 0x0035;
GPUREG_0036 :: 0x0036;
GPUREG_0037 :: 0x0037;
GPUREG_0038 :: 0x0038;
GPUREG_0039 :: 0x0039;
GPUREG_003A :: 0x003A;
GPUREG_003B :: 0x003B;
GPUREG_003C :: 0x003C;
GPUREG_003D :: 0x003D;
GPUREG_003E :: 0x003E;
GPUREG_003F :: 0x003F;

GPUREG_FACECULLING_CONFIG :: 0x0040;
GPUREG_VIEWPORT_WIDTH :: 0x0041;
GPUREG_VIEWPORT_INVW :: 0x0042;
GPUREG_VIEWPORT_HEIGHT :: 0x0043;
GPUREG_VIEWPORT_INVH :: 0x0044;
GPUREG_0045 :: 0x0045;
GPUREG_0046 :: 0x0046;
GPUREG_FRAGOP_CLIP :: 0x0047;
GPUREG_FRAGOP_CLIP_DATA0 :: 0x0048;
GPUREG_FRAGOP_CLIP_DATA1 :: 0x0049;
GPUREG_FRAGOP_CLIP_DATA2 :: 0x004A;
GPUREG_FRAGOP_CLIP_DATA3 :: 0x004B;
GPUREG_004C :: 0x004C;
GPUREG_DEPTHMAP_SCALE :: 0x004D;
GPUREG_DEPTHMAP_OFFSET :: 0x004E;
GPUREG_SH_OUTMAP_TOTAL :: 0x004F;
GPUREG_SH_OUTMAP_O0 :: 0x0050;
GPUREG_SH_OUTMAP_O1 :: 0x0051;
GPUREG_SH_OUTMAP_O2 :: 0x0052;
GPUREG_SH_OUTMAP_O3 :: 0x0053;
GPUREG_SH_OUTMAP_O4 :: 0x0054;
GPUREG_SH_OUTMAP_O5 :: 0x0055;
GPUREG_SH_OUTMAP_O6 :: 0x0056;
GPUREG_0057 :: 0x0057;
GPUREG_0058 :: 0x0058;
GPUREG_0059 :: 0x0059;
GPUREG_005A :: 0x005A;
GPUREG_005B :: 0x005B;
GPUREG_005C :: 0x005C;
GPUREG_005D :: 0x005D;
GPUREG_005E :: 0x005E;
GPUREG_005F :: 0x005F;
GPUREG_0060 :: 0x0060;
GPUREG_EARLYDEPTH_FUNC :: 0x0061;
GPUREG_EARLYDEPTH_TEST1 :: 0x0062;
GPUREG_EARLYDEPTH_CLEAR :: 0x0063;
GPUREG_SH_OUTATTR_MODE :: 0x0064;
GPUREG_SCISSORTEST_MODE :: 0x0065;
GPUREG_SCISSORTEST_POS :: 0x0066;
GPUREG_SCISSORTEST_DIM :: 0x0067;
GPUREG_VIEWPORT_XY :: 0x0068;
GPUREG_0069 :: 0x0069;
GPUREG_EARLYDEPTH_DATA :: 0x006A;
GPUREG_006B :: 0x006B;
GPUREG_006C :: 0x006C;
GPUREG_DEPTHMAP_ENABLE :: 0x006D;
GPUREG_RENDERBUF_DIM :: 0x006E;
GPUREG_SH_OUTATTR_CLOCK :: 0x006F;
GPUREG_0070 :: 0x0070;
GPUREG_0071 :: 0x0071;
GPUREG_0072 :: 0x0072;
GPUREG_0073 :: 0x0073;
GPUREG_0074 :: 0x0074;
GPUREG_0075 :: 0x0075;
GPUREG_0076 :: 0x0076;
GPUREG_0077 :: 0x0077;
GPUREG_0078 :: 0x0078;
GPUREG_0079 :: 0x0079;
GPUREG_007A :: 0x007A;
GPUREG_007B :: 0x007B;
GPUREG_007C :: 0x007C;
GPUREG_007D :: 0x007D;
GPUREG_007E :: 0x007E;
GPUREG_007F :: 0x007F;

GPUREG_TEXUNIT_CONFIG :: 0x0080;
GPUREG_TEXUNIT0_BORDER_COLOR :: 0x0081;
GPUREG_TEXUNIT0_DIM :: 0x0082;
GPUREG_TEXUNIT0_PARAM :: 0x0083;
GPUREG_TEXUNIT0_LOD :: 0x0084;
GPUREG_TEXUNIT0_ADDR1 :: 0x0085;
GPUREG_TEXUNIT0_ADDR2 :: 0x0086;
GPUREG_TEXUNIT0_ADDR3 :: 0x0087;
GPUREG_TEXUNIT0_ADDR4 :: 0x0088;
GPUREG_TEXUNIT0_ADDR5 :: 0x0089;
GPUREG_TEXUNIT0_ADDR6 :: 0x008A;
GPUREG_TEXUNIT0_SHADOW :: 0x008B;
GPUREG_008C :: 0x008C;
GPUREG_008D :: 0x008D;
GPUREG_TEXUNIT0_TYPE :: 0x008E;
GPUREG_LIGHTING_ENABLE0 :: 0x008F;
GPUREG_0090 :: 0x0090;
GPUREG_TEXUNIT1_BORDER_COLOR :: 0x0091;
GPUREG_TEXUNIT1_DIM :: 0x0092;
GPUREG_TEXUNIT1_PARAM :: 0x0093;
GPUREG_TEXUNIT1_LOD :: 0x0094;
GPUREG_TEXUNIT1_ADDR :: 0x0095;
GPUREG_TEXUNIT1_TYPE :: 0x0096;
GPUREG_0097 :: 0x0097;
GPUREG_0098 :: 0x0098;
GPUREG_TEXUNIT2_BORDER_COLOR :: 0x0099;
GPUREG_TEXUNIT2_DIM :: 0x009A;
GPUREG_TEXUNIT2_PARAM :: 0x009B;
GPUREG_TEXUNIT2_LOD :: 0x009C;
GPUREG_TEXUNIT2_ADDR :: 0x009D;
GPUREG_TEXUNIT2_TYPE :: 0x009E;
GPUREG_009F :: 0x009F;
GPUREG_00A0 :: 0x00A0;
GPUREG_00A1 :: 0x00A1;
GPUREG_00A2 :: 0x00A2;
GPUREG_00A3 :: 0x00A3;
GPUREG_00A4 :: 0x00A4;
GPUREG_00A5 :: 0x00A5;
GPUREG_00A6 :: 0x00A6;
GPUREG_00A7 :: 0x00A7;
GPUREG_TEXUNIT3_PROCTEX0 :: 0x00A8;
GPUREG_TEXUNIT3_PROCTEX1 :: 0x00A9;
GPUREG_TEXUNIT3_PROCTEX2 :: 0x00AA;
GPUREG_TEXUNIT3_PROCTEX3 :: 0x00AB;
GPUREG_TEXUNIT3_PROCTEX4 :: 0x00A;
GPUREG_TEXUNIT3_PROCTEX5 :: 0x00D;
GPUREG_00AE :: 0x00AE;
GPUREG_PROCTEX_LUT :: 0x00AF;
GPUREG_PROCTEX_LUT_DATA0 :: 0x00B0;
GPUREG_PROCTEX_LUT_DATA1 :: 0x00B1;
GPUREG_PROCTEX_LUT_DATA2 :: 0x00B2;
GPUREG_PROCTEX_LUT_DATA3 :: 0x00B3;
GPUREG_PROCTEX_LUT_DATA4 :: 0x00B4;
GPUREG_PROCTEX_LUT_DATA5 :: 0x00B5;
GPUREG_PROCTEX_LUT_DATA6 :: 0x00B6;
GPUREG_PROCTEX_LUT_DATA7 :: 0x00B7;
GPUREG_00B8 :: 0x00B8;
GPUREG_00B9 :: 0x00B9;
GPUREG_00BA :: 0x00BA;
GPUREG_00BB :: 0x00BB;
GPUREG_00BC :: 0x00BC;
GPUREG_00BD :: 0x00BD;
GPUREG_00BE :: 0x00BE;
GPUREG_00BF :: 0x00BF;
GPUREG_TEXENV0_SOURCE :: 0x00C0;
GPUREG_TEXENV0_OPERAND :: 0x00C1;
GPUREG_TEXENV0_COMBINER :: 0x00C2;
GPUREG_TEXENV0_COLOR :: 0x00C3;
GPUREG_TEXENV0_SCALE :: 0x00C4;
GPUREG_00C5 :: 0x00C5;
GPUREG_00C6 :: 0x00C6;
GPUREG_00C7 :: 0x00C7;
GPUREG_TEXENV1_SOURCE :: 0x00C8;
GPUREG_TEXENV1_OPERAND :: 0x00C9;
GPUREG_TEXENV1_COMBINER :: 0x00CA;
GPUREG_TEXENV1_COLOR :: 0x00CB;
GPUREG_TEXENV1_SCALE :: 0x00CC;
GPUREG_00CD :: 0x00CD;
GPUREG_00CE :: 0x00CE;
GPUREG_00CF :: 0x00CF;
GPUREG_TEXENV2_SOURCE :: 0x00D0;
GPUREG_TEXENV2_OPERAND :: 0x00D1;
GPUREG_TEXENV2_COMBINER :: 0x00D2;
GPUREG_TEXENV2_COLOR :: 0x00D3;
GPUREG_TEXENV2_SCALE :: 0x00D4;
GPUREG_00D5 :: 0x00D5;
GPUREG_00D6 :: 0x00D6;
GPUREG_00D7 :: 0x00D7;
GPUREG_TEXENV3_SOURCE :: 0x00D8;
GPUREG_TEXENV3_OPERAND :: 0x00D9;
GPUREG_TEXENV3_COMBINER :: 0x00DA;
GPUREG_TEXENV3_COLOR :: 0x00DB;
GPUREG_TEXENV3_SCALE :: 0x00DC;
GPUREG_00DD :: 0x00DD;
GPUREG_00DE :: 0x00DE;
GPUREG_00DF :: 0x00DF;
GPUREG_TEXENV_UPDATE_BUFFER :: 0x00E0;
GPUREG_FOG_COLOR :: 0x00E1;
GPUREG_00E2 :: 0x00E2;
GPUREG_00E3 :: 0x00E3;
GPUREG_GAS_ATTENUATION :: 0x00E4;
GPUREG_GAS_ACCMAX :: 0x00E5;
GPUREG_FOG_LUT_INDEX :: 0x00E6;
GPUREG_00E7 :: 0x00E7;
GPUREG_FOG_LUT_DATA0 :: 0x00E8;
GPUREG_FOG_LUT_DATA1 :: 0x00E9;
GPUREG_FOG_LUT_DATA2 :: 0x00EA;
GPUREG_FOG_LUT_DATA3 :: 0x00EB;
GPUREG_FOG_LUT_DATA4 :: 0x00EC;
GPUREG_FOG_LUT_DATA5 :: 0x00ED;
GPUREG_FOG_LUT_DATA6 :: 0x00EE;
GPUREG_FOG_LUT_DATA7 :: 0x00EF;
GPUREG_TEXENV4_SOURCE :: 0x00F0;
GPUREG_TEXENV4_OPERAND :: 0x00F1;
GPUREG_TEXENV4_COMBINER :: 0x00F2;
GPUREG_TEXENV4_COLOR :: 0x00F3;
GPUREG_TEXENV4_SCALE :: 0x00F4;
GPUREG_00F5 :: 0x00F5;
GPUREG_00F6 :: 0x00F6;
GPUREG_00F7 :: 0x00F7;
GPUREG_TEXENV5_SOURCE :: 0x00F8;
GPUREG_TEXENV5_OPERAND :: 0x00F9;
GPUREG_TEXENV5_COMBINER :: 0x00FA;
GPUREG_TEXENV5_COLOR :: 0x00FB;
GPUREG_TEXENV5_SCALE :: 0x00FC;
GPUREG_TEXENV_BUFFER_COLOR :: 0x00FD;
GPUREG_00FE :: 0x00FE;
GPUREG_00FF :: 0x00FF;

GPUREG_COLOR_OPERATION :: 0x0100;
GPUREG_BLEND_FUNC :: 0x0101;
GPUREG_LOGIC_OP :: 0x0102;
GPUREG_BLEND_COLOR :: 0x0103;
GPUREG_FRAGOP_ALPHA_TEST :: 0x0104;
GPUREG_STENCIL_TEST :: 0x0105;
GPUREG_STENCIL_OP :: 0x0106;
GPUREG_DEPTH_COLOR_MASK :: 0x0107;
GPUREG_0108 :: 0x0108;
GPUREG_0109 :: 0x0109;
GPUREG_010A :: 0x010A;
GPUREG_010B :: 0x010B;
GPUREG_010C :: 0x010C;
GPUREG_010D :: 0x010D;
GPUREG_010E :: 0x010E;
GPUREG_010F :: 0x010F;
GPUREG_FRAMEBUFFER_INVALIDATE :: 0x0110;
GPUREG_FRAMEBUFFER_FLUSH :: 0x0111;
GPUREG_COLORBUFFER_READ :: 0x0112;
GPUREG_COLORBUFFER_WRITE :: 0x0113;
GPUREG_DEPTHBUFFER_READ :: 0x0114;
GPUREG_DEPTHBUFFER_WRITE :: 0x0115;
GPUREG_DEPTHBUFFER_FORMAT :: 0x0116;
GPUREG_COLORBUFFER_FORMAT :: 0x0117;
GPUREG_EARLYDEPTH_TEST2 :: 0x0118;
GPUREG_0119 :: 0x0119;
GPUREG_011A :: 0x011A;
GPUREG_FRAMEBUFFER_BLOCK32 :: 0x011B;
GPUREG_DEPTHBUFFER_LOC :: 0x011C;
GPUREG_COLORBUFFER_LOC :: 0x011D;
GPUREG_FRAMEBUFFER_DIM :: 0x011E;
GPUREG_011F :: 0x011F;
GPUREG_GAS_LIGHT_XY :: 0x0120;
GPUREG_GAS_LIGHT_Z :: 0x0121;
GPUREG_GAS_LIGHT_Z_COLOR :: 0x0122;
GPUREG_GAS_LUT_INDEX :: 0x0123;
GPUREG_GAS_LUT_DATA :: 0x0124;
GPUREG_GAS_ACCMAX_FEEDBACK :: 0x0125;
GPUREG_GAS_DELTAZ_DEPTH :: 0x0126;
GPUREG_0127 :: 0x0127;
GPUREG_0128 :: 0x0128;
GPUREG_0129 :: 0x0129;
GPUREG_012A :: 0x012A;
GPUREG_012B :: 0x012B;
GPUREG_012C :: 0x012C;
GPUREG_012D :: 0x012D;
GPUREG_012E :: 0x012E;
GPUREG_012F :: 0x012F;
GPUREG_FRAGOP_SHADOW :: 0x0130;
GPUREG_0131 :: 0x0131;
GPUREG_0132 :: 0x0132;
GPUREG_0133 :: 0x0133;
GPUREG_0134 :: 0x0134;
GPUREG_0135 :: 0x0135;
GPUREG_0136 :: 0x0136;
GPUREG_0137 :: 0x0137;
GPUREG_0138 :: 0x0138;
GPUREG_0139 :: 0x0139;
GPUREG_013A :: 0x013A;
GPUREG_013B :: 0x013B;
GPUREG_013C :: 0x013C;
GPUREG_013D :: 0x013D;
GPUREG_013E :: 0x013E;
GPUREG_013F :: 0x013F;

GPUREG_LIGHT0_SPECULAR0 :: 0x0140;
GPUREG_LIGHT0_SPECULAR1 :: 0x0141;
GPUREG_LIGHT0_DIFFUSE :: 0x0142;
GPUREG_LIGHT0_AMBIENT :: 0x0143;
GPUREG_LIGHT0_XY :: 0x0144;
GPUREG_LIGHT0_Z :: 0x0145;
GPUREG_LIGHT0_SPOTDIR_XY :: 0x0146;
GPUREG_LIGHT0_SPOTDIR_Z :: 0x0147;
GPUREG_0148 :: 0x0148;
GPUREG_LIGHT0_CONFIG :: 0x0149;
GPUREG_LIGHT0_ATTENUATION_BIAS :: 0x014A;
GPUREG_LIGHT0_ATTENUATION_SCALE :: 0x014B;
GPUREG_014C :: 0x014C;
GPUREG_014D :: 0x014D;
GPUREG_014E :: 0x014E;
GPUREG_014F :: 0x014F;
GPUREG_LIGHT1_SPECULAR0 :: 0x0150;
GPUREG_LIGHT1_SPECULAR1 :: 0x0151;
GPUREG_LIGHT1_DIFFUSE :: 0x0152;
GPUREG_LIGHT1_AMBIENT :: 0x0153;
GPUREG_LIGHT1_XY :: 0x0154;
GPUREG_LIGHT1_Z :: 0x0155;
GPUREG_LIGHT1_SPOTDIR_XY :: 0x0156;
GPUREG_LIGHT1_SPOTDIR_Z :: 0x0157;
GPUREG_0158 :: 0x0158;
GPUREG_LIGHT1_CONFIG :: 0x0159;
GPUREG_LIGHT1_ATTENUATION_BIAS :: 0x015A;
GPUREG_LIGHT1_ATTENUATION_SCALE :: 0x015B;
GPUREG_015C :: 0x015C;
GPUREG_015D :: 0x015D;
GPUREG_015E :: 0x015E;
GPUREG_015F :: 0x015F;
GPUREG_LIGHT2_SPECULAR0 :: 0x0160;
GPUREG_LIGHT2_SPECULAR1 :: 0x0161;
GPUREG_LIGHT2_DIFFUSE :: 0x0162;
GPUREG_LIGHT2_AMBIENT :: 0x0163;
GPUREG_LIGHT2_XY :: 0x0164;
GPUREG_LIGHT2_Z :: 0x0165;
GPUREG_LIGHT2_SPOTDIR_XY :: 0x0166;
GPUREG_LIGHT2_SPOTDIR_Z :: 0x0167;
GPUREG_0168 :: 0x0168;
GPUREG_LIGHT2_CONFIG :: 0x0169;
GPUREG_LIGHT2_ATTENUATION_BIAS :: 0x016A;
GPUREG_LIGHT2_ATTENUATION_SCALE :: 0x016B;
GPUREG_016C :: 0x016C;
GPUREG_016D :: 0x016D;
GPUREG_016E :: 0x016E;
GPUREG_016F :: 0x016F;
GPUREG_LIGHT3_SPECULAR0 :: 0x0170;
GPUREG_LIGHT3_SPECULAR1 :: 0x0171;
GPUREG_LIGHT3_DIFFUSE :: 0x0172;
GPUREG_LIGHT3_AMBIENT :: 0x0173;
GPUREG_LIGHT3_XY :: 0x0174;
GPUREG_LIGHT3_Z :: 0x0175;
GPUREG_LIGHT3_SPOTDIR_XY :: 0x0176;
GPUREG_LIGHT3_SPOTDIR_Z :: 0x0177;
GPUREG_0178 :: 0x0178;
GPUREG_LIGHT3_CONFIG :: 0x0179;
GPUREG_LIGHT3_ATTENUATION_BIAS :: 0x017A;
GPUREG_LIGHT3_ATTENUATION_SCALE :: 0x017B;
GPUREG_017C :: 0x017C;
GPUREG_017D :: 0x017D;
GPUREG_017E :: 0x017E;
GPUREG_017F :: 0x017F;
GPUREG_LIGHT4_SPECULAR0 :: 0x0180;
GPUREG_LIGHT4_SPECULAR1 :: 0x0181;
GPUREG_LIGHT4_DIFFUSE :: 0x0182;
GPUREG_LIGHT4_AMBIENT :: 0x0183;
GPUREG_LIGHT4_XY :: 0x0184;
GPUREG_LIGHT4_Z :: 0x0185;
GPUREG_LIGHT4_SPOTDIR_XY :: 0x0186;
GPUREG_LIGHT4_SPOTDIR_Z :: 0x0187;
GPUREG_0188 :: 0x0188;
GPUREG_LIGHT4_CONFIG :: 0x0189;
GPUREG_LIGHT4_ATTENUATION_BIAS :: 0x018A;
GPUREG_LIGHT4_ATTENUATION_SCALE :: 0x018B;
GPUREG_018C :: 0x018C;
GPUREG_018D :: 0x018D;
GPUREG_018E :: 0x018E;
GPUREG_018F :: 0x018F;
GPUREG_LIGHT5_SPECULAR0 :: 0x0190;
GPUREG_LIGHT5_SPECULAR1 :: 0x0191;
GPUREG_LIGHT5_DIFFUSE :: 0x0192;
GPUREG_LIGHT5_AMBIENT :: 0x0193;
GPUREG_LIGHT5_XY :: 0x0194;
GPUREG_LIGHT5_Z :: 0x0195;
GPUREG_LIGHT5_SPOTDIR_XY :: 0x0196;
GPUREG_LIGHT5_SPOTDIR_Z :: 0x0197;
GPUREG_0198 :: 0x0198;
GPUREG_LIGHT5_CONFIG :: 0x0199;
GPUREG_LIGHT5_ATTENUATION_BIAS :: 0x019A;
GPUREG_LIGHT5_ATTENUATION_SCALE :: 0x019B;
GPUREG_019C :: 0x019C;
GPUREG_019D :: 0x019D;
GPUREG_019E :: 0x019E;
GPUREG_019F :: 0x019F;
GPUREG_LIGHT6_SPECULAR0 :: 0x01A0;
GPUREG_LIGHT6_SPECULAR1 :: 0x01A1;
GPUREG_LIGHT6_DIFFUSE :: 0x01A2;
GPUREG_LIGHT6_AMBIENT :: 0x01A3;
GPUREG_LIGHT6_XY :: 0x01A4;
GPUREG_LIGHT6_Z :: 0x01A5;
GPUREG_LIGHT6_SPOTDIR_XY :: 0x01A6;
GPUREG_LIGHT6_SPOTDIR_Z :: 0x01A7;
GPUREG_01A8 :: 0x01A8;
GPUREG_LIGHT6_CONFIG :: 0x01A9;
GPUREG_LIGHT6_ATTENUATION_BIAS :: 0x01AA;
GPUREG_LIGHT6_ATTENUATION_SCALE :: 0x01AB;
GPUREG_01AC :: 0x01AC;
GPUREG_01AD :: 0x01AD;
GPUREG_01AE :: 0x01AE;
GPUREG_01AF :: 0x01AF;
GPUREG_LIGHT7_SPECULAR0 :: 0x01B0;
GPUREG_LIGHT7_SPECULAR1 :: 0x01B1;
GPUREG_LIGHT7_DIFFUSE :: 0x01B2;
GPUREG_LIGHT7_AMBIENT :: 0x01B3;
GPUREG_LIGHT7_XY :: 0x01B4;
GPUREG_LIGHT7_Z :: 0x01B5;
GPUREG_LIGHT7_SPOTDIR_XY :: 0x01B6;
GPUREG_LIGHT7_SPOTDIR_Z :: 0x01B7;
GPUREG_01B8 :: 0x01B8;
GPUREG_LIGHT7_CONFIG :: 0x01B9;
GPUREG_LIGHT7_ATTENUATION_BIAS :: 0x01BA;
GPUREG_LIGHT7_ATTENUATION_SCALE :: 0x01BB;
GPUREG_01BC :: 0x01BC;
GPUREG_01BD :: 0x01BD;
GPUREG_01BE :: 0x01BE;
GPUREG_01BF :: 0x01BF;
GPUREG_LIGHTING_AMBIENT :: 0x01C0;
GPUREG_01C1 :: 0x01C1;
GPUREG_LIGHTING_NUM_LIGHTS :: 0x01C2;
GPUREG_LIGHTING_CONFIG0 :: 0x01C3;
GPUREG_LIGHTING_CONFIG1 :: 0x01C4;
GPUREG_LIGHTING_LUT_INDEX :: 0x01C5;
GPUREG_LIGHTING_ENABLE1 :: 0x01C6;
GPUREG_01C7 :: 0x01C7;
GPUREG_LIGHTING_LUT_DATA0 :: 0x01C8;
GPUREG_LIGHTING_LUT_DATA1 :: 0x01C9;
GPUREG_LIGHTING_LUT_DATA2 :: 0x01CA;
GPUREG_LIGHTING_LUT_DATA3 :: 0x01CB;
GPUREG_LIGHTING_LUT_DATA4 :: 0x01CC;
GPUREG_LIGHTING_LUT_DATA5 :: 0x01CD;
GPUREG_LIGHTING_LUT_DATA6 :: 0x01CE;
GPUREG_LIGHTING_LUT_DATA7 :: 0x01CF;
GPUREG_LIGHTING_LUTINPUT_ABS :: 0x01D0;
GPUREG_LIGHTING_LUTINPUT_SELECT :: 0x01D1;
GPUREG_LIGHTING_LUTINPUT_SCALE :: 0x01D2;
GPUREG_01D3 :: 0x01D3;
GPUREG_01D4 :: 0x01D4;
GPUREG_01D5 :: 0x01D5;
GPUREG_01D6 :: 0x01D6;
GPUREG_01D7 :: 0x01D7;
GPUREG_01D8 :: 0x01D8;
GPUREG_LIGHTING_LIGHT_PERMUTATION :: 0x01D9;
GPUREG_01DA :: 0x01DA;
GPUREG_01DB :: 0x01DB;
GPUREG_01DC :: 0x01DC;
GPUREG_01DD :: 0x01DD;
GPUREG_01DE :: 0x01DE;
GPUREG_01DF :: 0x01DF;
GPUREG_01E0 :: 0x01E0;
GPUREG_01E1 :: 0x01E1;
GPUREG_01E2 :: 0x01E2;
GPUREG_01E3 :: 0x01E3;
GPUREG_01E4 :: 0x01E4;
GPUREG_01E5 :: 0x01E5;
GPUREG_01E6 :: 0x01E6;
GPUREG_01E7 :: 0x01E7;
GPUREG_01E8 :: 0x01E8;
GPUREG_01E9 :: 0x01E9;
GPUREG_01EA :: 0x01EA;
GPUREG_01EB :: 0x01EB;
GPUREG_01EC :: 0x01EC;
GPUREG_01ED :: 0x01ED;
GPUREG_01EE :: 0x01EE;
GPUREG_01EF :: 0x01EF;
GPUREG_01F0 :: 0x01F0;
GPUREG_01F1 :: 0x01F1;
GPUREG_01F2 :: 0x01F2;
GPUREG_01F3 :: 0x01F3;
GPUREG_01F4 :: 0x01F4;
GPUREG_01F5 :: 0x01F5;
GPUREG_01F6 :: 0x01F6;
GPUREG_01F7 :: 0x01F7;
GPUREG_01F8 :: 0x01F8;
GPUREG_01F9 :: 0x01F9;
GPUREG_01FA :: 0x01FA;
GPUREG_01FB :: 0x01FB;
GPUREG_01FC :: 0x01FC;
GPUREG_01FD :: 0x01FD;
GPUREG_01FE :: 0x01FE;
GPUREG_01FF :: 0x01FF;

GPUREG_ATTRIBBUFFERS_LOC :: 0x0200;
GPUREG_ATTRIBBUFFERS_FORMAT_LOW :: 0x0201;
GPUREG_ATTRIBBUFFERS_FORMAT_HIGH :: 0x0202;
GPUREG_ATTRIBBUFFER0_OFFSET :: 0x0203;
GPUREG_ATTRIBBUFFER0_CONFIG1 :: 0x0204;
GPUREG_ATTRIBBUFFER0_CONFIG2 :: 0x0205;
GPUREG_ATTRIBBUFFER1_OFFSET :: 0x0206;
GPUREG_ATTRIBBUFFER1_CONFIG1 :: 0x0207;
GPUREG_ATTRIBBUFFER1_CONFIG2 :: 0x0208;
GPUREG_ATTRIBBUFFER2_OFFSET :: 0x0209;
GPUREG_ATTRIBBUFFER2_CONFIG1 :: 0x020A;
GPUREG_ATTRIBBUFFER2_CONFIG2 :: 0x020B;
GPUREG_ATTRIBBUFFER3_OFFSET :: 0x020C;
GPUREG_ATTRIBBUFFER3_CONFIG1 :: 0x020D;
GPUREG_ATTRIBBUFFER3_CONFIG2 :: 0x020E;
GPUREG_ATTRIBBUFFER4_OFFSET :: 0x020F;
GPUREG_ATTRIBBUFFER4_CONFIG1 :: 0x0210;
GPUREG_ATTRIBBUFFER4_CONFIG2 :: 0x0211;
GPUREG_ATTRIBBUFFER5_OFFSET :: 0x0212;
GPUREG_ATTRIBBUFFER5_CONFIG1 :: 0x0213;
GPUREG_ATTRIBBUFFER5_CONFIG2 :: 0x0214;
GPUREG_ATTRIBBUFFER6_OFFSET :: 0x0215;
GPUREG_ATTRIBBUFFER6_CONFIG1 :: 0x0216;
GPUREG_ATTRIBBUFFER6_CONFIG2 :: 0x0217;
GPUREG_ATTRIBBUFFER7_OFFSET :: 0x0218;
GPUREG_ATTRIBBUFFER7_CONFIG1 :: 0x0219;
GPUREG_ATTRIBBUFFER7_CONFIG2 :: 0x021A;
GPUREG_ATTRIBBUFFER8_OFFSET :: 0x021B;
GPUREG_ATTRIBBUFFER8_CONFIG1 :: 0x021C;
GPUREG_ATTRIBBUFFER8_CONFIG2 :: 0x021D;
GPUREG_ATTRIBBUFFER9_OFFSET :: 0x021E;
GPUREG_ATTRIBBUFFER9_CONFIG1 :: 0x021F;
GPUREG_ATTRIBBUFFER9_CONFIG2 :: 0x0220;
GPUREG_ATTRIBBUFFERA_OFFSET :: 0x0221;
GPUREG_ATTRIBBUFFERA_CONFIG1 :: 0x0222;
GPUREG_ATTRIBBUFFERA_CONFIG2 :: 0x0223;
GPUREG_ATTRIBBUFFERB_OFFSET :: 0x0224;
GPUREG_ATTRIBBUFFERB_CONFIG1 :: 0x0225;
GPUREG_ATTRIBBUFFERB_CONFIG2 :: 0x0226;
GPUREG_INDEXBUFFER_CONFIG :: 0x0227;
GPUREG_NUMVERTICES :: 0x0228;
GPUREG_GEOSTAGE_CONFIG :: 0x0229;
GPUREG_VERTEX_OFFSET :: 0x022A;
GPUREG_022B :: 0x022B;
GPUREG_022C :: 0x022C;
GPUREG_POST_VERTEX_CACHE_NUM :: 0x022D;
GPUREG_DRAWARRAYS :: 0x022E;
GPUREG_DRAWELEMENTS :: 0x022F;
GPUREG_0230 :: 0x0230;
GPUREG_VTX_FUNC :: 0x0231;
GPUREG_FIXEDATTRIB_INDEX :: 0x0232;
GPUREG_FIXEDATTRIB_DATA0 :: 0x0233;
GPUREG_FIXEDATTRIB_DATA1 :: 0x0234;
GPUREG_FIXEDATTRIB_DATA2 :: 0x0235;
GPUREG_0236 :: 0x0236;
GPUREG_0237 :: 0x0237;
GPUREG_CMDBUF_SIZE0 :: 0x0238;
GPUREG_CMDBUF_SIZE1 :: 0x0239;
GPUREG_CMDBUF_ADDR0 :: 0x023A;
GPUREG_CMDBUF_ADDR1 :: 0x023B;
GPUREG_CMDBUF_JUMP0 :: 0x023C;
GPUREG_CMDBUF_JUMP1 :: 0x023D;
GPUREG_023E :: 0x023E;
GPUREG_023F :: 0x023F;
GPUREG_0240 :: 0x0240;
GPUREG_0241 :: 0x0241;
GPUREG_VSH_NUM_ATTR :: 0x0242;
GPUREG_0243 :: 0x0243;
GPUREG_VSH_COM_MODE :: 0x0244;
GPUREG_START_DRAW_FUNC0 :: 0x0245;
GPUREG_0246 :: 0x0246;
GPUREG_0247 :: 0x0247;
GPUREG_0248 :: 0x0248;
GPUREG_0249 :: 0x0249;
GPUREG_VSH_OUTMAP_TOTAL1 :: 0x024A;
GPUREG_024B :: 0x024B;
GPUREG_024C :: 0x024C;
GPUREG_024D :: 0x024D;
GPUREG_024E :: 0x024E;
GPUREG_024F :: 0x024F;
GPUREG_0250 :: 0x0250;
GPUREG_VSH_OUTMAP_TOTAL2 :: 0x0251;
GPUREG_GSH_MISC0 :: 0x0252;
GPUREG_GEOSTAGE_CONFIG2 :: 0x0253;
GPUREG_GSH_MISC1 :: 0x0254;
GPUREG_0255 :: 0x0255;
GPUREG_0256 :: 0x0256;
GPUREG_0257 :: 0x0257;
GPUREG_0258 :: 0x0258;
GPUREG_0259 :: 0x0259;
GPUREG_025A :: 0x025A;
GPUREG_025B :: 0x025B;
GPUREG_025C :: 0x025C;
GPUREG_025D :: 0x025D;
GPUREG_PRIMITIVE_CONFIG :: 0x025E;
GPUREG_RESTART_PRIMITIVE :: 0x025F;
GPUREG_0260 :: 0x0260;
GPUREG_0261 :: 0x0261;
GPUREG_0262 :: 0x0262;
GPUREG_0263 :: 0x0263;
GPUREG_0264 :: 0x0264;
GPUREG_0265 :: 0x0265;
GPUREG_0266 :: 0x0266;
GPUREG_0267 :: 0x0267;
GPUREG_0268 :: 0x0268;
GPUREG_0269 :: 0x0269;
GPUREG_026A :: 0x026A;
GPUREG_026B :: 0x026B;
GPUREG_026C :: 0x026C;
GPUREG_026D :: 0x026D;
GPUREG_026E :: 0x026E;
GPUREG_026F :: 0x026F;
GPUREG_0270 :: 0x0270;
GPUREG_0271 :: 0x0271;
GPUREG_0272 :: 0x0272;
GPUREG_0273 :: 0x0273;
GPUREG_0274 :: 0x0274;
GPUREG_0275 :: 0x0275;
GPUREG_0276 :: 0x0276;
GPUREG_0277 :: 0x0277;
GPUREG_0278 :: 0x0278;
GPUREG_0279 :: 0x0279;
GPUREG_027A :: 0x027A;
GPUREG_027B :: 0x027B;
GPUREG_027C :: 0x027C;
GPUREG_027D :: 0x027D;
GPUREG_027E :: 0x027E;
GPUREG_027F :: 0x027F;

GPUREG_GSH_BOOLUNIFORM :: 0x0280;
GPUREG_GSH_INTUNIFORM_I0 :: 0x0281;
GPUREG_GSH_INTUNIFORM_I1 :: 0x0282;
GPUREG_GSH_INTUNIFORM_I2 :: 0x0283;
GPUREG_GSH_INTUNIFORM_I3 :: 0x0284;
GPUREG_0285 :: 0x0285;
GPUREG_0286 :: 0x0286;
GPUREG_0287 :: 0x0287;
GPUREG_0288 :: 0x0288;
GPUREG_GSH_INPUTBUFFER_CONFIG :: 0x0289;
GPUREG_GSH_ENTRYPOINT :: 0x028A;
GPUREG_GSH_ATTRIBUTES_PERMUTATION_LOW :: 0x028B;
GPUREG_GSH_ATTRIBUTES_PERMUTATION_HIGH :: 0x028C;
GPUREG_GSH_OUTMAP_MASK :: 0x028D;
GPUREG_028E :: 0x028E;
GPUREG_GSH_CODETRANSFER_END :: 0x028F;
GPUREG_GSH_FLOATUNIFORM_CONFIG :: 0x0290;
GPUREG_GSH_FLOATUNIFORM_DATA :: 0x0291;
GPUREG_0299 :: 0x0299;
GPUREG_029A :: 0x029A;
GPUREG_GSH_CODETRANSFER_CONFIG :: 0x029B;
GPUREG_GSH_CODETRANSFER_DATA :: 0x029C;
GPUREG_02A4 :: 0x02A4;
GPUREG_GSH_OPDESCS_CONFIG :: 0x02A5;
GPUREG_GSH_OPDESCS_DATA :: 0x02A6;
GPUREG_02AE :: 0x02AE;
GPUREG_02AF :: 0x02AF;

GPUREG_VSH_BOOLUNIFORM :: 0x02B0;
GPUREG_VSH_INTUNIFORM_I0 :: 0x02B1;
GPUREG_VSH_INTUNIFORM_I1 :: 0x02B2;
GPUREG_VSH_INTUNIFORM_I2 :: 0x02B3;
GPUREG_VSH_INTUNIFORM_I3 :: 0x02B4;
GPUREG_02B5 :: 0x02B5;
GPUREG_02B6 :: 0x02B6;
GPUREG_02B7 :: 0x02B7;
GPUREG_02B8 :: 0x02B8;
GPUREG_VSH_INPUTBUFFER_CONFIG :: 0x02B9;
GPUREG_VSH_ENTRYPOINT :: 0x02BA;
GPUREG_VSH_ATTRIBUTES_PERMUTATION_LOW :: 0x02BB;
GPUREG_VSH_ATTRIBUTES_PERMUTATION_HIGH :: 0x02BC;
GPUREG_VSH_OUTMAP_MASK :: 0x02BD;
GPUREG_02BE :: 0x02BE;
GPUREG_VSH_CODETRANSFER_END :: 0x02BF;
GPUREG_VSH_FLOATUNIFORM_CONFIG :: 0x02C0;
GPUREG_VSH_FLOATUNIFORM_DATA :: 0x02C1;
GPUREG_02C9 :: 0x02C9;
GPUREG_02CA :: 0x02CA;
GPUREG_VSH_CODETRANSFER_CONFIG :: 0x02CB;
GPUREG_VSH_CODETRANSFER_DATA :: 0x02CC;
GPUREG_02D4 :: 0x02D4;
GPUREG_VSH_OPDESCS_CONFIG :: 0x02D5;
GPUREG_VSH_OPDESCS_DATA :: 0x02D6;
GPUREG_02DE :: 0x02DE;
GPUREG_02DF :: 0x02DF;

GPUREG_02E0 :: 0x02E0;
GPUREG_02E1 :: 0x02E1;
GPUREG_02E2 :: 0x02E2;
GPUREG_02E3 :: 0x02E3;
GPUREG_02E4 :: 0x02E4;
GPUREG_02E5 :: 0x02E5;
GPUREG_02E6 :: 0x02E6;
GPUREG_02E7 :: 0x02E7;
GPUREG_02E8 :: 0x02E8;
GPUREG_02E9 :: 0x02E9;
GPUREG_02EA :: 0x02EA;
GPUREG_02EB :: 0x02EB;
GPUREG_02EC :: 0x02EC;
GPUREG_02ED :: 0x02ED;
GPUREG_02EE :: 0x02EE;
GPUREG_02EF :: 0x02EF;
GPUREG_02F0 :: 0x02F0;
GPUREG_02F1 :: 0x02F1;
GPUREG_02F2 :: 0x02F2;
GPUREG_02F3 :: 0x02F3;
GPUREG_02F4 :: 0x02F4;
GPUREG_02F5 :: 0x02F5;
GPUREG_02F6 :: 0x02F6;
GPUREG_02F7 :: 0x02F7;
GPUREG_02F8 :: 0x02F8;
GPUREG_02F9 :: 0x02F9;
GPUREG_02FA :: 0x02FA;
GPUREG_02FB :: 0x02FB;
GPUREG_02FC :: 0x02FC;
GPUREG_02FD :: 0x02FD;
GPUREG_02FE :: 0x02FE;
GPUREG_02FF :: 0x02FF;

NDSP_SAMPLE_RATE :: SYSCLOCK_SOC / 512.0;

SWKBD_MAX_WORD_LEN :: 40;

SWKBD_MAX_BUTTON_TEXT_LEN :: 16;

SWKBD_MAX_HINT_TEXT_LEN :: 64;

SWKBD_MAX_CALLBACK_MSG_LEN :: 256;

MIISELECTOR_MAGIC :: 0x13DE28CF;

MIISELECTOR_TITLE_LEN :: 64;

MIISELECTOR_GUESTMII_SLOTS :: 6;

MIISELECTOR_USERMII_SLOTS :: 100;

MIISELECTOR_GUESTMII_NAME_LEN :: 12;

ARCHIVE_DIRITER_MAGIC :: 0x68637261;

LINK3DS_COMM_PORT :: 17491;

C3D_AspectRatioTop :: 400.0 / 240.0;
C3D_AspectRatioBot :: 320.0 / 240.0;

C3D_MTXSTACK_SIZE :: 8;

C3D_FVUNIF_COUNT :: 96;
C3D_IVUNIF_COUNT :: 4;

C3D_DEFAULT_CMDBUF_SIZE :: 0x40000;

C3DF_LightEnv_IsCP_Any :: 0xFF<<18;

C3DF_LightEnv_LutDirtyAll :: 0x3F<<26;

C2D_DEFAULT_MAX_OBJECTS :: 4096;

vu8 :: u8;
vu16 :: u16;
vu32 :: u32;
vu64 :: u64;

vs8 :: s8;
vs16 :: s16;
vs32 :: s32;
vs64 :: s64;

Handle :: u32;
Result :: s32;
ThreadFunc :: #type (unknown0: *void) -> void #c_call;
voidfn :: #type () -> void #c_call;

/// Structure representing CPU registers
CpuRegisters :: struct {
    r:    [13] u32; ///< r0-r12.
    sp:   u32; ///< sp.
    lr:   u32; ///< lr.
    pc:   u32; ///< pc. May need to be adjusted.
    cpsr: u32; ///< cpsr.
}

/// Structure representing FPU registers
FpuRegisters :: struct {
    union {
        struct {
            d: [16] float64; ///< d0-d15.
        }
        s: [32] float; ///< s0-s31.
    }
    fpscr: u32; ///< fpscr.
    fpexc: u32; ///< fpexc.
}

/// Result code level values.
RL :: enum u8 {
    SUCCESS      :: 0;
    INFO         :: 1;
    FATAL        :: 31;
    RESET        :: 30;
    REINITIALIZE :: 29;
    USAGE        :: 28;
    PERMANENT    :: 27;
    TEMPORARY    :: 26;
    STATUS       :: 25;
}

/// Result code summary values.
RS :: enum u8 {
    SUCCESS       :: 0;
    NOP           :: 1;
    WOULDBLOCK    :: 2;
    OUTOFRESOURCE :: 3;
    NOTFOUND      :: 4;
    INVALIDSTATE  :: 5;
    NOTSUPPORTED  :: 6;
    INVALIDARG    :: 7;
    WRONGARG      :: 8;
    CANCELED      :: 9;
    STATUSCHANGED :: 10;
    INTERNAL      :: 11;
    INVALIDRESVAL :: 63;
}

/// Result code module values.
RM :: enum u8 {
    COMMON        :: 0;
    KERNEL        :: 1;
    UTIL          :: 2;
    FILE_SERVER   :: 3;
    LOADER_SERVER :: 4;
    TCB           :: 5;
    OS            :: 6;
    DBG           :: 7;
    DMNT          :: 8;
    PDN           :: 9;
    GSP           :: 10;
    I2C           :: 11;
    GPIO          :: 12;
    DD            :: 13;
    CODEC         :: 14;
    SPI           :: 15;
    PXI           :: 16;
    FS            :: 17;
    DI            :: 18;
    HID           :: 19;
    CAM           :: 20;
    PI            :: 21;
    PM            :: 22;
    PM_LOW        :: 23;
    FSI           :: 24;
    SRV           :: 25;
    NDM           :: 26;
    NWM           :: 27;
    SOC           :: 28;
    LDR           :: 29;
    ACC           :: 30;
    ROMFS         :: 31;
    AM            :: 32;
    HIO           :: 33;
    UPDATER       :: 34;
    MIC           :: 35;
    FND           :: 36;
    MP            :: 37;
    MPWL          :: 38;
    AC            :: 39;
    HTTP          :: 40;
    DSP           :: 41;
    SND           :: 42;
    DLP           :: 43;
    HIO_LOW       :: 44;
    CSND          :: 45;
    SSL           :: 46;
    AM_LOW        :: 47;
    NEX           :: 48;
    FRIENDS       :: 49;
    RDT           :: 50;
    APPLET        :: 51;
    NIM           :: 52;
    PTM           :: 53;
    MIDI          :: 54;
    MC            :: 55;
    SWC           :: 56;
    FATFS         :: 57;
    NGC           :: 58;
    CARD          :: 59;
    CARDNOR       :: 60;
    SDMC          :: 61;
    BOSS          :: 62;
    DBM           :: 63;
    CONFIG        :: 64;
    PS            :: 65;
    CEC           :: 66;
    IR            :: 67;
    UDS           :: 68;
    PL            :: 69;
    CUP           :: 70;
    GYROSCOPE     :: 71;
    MCU           :: 72;
    NS            :: 73;
    NEWS          :: 74;
    RO            :: 75;
    GD            :: 76;
    CARD_SPI      :: 77;
    EC            :: 78;
    WEB_BROWSER   :: 79;
    TEST          :: 80;
    ENC           :: 81;
    PIA           :: 82;
    ACT           :: 83;
    VCTL          :: 84;
    OLV           :: 85;
    NEIA          :: 86;
    NPNS          :: 87;
    AVD           :: 90;
    L2B           :: 91;
    MVD           :: 92;
    NFC           :: 93;
    UART          :: 94;
    SPM           :: 95;
    QTM           :: 96;
    NFP           :: 97;
    APPLICATION   :: 254;
    INVALIDRESVAL :: 255;
}

/// Result code generic description values.
RD :: enum u16 {
    SUCCESS              :: 0;
    INVALID_RESULT_VALUE :: 1023;
    TIMEOUT              :: 1022;
    OUT_OF_RANGE         :: 1021;
    ALREADY_EXISTS       :: 1020;
    CANCEL_REQUESTED     :: 1019;
    NOT_FOUND            :: 1018;
    ALREADY_INITIALIZED  :: 1017;
    NOT_INITIALIZED      :: 1016;
    INVALID_HANDLE       :: 1015;
    INVALID_POINTER      :: 1014;
    INVALID_ADDRESS      :: 1013;
    NOT_IMPLEMENTED      :: 1012;
    OUT_OF_MEMORY        :: 1011;
    MISALIGNED_SIZE      :: 1010;
    MISALIGNED_ADDRESS   :: 1009;
    BUSY                 :: 1008;
    NO_DATA              :: 1007;
    INVALID_COMBINATION  :: 1006;
    INVALID_ENUM_VALUE   :: 1005;
    INVALID_SIZE         :: 1004;
    ALREADY_DONE         :: 1003;
    NOT_AUTHORIZED       :: 1002;
    TOO_LARGE            :: 1001;
    INVALID_SELECTION    :: 1000;
}

/// IPC buffer access rights.
IPC_BufferRights :: enum u8 {
    R  :: 2;
    W  :: 4;
    RW :: 6;
}

/**
* @brief @ref svcControlMemory operation flags
*
* The lowest 8 bits are the operation
*/
MemOp :: enum u32 {
    FREE          :: 1;
    RESERVE       :: 2;
    ALLOC         :: 3;
    MAP           :: 4;
    UNMAP         :: 5;
    PROT          :: 6;
    REGION_APP    :: 256;
    REGION_SYSTEM :: 512;
    REGION_BASE   :: 768;
    OP_MASK       :: 255;
    REGION_MASK   :: 3840;
    LINEAR_FLAG   :: 65536;
    ALLOC_LINEAR  :: 65539;
}

/// The state of a memory block.
MemState :: enum u8 {
    FREE       :: 0;
    RESERVED   :: 1;
    IO         :: 2;
    STATIC     :: 3;
    CODE       :: 4;
    PRIVATE    :: 5;
    SHARED     :: 6;
    CONTINUOUS :: 7;
    ALIASED    :: 8;
    ALIAS      :: 9;
    ALIASCODE  :: 10;
    LOCKED     :: 11;
}

/// Memory permission flags
MemPerm :: enum u32 {
    READ        :: 1;
    WRITE       :: 2;
    EXECUTE     :: 4;
    READWRITE   :: 3;
    READEXECUTE :: 5;
    DONTCARE    :: 268435456;
}

/// Memory regions.
MemRegion :: enum u8 {
    ALL         :: 0;
    APPLICATION :: 1;
    SYSTEM      :: 2;
    BASE        :: 3;
}

/// Memory information.
MemInfo :: struct {
    base_addr: u32; ///< Base address.
    size:      u32; ///< Size.
    perm:      u32; ///< Memory permissions. See @ref MemPerm
    state:     u32; ///< Memory state. See @ref MemState
}

/// Memory page information.
PageInfo :: struct {
    flags: u32; ///< Page flags.
}

/// Arbitration modes.
ArbitrationType :: enum u8 {
    SIGNAL                                  :: 0;
    WAIT_IF_LESS_THAN                       :: 1;
    DECREMENT_AND_WAIT_IF_LESS_THAN         :: 2;
    WAIT_IF_LESS_THAN_TIMEOUT               :: 3;
    DECREMENT_AND_WAIT_IF_LESS_THAN_TIMEOUT :: 4;
}

/// Reset types (for use with events and timers)
ResetType :: enum u8 {
    ONESHOT :: 0;
    STICKY  :: 1;
    PULSE   :: 2;
}

/// Types of thread info.
ThreadInfoType :: enum u8 {
    THREADINFO_TYPE_UNKNOWN :: 0;
}

/// Types of resource limit
ResourceLimitType :: enum u32 {
    PRIORITY       :: 0;
    COMMIT         :: 1;
    THREAD         :: 2;
    EVENT          :: 3;
    MUTEX          :: 4;
    SEMAPHORE      :: 5;
    TIMER          :: 6;
    SHAREDMEMORY   :: 7;
    ADDRESSARBITER :: 8;
    CPUTIME        :: 9;
    BIT            :: 2147483648;
}

/// DMA transfer state.
DmaState :: enum u8 {
    STARTING :: 0;
    WFP_DST  :: 1;
    WFP_SRC  :: 2;
    RUNNING  :: 3;
    DONE     :: 4;
}

/// Configuration flags for \ref DmaConfig.
DMACFG :: enum u8 {
    SRC_IS_DEVICE  :: 1;
    DST_IS_DEVICE  :: 2;
    WAIT_AVAILABLE :: 4;
    KEEP_LOCKED    :: 8;
    USE_SRC_CONFIG :: 64;
    USE_DST_CONFIG :: 128;
}

/// Configuration flags for \ref svcRestartDma.
DMARST :: enum u8 {
    UNLOCK        :: 1;
    RESUME_DEVICE :: 2;
}

/**
* @brief Device configuration structure, part of \ref DmaConfig.
* @note
* - if (and only if) src/dst is a device, then src/dst won't be auto-incremented.
* - the kernel uses DMAMOV instead of DMAADNH, when having to decrement (possibly working around an erratum);
* this forces all loops to be unrolled -- you need to keep that in mind when using negative increments, as the kernel
* uses a limit of 100 DMA instruction bytes per channel.
*/
DmaDeviceConfig :: struct {
    deviceId:          s8; ///< DMA device ID.
    allowedAlignments: s8; ///< Mask of allowed access alignments (8, 4, 2, 1).
    burstSize:         s16; ///< Number of bytes transferred in a burst loop. Can be 0 (in which case the max allowed alignment is used as unit).
    transferSize:      s16; ///< Number of bytes transferred in a "transfer" loop (made of burst loops).
    burstStride:       s16; ///< Burst loop stride, can be <= 0.
    transferStride:    s16; ///< "Transfer" loop stride, can be <= 0.
}

/// Configuration stucture for \ref svcStartInterProcessDma.
DmaConfig :: struct {
    channelId:      s8; ///< Channel ID (Arm11: 0-7, Arm9: 0-1). Use -1 to auto-assign to a free channel (Arm11: 3-7, Arm9: 0-1).
    endianSwapSize: s8; ///< Endian swap size (can be 0).
    flags:          u8; ///< DMACFG_* flags.
    _padding:       u8;
    srcCfg:         DmaDeviceConfig; ///< Source device configuration, read if \ref DMACFG_SRC_IS_DEVICE and/or \ref DMACFG_USE_SRC_CONFIG are set.
    dstCfg:         DmaDeviceConfig; ///< Destination device configuration, read if \ref DMACFG_SRC_IS_DEVICE and/or \ref DMACFG_USE_SRC_CONFIG are set.
}

/// Operations for \ref svcControlPerformanceCounter
PerfCounterOperation :: enum u8 {
    ENABLE                      :: 0;
    DISABLE                     :: 1;
    GET_VALUE                   :: 2;
    SET_VALUE                   :: 3;
    GET_OVERFLOW_FLAGS          :: 4;
    RESET                       :: 5;
    GET_EVENT                   :: 6;
    SET_EVENT                   :: 7;
    SET_VIRTUAL_COUNTER_ENABLED :: 8;
}

/// Performance counter register IDs (CP15 and SCU).
PerfCounterRegister :: enum u8 {
    CORE_BASE          :: 0;
    CORE_COUNT_REG_0   :: 0;
    CORE_COUNT_REG_1   :: 1;
    CORE_CYCLE_COUNTER :: 2;
    SCU_BASE           :: 16;
    SCU_0              :: 16;
    SCU_1              :: 17;
    SCU_2              :: 18;
    SCU_3              :: 19;
    SCU_4              :: 20;
    SCU_5              :: 21;
    SCU_6              :: 22;
    SCU_7              :: 23;
}

/**
* @brief Performance counter event IDs (CP15 or SCU).
* 
* @note Refer to:
*     - CP15: https://developer.arm.com/documentation/ddi0360/e/control-coprocessor-cp15/register-descriptions/c15--performance-monitor-control-register--pmnc-
*     - SCU: https://developer.arm.com/documentation/ddi0360/e/mpcore-private-memory-region/about-the-mpcore-private-memory-region/performance-monitor-event-registers
*/
PerfCounterEvent :: enum u16 {
    CORE_BASE                     :: 0;
    CORE_INST_CACHE_MISS          :: 0;
    CORE_STALL_BY_LACK_OF_INST    :: 1;
    CORE_STALL_BY_DATA_HAZARD     :: 2;
    CORE_INST_MICRO_TLB_MISS      :: 3;
    CORE_DATA_MICRO_TLB_MISS      :: 4;
    CORE_BRANCH_INST              :: 5;
    CORE_BRANCH_NOT_PREDICTED     :: 6;
    CORE_BRANCH_MISS_PREDICTED    :: 7;
    CORE_INST_EXECUTED            :: 8;
    CORE_FOLDED_INST_EXECUTED     :: 9;
    CORE_DATA_CACHE_READ          :: 10;
    CORE_DATA_CACHE_READ_MISS     :: 11;
    CORE_DATA_CACHE_WRITE         :: 12;
    CORE_DATA_CACHE_WRITE_MISS    :: 13;
    CORE_DATA_CACHE_LINE_EVICTION :: 14;
    CORE_PC_CHANGED               :: 15;
    CORE_MAIN_TLB_MISS            :: 16;
    CORE_EXTERNAL_REQUEST         :: 17;
    CORE_STALL_BY_LSU_FULL        :: 18;
    CORE_STORE_BUFFER_DRAIN       :: 19;
    CORE_MERGE_IN_STORE_BUFFER    :: 20;
    CORE_CYCLE_COUNT              :: 255;
    CORE_CYCLE_COUNT_64           :: 4095;
    SCU_BASE                      :: 4096;
    SCU_DISABLED                  :: 4096;
    SCU_LINEFILL_MISS_FROM_CORE0  :: 4097;
    SCU_LINEFILL_MISS_FROM_CORE1  :: 4098;
    SCU_LINEFILL_MISS_FROM_CORE2  :: 4099;
    SCU_LINEFILL_MISS_FROM_CORE3  :: 4100;
    SCU_LINEFILL_HIT_FROM_CORE0   :: 4101;
    SCU_LINEFILL_HIT_FROM_CORE1   :: 4102;
    SCU_LINEFILL_HIT_FROM_CORE2   :: 4103;
    SCU_LINEFILL_HIT_FROM_CORE3   :: 4104;
    SCU_LINE_MISSING_FROM_CORE0   :: 4105;
    SCU_LINE_MISSING_FROM_CORE1   :: 4106;
    SCU_LINE_MISSING_FROM_CORE2   :: 4107;
    SCU_LINE_MISSING_FROM_CORE3   :: 4108;
    SCU_LINE_MIGRATION            :: 4109;
    SCU_READ_BUSY_PORT0           :: 4110;
    SCU_READ_BUSY_PORT1           :: 4111;
    SCU_WRITE_BUSY_PORT0          :: 4112;
    SCU_WRITE_BUSY_PORT1          :: 4113;
    SCU_EXTERNAL_READ             :: 4114;
    SCU_EXTERNAL_WRITE            :: 4115;
    SCU_CYCLE_COUNT               :: 4127;
}

/// Event relating to the attachment of a process.
AttachProcessEvent :: struct {
    program_id:   u64; ///< ID of the program.
    process_name: [8] u8; ///< Name of the process.
    process_id:   u32; ///< ID of the process.
    other_flags:  u32; ///< Always 0
}

/// Reasons for an exit process event.
ExitProcessEventReason :: enum u8 {
    EXIT            :: 0;
    TERMINATE       :: 1;
    DEBUG_TERMINATE :: 2;
}

/// Event relating to the exiting of a process.
ExitProcessEvent :: struct {
    reason: ExitProcessEventReason; ///< Reason for exiting. See @ref ExitProcessEventReason
}

/// Event relating to the attachment of a thread.
AttachThreadEvent :: struct {
    creator_thread_id:    u32; ///< ID of the creating thread.
    thread_local_storage: u32; ///< Thread local storage.
    entry_point:          u32; ///< Entry point of the thread.
}

/// Reasons for an exit thread event.
ExitThreadEventReason :: enum u8 {
    EXIT              :: 0;
    TERMINATE         :: 1;
    EXIT_PROCESS      :: 2;
    TERMINATE_PROCESS :: 3;
}

/// Event relating to the exiting of a thread.
ExitThreadEvent :: struct {
    reason: ExitThreadEventReason; ///< Reason for exiting. See @ref ExitThreadEventReason
}

/// Reasons for a user break.
UserBreakType :: enum u8 {
    PANIC     :: 0;
    ASSERT    :: 1;
    USER      :: 2;
    LOAD_RO   :: 3;
    UNLOAD_RO :: 4;
}

/// Reasons for an exception event.
ExceptionEventType :: enum u8 {
    UNDEFINED_INSTRUCTION :: 0;
    PREFETCH_ABORT        :: 1;
    DATA_ABORT            :: 2;
    UNALIGNED_DATA_ACCESS :: 3;
    ATTACH_BREAK          :: 4;
    STOP_POINT            :: 5;
    USER_BREAK            :: 6;
    DEBUGGER_BREAK        :: 7;
    UNDEFINED_SYSCALL     :: 8;
}

/// Event relating to fault exceptions (CPU exceptions other than stop points and undefined syscalls).
FaultExceptionEvent :: struct {
    fault_information: u32; ///< FAR (for DATA ABORT / UNALIGNED DATA ACCESS), attempted syscall or 0
}

/// Stop point types
StopPointType :: enum u8 {
    SVC_FF     :: 0;
    BREAKPOINT :: 1;
    WATCHPOINT :: 2;
}

/// Event relating to stop points
StopPointExceptionEvent :: struct {
    type:              StopPointType; ///< Stop point type, see @ref StopPointType.
    fault_information: u32; ///< FAR for Watchpoints, otherwise 0.
}

/// Event relating to @ref svcBreak
UserBreakExceptionEvent :: struct {
    type:        UserBreakType; ///< User break type, see @ref UserBreakType.
    croInfo:     u32; ///< For LOAD_RO and UNLOAD_RO.
    croInfoSize: u32; ///< For LOAD_RO and UNLOAD_RO.
}

/// Event relating to @ref svcBreakDebugProcess
DebuggerBreakExceptionEvent :: struct {
    thread_ids: [4] s32; ///< IDs of the attached process's threads that were running on each core at the time of the @ref svcBreakDebugProcess call, or -1 (only the first 2 values are meaningful on O3DS).
}

/// Event relating to exceptions.
ExceptionEvent :: struct {
    type:    ExceptionEventType; ///< Type of event. See @ref ExceptionEventType.
    address: u32; ///< Address of the exception.
    union {
        fault:          FaultExceptionEvent; ///< Fault exception event data.
        stop_point:     StopPointExceptionEvent; ///< Stop point exception event data.
        user_break:     UserBreakExceptionEvent; ///< User break exception event data.
        debugger_break: DebuggerBreakExceptionEvent; ///< Debugger break exception event data
    }
}

/// Event relating to the scheduler.
ScheduleInOutEvent :: struct {
    clock_tick: u64; ///< Clock tick that the event occurred.
}

/// Event relating to syscalls.
SyscallInOutEvent :: struct {
    clock_tick: u64; ///< Clock tick that the event occurred.
    syscall:    u32; ///< Syscall sent/received.
}

/// Event relating to debug output.
OutputStringEvent :: struct {
    string_addr: u32; ///< Address of the outputted string.
    string_size: u32; ///< Size of the outputted string.
}

/// Event relating to the mapping of memory.
MapEvent :: struct {
    mapped_addr: u32; ///< Mapped address.
    mapped_size: u32; ///< Mapped size.
    memperm:     MemPerm; ///< Memory permissions. See @ref MemPerm.
    memstate:    MemState; ///< Memory state. See @ref MemState.
}

/// Debug event type.
DebugEventType :: enum u8 {
    ATTACH_PROCESS :: 0;
    ATTACH_THREAD  :: 1;
    EXIT_THREAD    :: 2;
    EXIT_PROCESS   :: 3;
    EXCEPTION      :: 4;
    DLL_LOAD       :: 5;
    DLL_UNLOAD     :: 6;
    SCHEDULE_IN    :: 7;
    SCHEDULE_OUT   :: 8;
    SYSCALL_IN     :: 9;
    SYSCALL_OUT    :: 10;
    OUTPUT_STRING  :: 11;
    MAP            :: 12;
}

/// Information about a debug event.
DebugEventInfo :: struct {
    type:      DebugEventType; ///< Type of event. See @ref DebugEventType
    thread_id: u32; ///< ID of the thread.
    flags:     u32; ///< Flags. Bit0 means that @ref svcContinueDebugEvent needs to be called for this event (except for EXIT PROCESS events, where this flag is disregarded).
    remnants:  [4] u8; ///< Always 0.
    union {
        attach_process: AttachProcessEvent; ///< Process attachment event data.
        attach_thread:  AttachThreadEvent; ///< Thread attachment event data.
        exit_thread:    ExitThreadEvent; ///< Thread exit event data.
        exit_process:   ExitProcessEvent; ///< Process exit event data.
        exception:      ExceptionEvent; ///< Exception event data.
        scheduler:      ScheduleInOutEvent; ///< Schedule in/out event data.
        syscall:        SyscallInOutEvent; ///< Syscall in/out event data.
        output_string:  OutputStringEvent; ///< Output string event data.
        map:            MapEvent; ///< Map event data.
    }
}

/// Debug flags for an attached process, set by @ref svcContinueDebugEvent
DebugFlags :: enum u8 {
    INHIBIT_USER_CPU_EXCEPTION_HANDLERS :: 1;
    SIGNAL_FAULT_EXCEPTION_EVENTS       :: 2;
    SIGNAL_SCHEDULE_EVENTS              :: 4;
    SIGNAL_SYSCALL_EVENTS               :: 8;
    SIGNAL_MAP_EVENTS                   :: 16;
}

ThreadContext :: struct {
    cpu_registers: CpuRegisters; ///< CPU registers.
    fpu_registers: FpuRegisters; ///< FPU registers.
}

/// Control flags for @ref svcGetDebugThreadContext and @ref svcSetDebugThreadContext
ThreadContextControlFlags :: enum u8 {
    CPU_GPRS :: 1;
    CPU_SPRS :: 2;
    FPU_GPRS :: 4;
    FPU_SPRS :: 8;
    CPU_REGS :: 3;
    FPU_REGS :: 12;
    ALL      :: 15;
}

/// Thread parameter field for @ref svcGetDebugThreadParameter
DebugThreadParameter :: enum u8 {
    PRIORITY            :: 0;
    SCHEDULING_MASK_LOW :: 1;
    CPU_IDEAL           :: 2;
    CPU_CREATOR         :: 3;
}

/// Information on address space for process. All sizes are in pages (0x1000 bytes)
CodeSetInfo :: struct {
    name:            [8] u8; ///< ASCII name of codeset
    unk1:            u16;
    unk2:            u16;
    unk3:            u32;
    text_addr:       u32; ///< .text start address
    text_size:       u32; ///< .text number of pages
    ro_addr:         u32; ///< .rodata start address
    ro_size:         u32; ///< .rodata number of pages
    rw_addr:         u32; ///< .data, .bss start address
    rw_size:         u32; ///< .data number of pages
    text_size_total: u32; ///< total pages for .text (aligned)
    ro_size_total:   u32; ///< total pages for .rodata (aligned)
    rw_size_total:   u32; ///< total pages for .data, .bss (aligned)
    unk4:            u32;
    program_id:      u64; ///< Program ID
}

/// Information for the main thread of a process.
StartupInfo :: struct {
    priority:   s32; ///< Priority of the main thread.
    stack_size: u32; ///< Size of the stack of the main thread.
    argc:       s32; ///< Unused on retail kernel.
    argv:       *u16 #align 4; ///< Unused on retail kernel.
    envp:       *u16; ///< Unused on retail kernel.
}

///@name Memory management
///@{
/**
* @brief Controls memory mapping
* @param[out] addr_out The virtual address resulting from the operation. Usually the same as addr0.
* @param addr0    The virtual address to be used for the operation.
* @param addr1    The virtual address to be (un)mirrored by @p addr0 when using @ref MEMOP_MAP or @ref MEMOP_UNMAP.
*                 It has to be pointing to a RW memory.
*                 Use NULL if the operation is @ref MEMOP_FREE or @ref MEMOP_ALLOC.
* @param size     The requested size for @ref MEMOP_ALLOC and @ref MEMOP_ALLOC_LINEAR.
* @param op       Operation flags. See @ref MemOp.
* @param perm     A combination of @ref MEMPERM_READ and @ref MEMPERM_WRITE. Using MEMPERM_EXECUTE will return an error.
*                 Value 0 is used when unmapping memory.
*
* If a memory is mapped for two or more addresses, you have to use MEMOP_UNMAP before being able to MEMOP_FREE it.
* MEMOP_MAP will fail if @p addr1 was already mapped to another address.
*
* More information is available at http://3dbrew.org/wiki/SVC#Memory_Mapping.
*
* @sa svcControlProcessMemory
*/
svcControlMemory :: (addr_out: *u32, addr0: u32, addr1: u32, size: u32, op: MemOp, perm: MemPerm) -> Result #foreign libctru;

/**
* @brief Controls the memory mapping of a process
* @param addr0 The virtual address to map
* @param addr1 The virtual address to be mapped by @p addr0
* @param type Only operations @ref MEMOP_MAP, @ref MEMOP_UNMAP and @ref MEMOP_PROT are allowed.
*
* This is the only SVC which allows mapping executable memory.
* Using @ref MEMOP_PROT will change the memory permissions of an already mapped memory.
*
* @note The pseudo handle for the current process is not supported by this service call.
* @sa svcControlProcess
*/
svcControlProcessMemory :: (process: Handle, addr0: u32, addr1: u32, size: u32, type: u32, perm: u32) -> Result #foreign libctru;

/**
* @brief Creates a block of shared memory
* @param[out] memblock Pointer to store the handle of the block
* @param addr Address of the memory to map, page-aligned. So its alignment must be 0x1000.
* @param size Size of the memory to map, a multiple of 0x1000.
* @param my_perm Memory permissions for the current process
* @param other_perm Memory permissions for the other processes
*
* @note The shared memory block, and its rights, are destroyed when the handle is closed.
*/
svcCreateMemoryBlock :: (memblock: *Handle, addr: u32, size: u32, my_perm: MemPerm, other_perm: MemPerm) -> Result #foreign libctru;

/**
* @brief Maps a block of shared memory
* @param memblock Handle of the block
* @param addr Address of the memory to map, page-aligned. So its alignment must be 0x1000.
* @param my_perm Memory permissions for the current process
* @param other_perm Memory permissions for the other processes
*
* @note The shared memory block, and its rights, are destroyed when the handle is closed.
*/
svcMapMemoryBlock :: (memblock: Handle, addr: u32, my_perm: MemPerm, other_perm: MemPerm) -> Result #foreign libctru;

/**
* @brief Maps a block of process memory, starting from address 0x00100000.
* @param process Handle of the process.
* @param destAddress Address of the block of memory to map, in the current (destination) process.
* @param size Size of the block of memory to map (truncated to a multiple of 0x1000 bytes).
*/
svcMapProcessMemory :: (process: Handle, destAddress: u32, size: u32) -> Result #foreign libctru;

/**
* @brief Unmaps a block of process memory, starting from address 0x00100000.
* @param process Handle of the process.
* @param destAddress Address of the block of memory to unmap, in the current (destination) process.
* @param size Size of the block of memory to unmap (truncated to a multiple of 0x1000 bytes).
*/
svcUnmapProcessMemory :: (process: Handle, destAddress: u32, size: u32) -> Result #foreign libctru;

/**
* @brief Unmaps a block of shared memory
* @param memblock Handle of the block
* @param addr Address of the memory to unmap, page-aligned. So its alignment must be 0x1000.
*/
svcUnmapMemoryBlock :: (memblock: Handle, addr: u32) -> Result #foreign libctru;

/**
* @brief Queries memory information.
* @param[out] info Pointer to output memory info to.
* @param out Pointer to output page info to.
* @param addr Virtual memory address to query.
*/
svcQueryMemory :: (info: *MemInfo, out: *PageInfo, addr: u32) -> Result #foreign libctru;

/**
* @brief Queries process memory information.
* @param[out] info Pointer to output memory info to.
* @param[out] out Pointer to output page info to.
* @param process Process to query memory from.
* @param addr Virtual memory address to query.
*/
svcQueryProcessMemory :: (info: *MemInfo, out: *PageInfo, process: Handle, addr: u32) -> Result #foreign libctru;

///@name Process management
///@{
/**
* @brief Gets the handle of a process.
* @param[out] process   The handle of the process
* @param      processId The ID of the process to open
*/
svcOpenProcess :: (process: *Handle, processId: u32) -> Result #foreign libctru;

/// Exits the current process.
svcExitProcess :: () -> void #foreign libctru;

/**
* @brief Terminates a process.
* @param process Handle of the process to terminate.
*/
svcTerminateProcess :: (process: Handle) -> Result #foreign libctru;

/**
* @brief Gets information about a process.
* @param[out] out Pointer to output process info to.
* @param process Handle of the process to get information about.
* @param type Type of information to retreieve.
*/
svcGetProcessInfo :: (out: *s64, process: Handle, type: u32) -> Result #foreign libctru;

/**
* @brief Gets the ID of a process.
* @param[out] out Pointer to output the process ID to.
* @param handle Handle of the process to get the ID of.
*/
svcGetProcessId :: (out: *u32, handle: Handle) -> Result #foreign libctru;

/**
* @brief Gets a list of running processes.
* @param[out] processCount Pointer to output the process count to.
* @param[out] processIds Pointer to output the process IDs to.
* @param processIdMaxCount Maximum number of process IDs.
*/
svcGetProcessList :: (processCount: *s32, processIds: *u32, processIdMaxCount: s32) -> Result #foreign libctru;

/**
* @brief Gets a list of the threads of a process.
* @param[out] threadCount Pointer to output the thread count to.
* @param[out] threadIds Pointer to output the thread IDs to.
* @param threadIdMaxCount Maximum number of thread IDs.
* @param process Process handle to list the threads of.
*/
svcGetThreadList :: (threadCount: *s32, threadIds: *u32, threadIdMaxCount: s32, process: Handle) -> Result #foreign libctru;

/**
* @brief Creates a port.
* @param[out] portServer Pointer to output the port server handle to.
* @param[out] portClient Pointer to output the port client handle to.
* @param name Name of the port.
* @param maxSessions Maximum number of sessions that can connect to the port.
*/
svcCreatePort :: (portServer: *Handle, portClient: *Handle, name: *u8, maxSessions: s32) -> Result #foreign libctru;

/**
* @brief Connects to a port.
* @param[out] out Pointer to output the port handle to.
* @param portName Name of the port.
*/
svcConnectToPort :: (out: *Handle, portName: *u8) -> Result #foreign libctru;

/**
* @brief Sets up virtual address space for a new process
* @param[out] out Pointer to output the code set handle to.
* @param info Description for setting up the addresses
* @param code_ptr Pointer to .text in shared memory
* @param ro_ptr Pointer to .rodata in shared memory
* @param data_ptr Pointer to .data in shared memory
*/
svcCreateCodeSet :: (out: *Handle, info: *CodeSetInfo, code_ptr: *void, ro_ptr: *void, data_ptr: *void) -> Result #foreign libctru;

/**
* @brief Sets up virtual address space for a new process
* @param[out] out Pointer to output the process handle to.
* @param codeset Codeset created for this process
* @param arm11kernelcaps ARM11 Kernel Capabilities from exheader
* @param arm11kernelcaps_num Number of kernel capabilities
*/
svcCreateProcess :: (out: *Handle, codeset: Handle, arm11kernelcaps: *u32, arm11kernelcaps_num: u32) -> Result #foreign libctru;

/**
* @brief Gets a process's affinity mask.
* @param[out] affinitymask Pointer to store the affinity masks.
* @param process Handle of the process.
* @param processorcount Number of processors.
*/
svcGetProcessAffinityMask :: (affinitymask: *u8, process: Handle, processorcount: s32) -> Result #foreign libctru;

/**
* @brief Sets a process's affinity mask.
* @param process Handle of the process.
* @param affinitymask Pointer to retrieve the affinity masks from.
* @param processorcount Number of processors.
*/
svcSetProcessAffinityMask :: (process: Handle, affinitymask: *u8, processorcount: s32) -> Result #foreign libctru;

/**
* Gets a process's ideal processor.
* @param[out] processorid Pointer to store the ID of the process's ideal processor.
* @param process Handle of the process.
*/
svcGetProcessIdealProcessor :: (processorid: *s32, process: Handle) -> Result #foreign libctru;

/**
* Sets a process's ideal processor.
* @param process Handle of the process.
* @param processorid ID of the process's ideal processor.
*/
svcSetProcessIdealProcessor :: (process: Handle, processorid: s32) -> Result #foreign libctru;

/**
* Launches the main thread of the process.
* @param process Handle of the process.
* @param info Pointer to a StartupInfo structure describing information for the main thread.
*/
svcRun :: (process: Handle, info: *StartupInfo) -> Result #foreign libctru;

///@name Multithreading
///@{
/**
* @brief Creates a new thread.
* @param[out] thread     The thread handle
* @param entrypoint      The function that will be called first upon thread creation
* @param arg             The argument passed to @p entrypoint
* @param stack_top       The top of the thread's stack. Must be 0x8 bytes mem-aligned.
* @param thread_priority Low values gives the thread higher priority.
*                        For userland apps, this has to be within the range [0x18;0x3F]
* @param processor_id    The id of the processor the thread should be ran on. Those are labelled starting from 0.
*                        For old 3ds it has to be <2, and for new 3DS <4.
*                        Value -1 means all CPUs and -2 read from the Exheader.
*
* The processor with ID 1 is the system processor.
* To enable multi-threading on this core you need to call APT_SetAppCpuTimeLimit at least once with a non-zero value.
*
* Since a thread is considered as a waitable object, you can use @ref svcWaitSynchronization
* and @ref svcWaitSynchronizationN to join with it.
*
* @note The kernel will clear the @p stack_top's address low 3 bits to make sure it is 0x8-bytes aligned.
*/
svcCreateThread :: (thread: *Handle, entrypoint: ThreadFunc, arg: u32, stack_top: *u32, thread_priority: s32, processor_id: s32) -> Result #foreign libctru;

/**
* @brief Gets the handle of a thread.
* @param[out] thread  The handle of the thread
* @param      process The ID of the process linked to the thread
*/
svcOpenThread :: (thread: *Handle, process: Handle, threadId: u32) -> Result #foreign libctru;

/**
* @brief Exits the current thread.
*
* This will trigger a state change and hence release all @ref svcWaitSynchronization operations.
* It means that you can join a thread by calling @code svcWaitSynchronization(threadHandle,yourtimeout); @endcode
*/
svcExitThread :: () -> void #foreign libctru;

/**
* @brief Puts the current thread to sleep.
* @param ns The minimum number of nanoseconds to sleep for.
*/
svcSleepThread :: (ns: s64) -> void #foreign libctru;

/// Retrieves the priority of a thread.
svcGetThreadPriority :: (out: *s32, handle: Handle) -> Result #foreign libctru;

/**
* @brief Changes the priority of a thread
* @param prio For userland apps, this has to be within the range [0x18;0x3F]
*
* Low values gives the thread higher priority.
*/
svcSetThreadPriority :: (thread: Handle, prio: s32) -> Result #foreign libctru;

/**
* @brief Gets a thread's affinity mask.
* @param[out] affinitymask Pointer to output the affinity masks to.
* @param thread Handle of the thread.
* @param processorcount Number of processors.
*/
svcGetThreadAffinityMask :: (affinitymask: *u8, thread: Handle, processorcount: s32) -> Result #foreign libctru;

/**
* @brief Sets a thread's affinity mask.
* @param thread Handle of the thread.
* @param affinitymask Pointer to retrieve the affinity masks from.
* @param processorcount Number of processors.
*/
svcSetThreadAffinityMask :: (thread: Handle, affinitymask: *u8, processorcount: s32) -> Result #foreign libctru;

/**
* @brief Gets a thread's ideal processor.
* @param[out] processorid Pointer to output the ID of the thread's ideal processor to.
* @param thread Handle of the thread.
*/
svcGetThreadIdealProcessor :: (processorid: *s32, thread: Handle) -> Result #foreign libctru;

/**
* Sets a thread's ideal processor.
* @param thread Handle of the thread.
* @param processorid ID of the thread's ideal processor.
*/
svcSetThreadIdealProcessor :: (thread: Handle, processorid: s32) -> Result #foreign libctru;

/**
* @brief Returns the ID of the processor the current thread is running on.
* @sa svcCreateThread
*/
svcGetProcessorID :: () -> s32 #foreign libctru;

/**
* @brief Gets the ID of a thread.
* @param[out] out Pointer to output the thread ID of the thread @p handle to.
* @param handle Handle of the thread.
*/
svcGetThreadId :: (out: *u32, handle: Handle) -> Result #foreign libctru;

/**
* @brief Gets the resource limit set of a process.
* @param[out] resourceLimit Pointer to output the resource limit set handle to.
* @param process Process to get the resource limits of.
*/
svcGetResourceLimit :: (resourceLimit: *Handle, process: Handle) -> Result #foreign libctru;

/**
* @brief Gets the value limits of a resource limit set.
* @param[out] values Pointer to output the value limits to.
* @param resourceLimit Resource limit set to use.
* @param names Resource limit names to get the limits of.
* @param nameCount Number of resource limit names.
*/
svcGetResourceLimitLimitValues :: (values: *s64, resourceLimit: Handle, names: *ResourceLimitType, nameCount: s32) -> Result #foreign libctru;

/**
* @brief Gets the values of a resource limit set.
* @param[out] values Pointer to output the values to.
* @param resourceLimit Resource limit set to use.
* @param names Resource limit names to get the values of.
* @param nameCount Number of resource limit names.
*/
svcGetResourceLimitCurrentValues :: (values: *s64, resourceLimit: Handle, names: *ResourceLimitType, nameCount: s32) -> Result #foreign libctru;

/**
* @brief Sets the resource limit set of a process.
* @param process Process to set the resource limit set to.
* @param resourceLimit Resource limit set handle.
*/
svcSetProcessResourceLimits :: (process: Handle, resourceLimit: Handle) -> Result #foreign libctru;

/**
* @brief Creates a resource limit set.
* @param[out] resourceLimit Pointer to output the resource limit set handle to.
*/
svcCreateResourceLimit :: (resourceLimit: *Handle) -> Result #foreign libctru;

/**
* @brief Sets the value limits of a resource limit set.
* @param resourceLimit Resource limit set to use.
* @param names Resource limit names to set the limits of.
* @param values Value limits to set. The high 32 bits of RESLIMIT_COMMIT are used to
set APPMEMALLOC in configuration memory, otherwise those bits are unused.
* @param nameCount Number of resource limit names.
*/
svcSetResourceLimitValues :: (resourceLimit: Handle, names: *ResourceLimitType, values: *s64, nameCount: s32) -> Result #foreign libctru;

/**
* @brief Gets the process ID of a thread.
* @param[out] out Pointer to output the process ID of the thread @p handle to.
* @param handle Handle of the thread.
* @sa svcOpenProcess
*/
svcGetProcessIdOfThread :: (out: *u32, handle: Handle) -> Result #foreign libctru;

/**
* @brief Checks if a thread handle is valid.
* This requests always return an error when called, it only checks if the handle is a thread or not.
* @return 0xD8E007ED (BAD_ENUM) if the Handle is a Thread Handle
* @return 0xD8E007F7 (BAD_HANDLE) if it isn't.
*/
svcGetThreadInfo :: (out: *s64, thread: Handle, type: ThreadInfoType) -> Result #foreign libctru;

///@name Synchronization
///@{
/**
* @brief Creates a mutex.
* @param[out] mutex Pointer to output the handle of the created mutex to.
* @param initially_locked Whether the mutex should be initially locked.
*/
svcCreateMutex :: (mutex: *Handle, initially_locked: bool) -> Result #foreign libctru;

/**
* @brief Releases a mutex.
* @param handle Handle of the mutex.
*/
svcReleaseMutex :: (handle: Handle) -> Result #foreign libctru;

/**
* @brief Creates a semaphore.
* @param[out] semaphore Pointer to output the handle of the created semaphore to.
* @param initial_count Initial count of the semaphore.
* @param max_count Maximum count of the semaphore.
*/
svcCreateSemaphore :: (semaphore: *Handle, initial_count: s32, max_count: s32) -> Result #foreign libctru;

/**
* @brief Releases a semaphore.
* @param[out] count Pointer to output the current count of the semaphore to.
* @param semaphore Handle of the semaphore.
* @param release_count Number to increase the semaphore count by.
*/
svcReleaseSemaphore :: (count: *s32, semaphore: Handle, release_count: s32) -> Result #foreign libctru;

/**
* @brief Creates an event handle.
* @param[out] event Pointer to output the created event handle to.
* @param reset_type Type of reset the event uses (RESET_ONESHOT/RESET_STICKY).
*/
svcCreateEvent :: (event: *Handle, reset_type: ResetType) -> Result #foreign libctru;

/**
* @brief Signals an event.
* @param handle Handle of the event to signal.
*/
svcSignalEvent :: (handle: Handle) -> Result #foreign libctru;

/**
* @brief Clears an event.
* @param handle Handle of the event to clear.
*/
svcClearEvent :: (handle: Handle) -> Result #foreign libctru;

/**
* @brief Waits for synchronization on a handle.
* @param handle Handle to wait on.
* @param nanoseconds Maximum nanoseconds to wait for.
*/
svcWaitSynchronization :: (handle: Handle, nanoseconds: s64) -> Result #foreign libctru;

/**
* @brief Waits for synchronization on multiple handles.
* @param[out] out Pointer to output the index of the synchronized handle to.
* @param handles Handles to wait on.
* @param handles_num Number of handles.
* @param wait_all Whether to wait for synchronization on all handles.
* @param nanoseconds Maximum nanoseconds to wait for.
*/
svcWaitSynchronizationN :: (out: *s32, handles: *Handle, handles_num: s32, wait_all: bool, nanoseconds: s64) -> Result #foreign libctru;

/**
* @brief Creates an address arbiter
* @param[out] mutex Pointer to output the handle of the created address arbiter to.
* @sa svcArbitrateAddress
*/
svcCreateAddressArbiter :: (arbiter: *Handle) -> Result #foreign libctru;

/**
* @brief Arbitrate an address, can be used for synchronization
* @param arbiter Handle of the arbiter
* @param addr A pointer to a s32 value.
* @param type Type of action to be performed by the arbiter
* @param value Number of threads to signal if using @ref ARBITRATION_SIGNAL, or the value used for comparison.
* @param timeout_ns Optional timeout in nanoseconds when using TIMEOUT actions, ignored otherwise. If not needed, use \ref svcArbitrateAddressNoTimeout instead.
* @note Usage of this syscall entails an implicit Data Memory Barrier (dmb).
* @warning Please use \ref syncArbitrateAddressWithTimeout instead.
*/
svcArbitrateAddress :: (arbiter: Handle, addr: u32, type: ArbitrationType, value: s32, timeout_ns: s64) -> Result #foreign libctru;

/**
* @brief Same as \ref svcArbitrateAddress but with the timeout_ns parameter undefined.
* @param arbiter Handle of the arbiter
* @param addr A pointer to a s32 value.
* @param type Type of action to be performed by the arbiter
* @param value Number of threads to signal if using @ref ARBITRATION_SIGNAL, or the value used for comparison.
* @note Usage of this syscall entails an implicit Data Memory Barrier (dmb).
* @warning Please use \ref syncArbitrateAddress instead.
*/
svcArbitrateAddressNoTimeout :: (arbiter: Handle, addr: u32, type: ArbitrationType, value: s32) -> Result #foreign libctru;

/**
* @brief Sends a synchronized request to a session handle.
* @param session Handle of the session.
*/
svcSendSyncRequest :: (session: Handle) -> Result #foreign libctru;

/**
* @brief Connects to a port via a handle.
* @param[out] clientSession Pointer to output the client session handle to.
* @param clientPort Port client endpoint to connect to.
*/
svcCreateSessionToPort :: (clientSession: *Handle, clientPort: Handle) -> Result #foreign libctru;

/**
* @brief Creates a linked pair of session endpoints.
* @param[out] serverSession Pointer to output the created server endpoint handle to.
* @param[out] clientSession Pointer to output the created client endpoint handle to.
*/
svcCreateSession :: (serverSession: *Handle, clientSession: *Handle) -> Result #foreign libctru;

/**
* @brief Accepts a session.
* @param[out] session Pointer to output the created session handle to.
* @param port Handle of the port to accept a session from.
*/
svcAcceptSession :: (session: *Handle, port: Handle) -> Result #foreign libctru;

/**
* @brief Replies to and receives a new request.
* @param index Pointer to the index of the request.
* @param handles Session handles to receive requests from.
* @param handleCount Number of handles.
* @param replyTarget Handle of the session to reply to.
*/
svcReplyAndReceive :: (index: *s32, handles: *Handle, handleCount: s32, replyTarget: Handle) -> Result #foreign libctru;

///@name Time
///@{
/**
* @brief Creates a timer.
* @param[out] timer Pointer to output the handle of the created timer to.
* @param reset_type Type of reset to perform on the timer.
*/
svcCreateTimer :: (timer: *Handle, reset_type: ResetType) -> Result #foreign libctru;

/**
* @brief Sets a timer.
* @param timer Handle of the timer to set.
* @param initial Initial value of the timer.
* @param interval Interval of the timer.
*/
svcSetTimer :: (timer: Handle, initial: s64, interval: s64) -> Result #foreign libctru;

/**
* @brief Cancels a timer.
* @param timer Handle of the timer to cancel.
*/
svcCancelTimer :: (timer: Handle) -> Result #foreign libctru;

/**
* @brief Clears a timer.
* @param timer Handle of the timer to clear.
*/
svcClearTimer :: (timer: Handle) -> Result #foreign libctru;

/**
* @brief Gets the current system tick.
* @return The current system tick.
*/
svcGetSystemTick :: () -> u64 #foreign libctru;

///@name System
///@{
/**
* @brief Closes a handle.
* @param handle Handle to close.
*/
svcCloseHandle :: (handle: Handle) -> Result #foreign libctru;

/**
* @brief Duplicates a handle.
* @param[out] out Pointer to output the duplicated handle to.
* @param original Handle to duplicate.
*/
svcDuplicateHandle :: (out: *Handle, original: Handle) -> Result #foreign libctru;

/**
* @brief Gets a handle info.
* @param[out] out Pointer to output the handle info to.
* @param handle Handle to get the info for.
* @param param Parameter clarifying the handle info type.
*/
svcGetHandleInfo :: (out: *s64, handle: Handle, param: u32) -> Result #foreign libctru;

/**
* @brief Gets the system info.
* @param[out] out Pointer to output the system info to.
* @param type Type of system info to retrieve.
* @param param Parameter clarifying the system info type.
*/
svcGetSystemInfo :: (out: *s64, type: u32, param: s32) -> Result #foreign libctru;

/**
* @brief Sets the current kernel state.
* @param type Type of state to set (the other parameters depend on it).
*/
svcKernelSetState :: (type: u32, __args: ..Any) -> Result #foreign libctru;

/**
* @brief Binds an event or semaphore handle to an ARM11 interrupt.
* @param interruptId Interrupt identfier (see https://www.3dbrew.org/wiki/ARM11_Interrupts).
* @param eventOrSemaphore Event or semaphore handle to bind to the given interrupt.
* @param priority Priority of the interrupt for the current process.
* @param isManualClear Indicates whether the interrupt has to be manually cleared or not (= level-high active).
*/
svcBindInterrupt :: (interruptId: u32, eventOrSemaphore: Handle, priority: s32, isManualClear: bool) -> Result #foreign libctru;

/**
* @brief Unbinds an event or semaphore handle from an ARM11 interrupt.
* @param interruptId Interrupt identfier, see (see https://www.3dbrew.org/wiki/ARM11_Interrupts).
* @param eventOrSemaphore Event or semaphore handle to unbind from the given interrupt.
*/
svcUnbindInterrupt :: (interruptId: u32, eventOrSemaphore: Handle) -> Result #foreign libctru;

/**
* @brief Invalidates a process's data cache.
* @param process Handle of the process.
* @param addr Address to invalidate.
* @param size Size of the memory to invalidate.
*/
svcInvalidateProcessDataCache :: (process: Handle, addr: u32, size: u32) -> Result #foreign libctru;

/**
* @brief Cleans a process's data cache.
* @param process Handle of the process.
* @param addr Address to clean.
* @param size Size of the memory to clean.
*/
svcStoreProcessDataCache :: (process: Handle, addr: u32, size: u32) -> Result #foreign libctru;

/**
* @brief Flushes (cleans and invalidates) a process's data cache.
* @param process Handle of the process.
* @param addr Address to flush.
* @param size Size of the memory to flush.
*/
svcFlushProcessDataCache :: (process: Handle, addr: u32, size: u32) -> Result #foreign libctru;

/**
* @brief Begins an inter-process DMA transfer.
* @param[out] dma Pointer to output the handle of the DMA channel object to.
* @param dstProcess Destination process handle.
* @param dstAddr Address in the destination process to write data to.
* @param srcProcess Source process handle.
* @param srcAddr Address in the source to read data from.
* @param size Size of the data to transfer.
* @param cfg Configuration structure.
* @note The handle is signaled when the transfer finishes.
*/
svcStartInterProcessDma :: (dma: *Handle, dstProcess: Handle, dstAddr: u32, srcProcess: Handle, srcAddr: u32, size: u32, cfg: *DmaConfig) -> Result #foreign libctru;

/**
* @brief Stops an inter-process DMA transfer.
* @param dma Handle of the DMA channel object.
*/
svcStopDma :: (dma: Handle) -> Result #foreign libctru;

/**
* @brief Gets the state of an inter-process DMA transfer.
* @param[out] state Pointer to output the state of the DMA transfer to.
* @param dma Handle of the DMA channel object.
*/
svcGetDmaState :: (state: *DmaState, dma: Handle) -> Result #foreign libctru;

/**
* @brief Restarts a DMA transfer, using the same configuration as before.
* @param[out] state Pointer to output the state of the DMA transfer to.
* @param dma Handle of the DMA channel object.
* @param dstAddr Address in the destination process to write data to.
* @param srcAddr Address in the source to read data from.
* @param size Size of the data to transfer.
* @param flags Restart flags, \ref DMARST_UNLOCK and/or \ref DMARST_RESUME_DEVICE.
* @note The first transfer has to be configured with \ref DMACFG_KEEP_LOCKED.
*/
svcRestartDma :: (dma: Handle, dstAddr: u32, srcAddr: u32, size: u32, flags: s8) -> Result #foreign libctru;

/**
* @brief Sets the GPU protection register to restrict the range of the GPU DMA. 11.3+ only.
* @param useApplicationRestriction Whether to use the register value used for APPLICATION titles.
*/
svcSetGpuProt :: (useApplicationRestriction: bool) -> Result #foreign libctru;

/**
* @brief Enables or disables Wi-Fi. 11.4+ only.
* @param enabled Whether to enable or disable Wi-Fi.
*/
svcSetWifiEnabled :: (enabled: bool) -> Result #foreign libctru;

///@name Debugging
///@{
/**
* @brief Breaks execution.
* @param breakReason Reason for breaking.
*/
svcBreak :: (breakReason: UserBreakType) -> void #foreign libctru;

/**
* @brief Breaks execution (LOAD_RO and UNLOAD_RO).
* @param breakReason Debug reason for breaking.
* @param croInfo Library information.
* @param croInfoSize Size of the above structure.
*/
svcBreakRO :: (breakReason: UserBreakType, croInfo: *void, croInfoSize: u32) -> void #foreign libctru "svcBreak";

/**
* @brief Outputs a debug string.
* @param str String to output.
* @param length Length of the string to output, needs to be positive.
*/
svcOutputDebugString :: (str: *u8, length: s32) -> Result #foreign libctru;

/**
* @brief Controls performance monitoring on the CP15 interface and the SCU.
* The meaning of the parameters depend on the operation.
* @param[out] out Output.
* @param op Operation, see details.
* @param param1 First parameter.
* @param param2 Second parameter.
* @details The operations are the following:
*     - \ref PERFCOUNTEROP_ENABLE (void) -> void, tries to enable and lock perfmon. functionality.
*     - \ref PERFCOUNTEROP_DISABLE (void) -> void, disable and forcibly unlocks perfmon. functionality.
*     - \ref PERFCOUNTEROP_GET_VALUE (\ref PerfCounterRegister reg) -> u64, gets the value of a particular counter register.
*     - \ref PERFCOUNTEROP_SET_VALUE (\ref PerfCounterRegister reg, u64 value) -> void, sets the value of a particular counter register.
*     - \ref PERFCOUNTEROP_GET_OVERFLOW_FLAGS (void) -> u32, gets the overflow flags of all CP15 and SCU registers.
*         - Format is a bitfield of \ref PerfCounterRegister.
*     - \ref PERFCOUNTEROP_RESET (u32 valueResetMask, u32 overflowFlagResetMask) -> void, resets the value and/or
*     overflow flags of selected registers.
*         - Format is two bitfields of \ref PerfCounterRegister.
*     - \ref PERFCOUNTEROP_GET_EVENT (\ref PerfCounterRegister reg) -> \ref PerfCounterEvent, gets the event associated
*     to a particular counter register.
*     - \ref PERFCOUNTEROP_SET_EVENT (\ref PerfCounterRegister reg, \ref PerfCounterEvent) -> void, sets the event associated
*     to a particular counter register.
*     - \ref PERFCOUNTEROP_SET_VIRTUAL_COUNTER_ENABLED (bool enabled) -> void, (dis)allows the kernel to track counter overflows
*     and to use 64-bit counter values.
*/
svcControlPerformanceCounter :: (out: *u64, op: PerfCounterOperation, param1: u32, param2: u64) -> Result #foreign libctru;

/**
* @brief Creates a debug handle for an active process.
* @param[out] debug Pointer to output the created debug handle to.
* @param processId ID of the process to debug.
*/
svcDebugActiveProcess :: (debug: *Handle, processId: u32) -> Result #foreign libctru;

/**
* @brief Breaks a debugged process.
* @param debug Debug handle of the process.
*/
svcBreakDebugProcess :: (debug: Handle) -> Result #foreign libctru;

/**
* @brief Terminates a debugged process.
* @param debug Debug handle of the process.
*/
svcTerminateDebugProcess :: (debug: Handle) -> Result #foreign libctru;

/**
* @brief Gets the current debug event of a debugged process.
* @param[out] info Pointer to output the debug event information to.
* @param debug Debug handle of the process.
*/
svcGetProcessDebugEvent :: (info: *DebugEventInfo, debug: Handle) -> Result #foreign libctru;

/**
* @brief Continues the current debug event of a debugged process (not necessarily the same as @ref svcGetProcessDebugEvent).
* @param debug Debug handle of the process.
* @param flags Flags to continue with, see @ref DebugFlags.
*/
svcContinueDebugEvent :: (debug: Handle, flags: DebugFlags) -> Result #foreign libctru;

/**
* @brief Fetches the saved registers of a thread, either inactive or awaiting @ref svcContinueDebugEvent, belonging to a debugged process.
* @param[out] context Values of the registers to fetch, see @ref ThreadContext.
* @param debug Debug handle of the parent process.
* @param threadId ID of the thread to fetch the saved registers of.
* @param controlFlags Which registers to fetch, see @ref ThreadContextControlFlags.
*/
svcGetDebugThreadContext :: (_context: *ThreadContext, debug: Handle, threadId: u32, controlFlags: ThreadContextControlFlags) -> Result #foreign libctru;

/**
* @brief Updates the saved registers of a thread, either inactive or awaiting @ref svcContinueDebugEvent, belonging to a debugged process.
* @param debug Debug handle of the parent process.
* @param threadId ID of the thread to update the saved registers of.
* @param context Values of the registers to update, see @ref ThreadContext.
* @param controlFlags Which registers to update, see @ref ThreadContextControlFlags.
*/
svcSetDebugThreadContext :: (debug: Handle, threadId: u32, _context: *ThreadContext, controlFlags: ThreadContextControlFlags) -> Result #foreign libctru;

/**
* @brief Queries memory information of a debugged process.
* @param[out] info Pointer to output memory info to.
* @param[out] out Pointer to output page info to.
* @param debug Debug handle of the process to query memory from.
* @param addr Virtual memory address to query.
*/
svcQueryDebugProcessMemory :: (info: *MemInfo, out: *PageInfo, debug: Handle, addr: u32) -> Result #foreign libctru;

/**
* @brief Reads from a debugged process's memory.
* @param buffer Buffer to read data to.
* @param debug Debug handle of the process.
* @param addr Address to read from.
* @param size Size of the memory to read.
*/
svcReadProcessMemory :: (buffer: *void, debug: Handle, addr: u32, size: u32) -> Result #foreign libctru;

/**
* @brief Writes to a debugged process's memory.
* @param debug Debug handle of the process.
* @param buffer Buffer to write data from.
* @param addr Address to write to.
* @param size Size of the memory to write.
*/
svcWriteProcessMemory :: (debug: Handle, buffer: *void, addr: u32, size: u32) -> Result #foreign libctru;

/**
* @brief Sets an hardware breakpoint or watchpoint. This is an interface to the BRP/WRP registers, see http://infocenter.arm.com/help/topic/com.arm.doc.ddi0360f/CEGEBGFC.html .
* @param registerId range 0..5 = breakpoints (BRP0-5), 0x100..0x101 = watchpoints (WRP0-1). The previous stop point for the register is disabled.
* @param control Value of the control regiser.
* @param value Value of the value register: either and address (if bit21 of control is clear) or the debug handle of a process to fetch the context ID of.
*/
svcSetHardwareBreakPoint :: (registerId: s32, control: u32, value: u32) -> Result #foreign libctru;

/**
* @brief Gets a debugged thread's parameter.
* @param[out] unused Unused.
* @param[out] out Output value.
* @param debug Debug handle of the process.
* @param threadId ID of the thread
* @param parameter Parameter to fetch, see @ref DebugThreadParameter.
*/
svcGetDebugThreadParam :: (unused: *s64, out: *u32, debug: Handle, threadId: u32, parameter: DebugThreadParameter) -> Result #foreign libctru;

/**
* @brief Executes a function in supervisor mode.
* @param callback Function to execute.
*/
svcBackdoor :: (callback: #type () -> s32 #c_call) -> Result #foreign libctru;

/// ARM9 descriptor flags
ARM9DESC :: enum u16 {
    MOUNT_NAND      :: 1;
    MOUNT_NANDRO_RW :: 2;
    MOUNT_TWLN      :: 4;
    MOUNT_WNAND     :: 8;
    MOUNT_CARDSPI   :: 16;
    USE_SDIF3       :: 32;
    CREATE_SEED     :: 64;
    USE_CARD_SPI    :: 128;
    SD_APPLICATION  :: 256;
    MOUNT_SDMC_RW   :: 512;
}

/// Filesystem access flags
FSACCESS :: enum u32 {
    CATEGORY_SYSTEM_APPLICATION :: 1;
    CATEGORY_HARDWARE_CHECK     :: 2;
    CATEGORY_FILESYSTEM_TOOL    :: 4;
    DEBUG                       :: 8;
    TWLCARD_BACKUP              :: 16;
    TWLNAND_DATA                :: 32;
    BOSS                        :: 64;
    SDMC_RW                     :: 128;
    CORE                        :: 256;
    NANDRO_RO                   :: 512;
    NANDRW                      :: 1024;
    NANDRO_RW                   :: 2048;
    CATEGORY_SYSTEM_SETTINGS    :: 4096;
    CARDBOARD                   :: 8192;
    EXPORT_IMPORT_IVS           :: 16384;
    SDMC_WO                     :: 32768;
    SWITCH_CLEANUP              :: 65536;
    SAVEDATA_MOVE               :: 131072;
    SHOP                        :: 262144;
    SHELL                       :: 524288;
    CATEGORY_HOME_MENU          :: 1048576;
    SEEDDB                      :: 2097152;
}

/// The resource limit category of a title
ResourceLimitCategory :: enum u8 {
    APPLICATION :: 0;
    SYS_APPLET  :: 1;
    LIB_APPLET  :: 2;
    OTHER       :: 3;
}

/// The system mode a title should be launched under
SystemMode :: enum u8 {
    O3DS_PROD :: 0;
    N3DS_PROD :: 1;
    DEV1      :: 2;
    DEV2      :: 3;
    DEV3      :: 4;
    DEV4      :: 5;
}

/// The system info flags and remaster version of a title
ExHeader_SystemInfoFlags :: struct {
    reserved:            [5] u8; ///< Reserved
    compress_exefs_code: bool; ///< Whether the ExeFS's .code section is compressed
    #place compress_exefs_code; /*bitfield 1*/ is_sd_application:   bool; ///< Whether the title is meant to be used on an SD card
    remaster_version:    u16; ///< Remaster version
}

/// Information about a title's section
ExHeader_CodeSectionInfo :: struct {
    address:   u32; ///< The address of the section
    num_pages: u32; ///< The number of pages the section occupies
    size:      u32; ///< The size of the section
}

/// The name of a title and infomation about its section
ExHeader_CodeSetInfo :: struct {
    name:       [8] u8; ///< Title name
    flags:      ExHeader_SystemInfoFlags; ///< System info flags, see @ref ExHeader_SystemInfoFlags
    text:       ExHeader_CodeSectionInfo; ///< .text section info, see @ref ExHeader_CodeSectionInfo
    stack_size: u32; ///< Stack size
    rodata:     ExHeader_CodeSectionInfo; ///< .rodata section info, see @ref ExHeader_CodeSectionInfo
    reserved:   u32; ///< Reserved
    data:       ExHeader_CodeSectionInfo; ///< .data section info, see @ref ExHeader_CodeSectionInfo
    bss_size:   u32; ///< .bss section size
}

/// The savedata size and jump ID of a title
ExHeader_SystemInfo :: struct {
    savedata_size: u64; ///< Savedata size
    jump_id:       u64; ///< Jump ID
    reserved:      [48] u8; ///< Reserved
}

/// The code set info, dependencies and system info of a title (SCI)
ExHeader_SystemControlInfo :: struct {
    codeset_info: ExHeader_CodeSetInfo; ///< Code set info, see @ref ExHeader_CodeSetInfo
    dependencies: [48] u64; ///< Title IDs of the titles that this program depends on
    system_info:  ExHeader_SystemInfo; ///< System info, see @ref ExHeader_SystemInfo
}

/// The ARM11 filesystem info of a title
ExHeader_Arm11StorageInfo :: struct {
    extdata_id:                   u64; ///< Extdata ID
    system_savedata_ids:          [2] u32; ///< IDs of the system savedata accessible by the title
    accessible_savedata_ids:      u64; ///< IDs of the savedata accessible by the title, 20 bits each, followed by "Use other variation savedata"
    fs_access_info:               u32; ///< FS access flags
    reserved:                     u32; ///< Reserved
    no_romfs:                     bool; ///< Don't use any RomFS
    #place no_romfs; /*bitfield 1*/ use_extended_savedata_access: bool; ///< Use the "extdata_id" field to store 3 additional accessible savedata IDs
}

/// The CPU-related and memory-layout-related info of a title
ExHeader_Arm11CoreInfo :: struct {
    core_version:             u32; ///< The low title ID of the target firmware
    use_cpu_clockrate_804MHz: bool; ///< Whether to start the title with the 804MHz clock rate
    #place use_cpu_clockrate_804MHz; /*bitfield 1*/ enable_l2c:               bool; ///< Whether to start the title with the L2C-310 enabled enabled
    flag1_unused:             u8; ///< Unused
    n3ds_system_mode:         SystemMode; ///< The system mode to use on N3DS
    flag2_unused:             u8; ///< Unused
    #place flag2_unused; /*bitfield 4*/ ideal_processor:          u8; ///< The ideal processor to start the title on
    #place flag2_unused; /*bitfield 6*/ affinity_mask:            u8; ///< The affinity mask of the title
    o3ds_system_mode:         SystemMode; ///< The system mode to use on N3DS
    priority:                 u8; ///< The priority of the title's main thread
}

/// The ARM11 system-local capabilities of a title
ExHeader_Arm11SystemLocalCapabilities :: struct {
    title_id:          u64; ///< Title ID
    core_info:         ExHeader_Arm11CoreInfo; ///< Core info, see @ref ExHeader_Arm11CoreInfo
    reslimits:         [16] u16; ///< Resource limit descriptors, only "CpuTime" (first byte) sems to be used
    storage_info:      ExHeader_Arm11StorageInfo; ///< Storage info, see @ref ExHeader_Arm11StorageInfo
    service_access:    [34] [8] u8; ///< List of the services the title has access to. Limited to 32 prior to system version 9.3
    reserved:          [15] u8; ///< Reserved
    reslimit_category: ResourceLimitCategory; ///< Resource limit category, see @ref ExHeader_Arm11SystemLocalCapabilities
}

/// The ARM11 kernel capabilities of a title
ExHeader_Arm11KernelCapabilities :: struct {
    descriptors: [28] u32; ///< ARM11 kernel descriptors, see 3dbrew
    reserved:    [16] u8; ///< Reserved
}

/// The ARM9 access control of a title
ExHeader_Arm9AccessControl :: struct {
    descriptors:        [15] u8; ///< Process9 FS descriptors, see 3dbrew
    descriptor_version: u8; ///< Descriptor version
}

/// The access control information of a title
ExHeader_AccessControlInfo :: struct {
    local_caps:     ExHeader_Arm11SystemLocalCapabilities; ///< ARM11 system-local capabilities, see @ref ExHeader_Arm11SystemLocalCapabilities
    kernel_caps:    ExHeader_Arm11KernelCapabilities; ///< ARM11 kernel capabilities, see @ref ExHeader_Arm11SystemLocalCapabilities
    access_control: ExHeader_Arm9AccessControl; ///< ARM9 access control, see @ref ExHeader_Arm9AccessControl
}

/// Main extended header data, as returned by PXIPM, Loader and FSREG service commands
ExHeader_Info :: struct {
    sci: ExHeader_SystemControlInfo; ///< System control info, see @ref ExHeader_SystemControlInfo
    aci: ExHeader_AccessControlInfo; ///< Access control info, see @ref ExHeader_AccessControlInfo
}

/// Extended header access descriptor
ExHeader_AccessDescriptor :: struct {
    signature:   [256] u8; ///< The signature of the access descriptor (RSA-2048-SHA256)
    ncchModulus: [256] u8; ///< The modulus used for the above signature, with 65537 as public exponent
    acli:        ExHeader_AccessControlInfo; ///< This is compared for equality with the first ACI by Process9, see @ref ExHeader_AccessControlInfo
}

/// The NCCH Extended Header of a title
ExHeader :: struct {
    info:              ExHeader_Info; ///< Main extended header data, see @ref ExHeader_Info
    access_descriptor: ExHeader_AccessDescriptor; ///< Access descriptor, see @ref ExHeader_AccessDescriptor
}

/// Initializes the service API.
srvInit :: () -> Result #foreign libctru;

/// Exits the service API.
srvExit :: () -> void #foreign libctru;

/**
* @brief Makes srvGetServiceHandle non-blocking for the current thread (or blocking, the default), in case of unavailable (full) requested services.
* @param blocking Whether srvGetServiceHandle should be non-blocking.
*                 srvGetServiceHandle will always block if the service hasn't been registered yet,
*                 use srvIsServiceRegistered to check whether that is the case or not.
*/
srvSetBlockingPolicy :: (nonBlocking: bool) -> void #foreign libctru;

/**
* @brief Gets the current service API session handle.
* @return The current service API session handle.
*/
srvGetSessionHandle :: () -> *Handle #foreign libctru;

/**
* @brief Retrieves a service handle, retrieving from the environment handle list if possible.
* @param out Pointer to write the handle to.
* @param name Name of the service.
* @return 0 if no error occured,
*         0xD8E06406 if the caller has no right to access the service,
*         0xD0401834 if the requested service port is full and srvGetServiceHandle is non-blocking (see @ref srvSetBlockingPolicy).
*/
srvGetServiceHandle :: (out: *Handle, name: *u8) -> Result #foreign libctru;

/// Registers the current process as a client to the service API.
srvRegisterClient :: () -> Result #foreign libctru;

/**
* @brief Enables service notificatios, returning a notification semaphore.
* @param semaphoreOut Pointer to output the notification semaphore to.
*/
srvEnableNotification :: (semaphoreOut: *Handle) -> Result #foreign libctru;

/**
* @brief Registers the current process as a service.
* @param out Pointer to write the service handle to.
* @param name Name of the service.
* @param maxSessions Maximum number of sessions the service can handle.
*/
srvRegisterService :: (out: *Handle, name: *u8, maxSessions: s32) -> Result #foreign libctru;

/**
* @brief Unregisters the current process as a service.
* @param name Name of the service.
*/
srvUnregisterService :: (name: *u8) -> Result #foreign libctru;

/**
* @brief Retrieves a service handle.
* @param out Pointer to output the handle to.
* @param name Name of the service.
* * @return 0 if no error occured,
*           0xD8E06406 if the caller has no right to access the service,
*           0xD0401834 if the requested service port is full and srvGetServiceHandle is non-blocking (see @ref srvSetBlockingPolicy).
*/
srvGetServiceHandleDirect :: (out: *Handle, name: *u8) -> Result #foreign libctru;

/**
* @brief Registers a port.
* @param name Name of the port.
* @param clientHandle Client handle of the port.
*/
srvRegisterPort :: (name: *u8, clientHandle: Handle) -> Result #foreign libctru;

/**
* @brief Unregisters a port.
* @param name Name of the port.
*/
srvUnregisterPort :: (name: *u8) -> Result #foreign libctru;

/**
* @brief Retrieves a port handle.
* @param out Pointer to output the handle to.
* @param name Name of the port.
*/
srvGetPort :: (out: *Handle, name: *u8) -> Result #foreign libctru;

/**
* @brief Waits for a port to be registered.
* @param name Name of the port to wait for registration.
*/
srvWaitForPortRegistered :: (name: *u8) -> Result #foreign libctru;

/**
* @brief Subscribes to a notification.
* @param notificationId ID of the notification.
*/
srvSubscribe :: (notificationId: u32) -> Result #foreign libctru;

/**
* @brief Unsubscribes from a notification.
* @param notificationId ID of the notification.
*/
srvUnsubscribe :: (notificationId: u32) -> Result #foreign libctru;

/**
* @brief Receives a notification.
* @param notificationIdOut Pointer to output the ID of the received notification to.
*/
srvReceiveNotification :: (notificationIdOut: *u32) -> Result #foreign libctru;

/**
* @brief Publishes a notification to subscribers.
* @param notificationId ID of the notification.
* @param flags Flags to publish with. (bit 0 = only fire if not fired, bit 1 = do not report an error if there are more than 16 pending notifications)
*/
srvPublishToSubscriber :: (notificationId: u32, flags: u32) -> Result #foreign libctru;

/**
* @brief Publishes a notification to subscribers and retrieves a list of all processes that were notified.
* @param processIdCountOut Pointer to output the number of process IDs to.
* @param processIdsOut Pointer to output the process IDs to. Should have size "60 * sizeof(u32)".
* @param notificationId ID of the notification.
*/
srvPublishAndGetSubscriber :: (processIdCountOut: *u32, processIdsOut: *u32, notificationId: u32) -> Result #foreign libctru;

/**
* @brief Checks whether a service is registered.
* @param registeredOut Pointer to output the registration status to.
* @param name Name of the service to check.
*/
srvIsServiceRegistered :: (registeredOut: *bool, name: *u8) -> Result #foreign libctru;

/**
* @brief Checks whether a port is registered.
* @param registeredOut Pointer to output the registration status to.
* @param name Name of the port to check.
*/
srvIsPortRegistered :: (registeredOut: *bool, name: *u8) -> Result #foreign libctru;

/// Types of errors that can be thrown by err:f.
ERRF_ErrType :: enum u8 {
    GENERIC      :: 0;
    MEM_CORRUPT  :: 1;
    CARD_REMOVED :: 2;
    EXCEPTION    :: 3;
    FAILURE      :: 4;
    LOGGED       :: 5;
}

/// Types of 'Exceptions' thrown for ERRF_ERRTYPE_EXCEPTION
ERRF_ExceptionType :: enum u8 {
    PREFETCH_ABORT :: 0;
    DATA_ABORT     :: 1;
    UNDEFINED      :: 2;
    VFP            :: 3;
}

ERRF_ExceptionInfo :: struct {
    type:     ERRF_ExceptionType; ///< Type of the exception. One of the ERRF_EXCEPTION_* values.
    reserved: [3] u8;
    fsr:      u32; ///< ifsr (prefetch abort) / dfsr (data abort)
    far:      u32; ///< pc = ifar (prefetch abort) / dfar (data abort)
    fpexc:    u32;
    fpinst:   u32;
    fpinst2:  u32;
}

ERRF_ExceptionData :: struct {
    excep: ERRF_ExceptionInfo; ///< Exception info struct
    regs:  CpuRegisters; ///< CPU register dump.
}

ERRF_FatalErrInfo :: struct {
    type:       ERRF_ErrType; ///< Type, one of the ERRF_ERRTYPE_* enum
    revHigh:    u8; ///< High revison ID
    revLow:     u16; ///< Low revision ID
    resCode:    u32; ///< Result code
    pcAddr:     u32; ///< PC address at exception
    procId:     u32; ///< Process ID.
    titleId:    u64; ///< Title ID.
    appTitleId: u64; ///< Application Title ID.
    data:       union {
        exception_data: ERRF_ExceptionData; ///< Data for when type is ERRF_ERRTYPE_EXCEPTION
        failure_mesg:   [96] u8; ///< String for when type is ERRF_ERRTYPE_FAILURE
    }; ///< The different types of data for errors.
}

/// Initializes ERR:f. Unless you plan to call ERRF_Throw yourself, do not use this.
errfInit :: () -> Result #foreign libctru;

/// Exits ERR:f. Unless you plan to call ERRF_Throw yourself, do not use this.
errfExit :: () -> void #foreign libctru;

/**
* @brief Gets the current err:f API session handle.
* @return The current err:f API session handle.
*/
errfGetSessionHandle :: () -> *Handle #foreign libctru;

/**
* @brief Throws a system error and possibly results in ErrDisp triggering.
* @param[in] error Error to throw.
*
* After performing this, the system may panic and need to be rebooted. Extra information will be displayed on the
* top screen with a developer console or the proper patches in a CFW applied.
*
* The error may not be shown and execution aborted until errfExit(void) is called.
*
* You may wish to use ERRF_ThrowResult() or ERRF_ThrowResultWithMessage() instead of
* constructing the ERRF_FatalErrInfo struct yourself.
*/
ERRF_Throw :: (error: *ERRF_FatalErrInfo) -> Result #foreign libctru;

/**
* @brief Throws a system error with the given Result code.
* @param[in] failure Result code to throw.
*
* This calls ERRF_Throw() with error type ERRF_ERRTYPE_GENERIC and fills in the required data.
*
* This function \em does fill in the address where this function was called from.
*
* See https://3dbrew.org/wiki/ERR:Throw#Generic for expected top screen output
* on development units/patched ErrDisp.
*/
ERRF_ThrowResult :: (failure: Result) -> Result #foreign libctru;

/**
* @brief Throws a system error with the given Result code and message.
* @param[in] failure Result code to throw.
* @param[in] message The message to display.
*
* This calls ERRF_Throw() with error type ERRF_ERRTYPE_FAILURE and fills in the required data.
*
* This function does \em not fill in the address where this function was called from because it
* would not be displayed.
*
* The message is only displayed on development units/patched ErrDisp.
*
* See https://3dbrew.org/wiki/ERR:Throw#Result_Failure for expected top screen output
* on development units/patched ErrDisp.
*/
ERRF_ThrowResultWithMessage :: (failure: Result, message: *u8) -> Result #foreign libctru;

/**
* @brief Handles an exception using ErrDisp.
* @param excep Exception information
* @param regs CPU registers
*
* You might want to clear ENVINFO's bit0 to be able to see any debugging information.
* @sa threadOnException
*/
ERRF_ExceptionHandler :: (excep: *ERRF_ExceptionInfo, regs: *CpuRegisters) -> void #foreign libctru;

/// Kernel configuration page (read-only).
osKernelConfig_s :: struct {
    kernel_ver:         u32;
    update_flag:        u32;
    ns_tid:             u64;
    kernel_syscore_ver: u32;
    env_info:           u8;
    unit_info:          u8;
    boot_env:           u8;
    unk_0x17:           u8;
    kernel_ctrsdk_ver:  u32;
    unk_0x1c:           u32;
    firmlaunch_flags:   u32;
    unk_0x24:           [12] u8;
    app_memtype:        u32;
    unk_0x34:           [12] u8;
    memregion_sz:       [3] u32;
    unk_0x4c:           [20] u8;
    firm_ver:           u32;
    firm_syscore_ver:   u32;
    firm_ctrsdk_ver:    u32;
}

/// Time reference information struct (filled in by PTM).
osTimeRef_s :: struct {
    value_ms:    u64; ///< Milliseconds elapsed since January 1900 when this structure was last updated
    value_tick:  u64; ///< System ticks elapsed since boot when this structure was last updated
    sysclock_hz: s64; ///< System clock frequency in Hz adjusted using RTC measurements (usually around \ref SYSCLOCK_ARM11)
    drift_ms:    s64; ///< Measured time drift of the system clock (according to the RTC) in milliseconds since the last update
}

/// Shared system configuration page structure (read-only or read-write depending on exheader).
osSharedConfig_s :: struct {
    timeref_cnt:       vu32;
    running_hw:        u8;
    mcu_hwinfo:        u8;
    unk_0x06:          [26] u8;
    timeref:           [2] osTimeRef_s;
    wifi_macaddr:      [6] u8;
    wifi_strength:     vu8;
    network_state:     vu8;
    unk_0x68:          [24] u8;
    slider_3d:         float;
    led_3d:            vu8;
    led_battery:       vu8;
    unk_flag:          vu8;
    unk_0x87:          u8;
    unk_0x88:          [24] u8;
    menu_tid:          vu64;
    cur_menu_tid:      vu64;
    unk_0xB0:          [16] u8;
    headset_connected: vu8;
}

/// Tick counter.
TickCounter :: struct {
    elapsed:   u64; ///< Elapsed CPU ticks between measurements.
    reference: u64; ///< Point in time used as reference.
}

/// OS_VersionBin. Format of the system version: "<major>.<minor>.<build>-<nupver><region>"
OS_VersionBin :: struct {
    build:       u8;
    minor:       u8;
    mainver:     u8; //"major" in CVER, NUP version in NVer.
    reserved_x3: u8;
    region:      u8; //"ASCII character for the system version region"
    reserved_x5: [3] u8;
}

/**
* @brief Converts an address from virtual (process) memory to physical memory.
* @param vaddr Input virtual address.
* @return The corresponding physical address.
* It is sometimes required by services or when using the GPU command buffer.
*/
osConvertVirtToPhys :: (vaddr: *void) -> u32 #foreign libctru;

/**
* @brief Converts 0x14* vmem to 0x30*.
* @param vaddr Input virtual address.
* @return The corresponding address in the 0x30* range, the input address if it's already within the new vmem, or 0 if it's outside of both ranges.
*/
osConvertOldLINEARMemToNew :: (vaddr: *void) -> *void #foreign libctru;

/**
* @brief Retrieves basic information about a service error.
* @param error Error to retrieve information about.
* @return A string containing a summary of an error.
*
* This can be used to get some details about an error returned by a service call.
*/
osStrError :: (error: Result) -> *u8 #foreign libctru;

/**
* @brief Reads the latest reference timepoint published by PTM.
* @return Structure (see \ref osTimeRef_s).
*/
osGetTimeRef :: () -> osTimeRef_s #foreign libctru;

/**
* @brief Gets the current time.
* @return The number of milliseconds since 1st Jan 1900 00:00.
*/
osGetTime :: () -> u64 #foreign libctru;

/**
* @brief Reads the elapsed time in a tick counter.
* @param cnt The tick counter.
* @return The number of milliseconds elapsed.
*/
osTickCounterRead :: (cnt: *TickCounter) -> float64 #foreign libctru;

/**
* @brief Configures the New 3DS speedup.
* @param enable Specifies whether to enable or disable the speedup.
*/
osSetSpeedupEnable :: (enable: bool) -> void #foreign libctru;

/**
* @brief Gets the NAND system-version stored in NVer/CVer.
* @param nver_versionbin Output OS_VersionBin structure for the data read from NVer.
* @param cver_versionbin Output OS_VersionBin structure for the data read from CVer.
* @return The result-code. This value can be positive if opening "romfs:/version.bin" fails with stdio, since errno would be returned in that case. In some cases the error can be special negative values as well.
*/
osGetSystemVersionData :: (nver_versionbin: *OS_VersionBin, cver_versionbin: *OS_VersionBin) -> Result #foreign libctru;

/**
* @brief This is a wrapper for osGetSystemVersionData.
* @param nver_versionbin Optional output OS_VersionBin structure for the data read from NVer, can be NULL.
* @param cver_versionbin Optional output OS_VersionBin structure for the data read from CVer, can be NULL.
* @param sysverstr Output string where the printed system-version will be written, in the same format displayed by the System Settings title.
* @param sysverstr_maxsize Max size of the above string buffer, *including* NULL-terminator.
* @return See osGetSystemVersionData.
*/
osGetSystemVersionDataString :: (nver_versionbin: *OS_VersionBin, cver_versionbin: *OS_VersionBin, sysverstr: *u8, sysverstr_maxsize: u32) -> Result #foreign libctru;

/// A light lock.
LightLock :: _LOCK_T;

/// A recursive lock.
RecursiveLock :: _LOCK_RECURSIVE_T;

/// A condition variable.
CondVar :: s32;

/// A light event.
LightEvent :: struct {
    state: s32; ///< State of the event: -2=cleared sticky, -1=cleared oneshot, 0=signaled oneshot, 1=signaled sticky
    lock:  LightLock; ///< Lock used for sticky timer operation
}

/// A light semaphore.
LightSemaphore :: struct {
    current_count:   s32; ///< The current release count of the semaphore
    num_threads_acq: s16; ///< Number of threads concurrently acquiring the semaphore
    max_count:       s16; ///< The maximum release count of the semaphore
}

/**
* @brief Function used to implement user-mode synchronization primitives.
* @param addr Pointer to a signed 32-bit value whose address will be used to identify waiting threads.
* @param type Type of action to be performed by the arbiter
* @param value Number of threads to signal if using @ref ARBITRATION_SIGNAL, or the value used for comparison.
*
* This will perform an arbitration based on #type. The comparisons are done between #value and the value at the address #addr.
*
* @code
* s32 val=0;
* // Does *nothing* since val >= 0
* syncArbitrateAddress(&val,ARBITRATION_WAIT_IF_LESS_THAN,0);
* @endcode
*
* @note Usage of this function entails an implicit Data Memory Barrier (dmb).
*/
syncArbitrateAddress :: (addr: *s32, type: ArbitrationType, value: s32) -> Result #foreign libctru;

/**
* @brief Function used to implement user-mode synchronization primitives (with timeout).
* @param addr Pointer to a signed 32-bit value whose address will be used to identify waiting threads.
* @param type Type of action to be performed by the arbiter (must use \ref ARBITRATION_WAIT_IF_LESS_THAN_TIMEOUT or \ref ARBITRATION_DECREMENT_AND_WAIT_IF_LESS_THAN_TIMEOUT)
* @param value Number of threads to signal if using @ref ARBITRATION_SIGNAL, or the value used for comparison.
*
* This will perform an arbitration based on #type. The comparisons are done between #value and the value at the address #addr.
*
* @code
* s32 val=0;
* // Thread will wait for a signal or wake up after 10000000 nanoseconds because val < 1.
* syncArbitrateAddressWithTimeout(&val,ARBITRATION_WAIT_IF_LESS_THAN_TIMEOUT,1,10000000LL);
* @endcode
*
* @note Usage of this function entails an implicit Data Memory Barrier (dmb).
*/
syncArbitrateAddressWithTimeout :: (addr: *s32, type: ArbitrationType, value: s32, timeout_ns: s64) -> Result #foreign libctru;

/**
* @brief Initializes a light lock.
* @param lock Pointer to the lock.
*/
LightLock_Init :: (lock: *LightLock) -> void #foreign libctru;

/**
* @brief Locks a light lock.
* @param lock Pointer to the lock.
*/
LightLock_Lock :: (lock: *LightLock) -> void #foreign libctru;

/**
* @brief Attempts to lock a light lock.
* @param lock Pointer to the lock.
* @return Zero on success, non-zero on failure.
*/
LightLock_TryLock :: (lock: *LightLock) -> s32 #foreign libctru;

/**
* @brief Unlocks a light lock.
* @param lock Pointer to the lock.
*/
LightLock_Unlock :: (lock: *LightLock) -> void #foreign libctru;

/**
* @brief Initializes a recursive lock.
* @param lock Pointer to the lock.
*/
RecursiveLock_Init :: (lock: *RecursiveLock) -> void #foreign libctru;

/**
* @brief Locks a recursive lock.
* @param lock Pointer to the lock.
*/
RecursiveLock_Lock :: (lock: *RecursiveLock) -> void #foreign libctru;

/**
* @brief Attempts to lock a recursive lock.
* @param lock Pointer to the lock.
* @return Zero on success, non-zero on failure.
*/
RecursiveLock_TryLock :: (lock: *RecursiveLock) -> s32 #foreign libctru;

/**
* @brief Unlocks a recursive lock.
* @param lock Pointer to the lock.
*/
RecursiveLock_Unlock :: (lock: *RecursiveLock) -> void #foreign libctru;

/**
* @brief Initializes a condition variable.
* @param cv Pointer to the condition variable.
*/
CondVar_Init :: (cv: *CondVar) -> void #foreign libctru;

/**
* @brief Waits on a condition variable.
* @param cv Pointer to the condition variable.
* @param lock Pointer to the lock to atomically unlock/relock during the wait.
*/
CondVar_Wait :: (cv: *CondVar, lock: *LightLock) -> void #foreign libctru;

/**
* @brief Waits on a condition variable with a timeout.
* @param cv Pointer to the condition variable.
* @param lock Pointer to the lock to atomically unlock/relock during the wait.
* @param timeout_ns Timeout in nanoseconds.
* @return Zero on success, non-zero on failure.
*/
CondVar_WaitTimeout :: (cv: *CondVar, lock: *LightLock, timeout_ns: s64) -> s32 #foreign libctru;

/**
* @brief Wakes up threads waiting on a condition variable.
* @param cv Pointer to the condition variable.
* @param num_threads Maximum number of threads to wake up (or \ref ARBITRATION_SIGNAL_ALL to wake them all).
*/
CondVar_WakeUp :: (cv: *CondVar, num_threads: s32) -> void #foreign libctru;

/**
* @brief Initializes a light event.
* @param event Pointer to the event.
* @param reset_type Type of reset the event uses (RESET_ONESHOT/RESET_STICKY).
*/
LightEvent_Init :: (event: *LightEvent, reset_type: ResetType) -> void #foreign libctru;

/**
* @brief Clears a light event.
* @param event Pointer to the event.
*/
LightEvent_Clear :: (event: *LightEvent) -> void #foreign libctru;

/**
* @brief Wakes up threads waiting on a sticky light event without signaling it. If the event had been signaled before, it is cleared instead.
* @param event Pointer to the event.
*/
LightEvent_Pulse :: (event: *LightEvent) -> void #foreign libctru;

/**
* @brief Signals a light event, waking up threads waiting on it.
* @param event Pointer to the event.
*/
LightEvent_Signal :: (event: *LightEvent) -> void #foreign libctru;

/**
* @brief Attempts to wait on a light event.
* @param event Pointer to the event.
* @return Non-zero if the event was signaled, zero otherwise.
*/
LightEvent_TryWait :: (event: *LightEvent) -> s32 #foreign libctru;

/**
* @brief Waits on a light event.
* @param event Pointer to the event.
*/
LightEvent_Wait :: (event: *LightEvent) -> void #foreign libctru;

/**
* @brief Waits on a light event until either the event is signaled or the timeout is reached.
* @param event Pointer to the event.
* @param timeout_ns Timeout in nanoseconds.
* @return Non-zero on timeout, zero otherwise.
*/
LightEvent_WaitTimeout :: (event: *LightEvent, timeout_ns: s64) -> s32 #foreign libctru;

/**
* @brief Initializes a light semaphore.
* @param event Pointer to the semaphore.
* @param max_count Initial count of the semaphore.
* @param max_count Maximum count of the semaphore.
*/
LightSemaphore_Init :: (semaphore: *LightSemaphore, initial_count: s16, max_count: s16) -> void #foreign libctru;

/**
* @brief Acquires a light semaphore.
* @param semaphore Pointer to the semaphore.
* @param count Acquire count
*/
LightSemaphore_Acquire :: (semaphore: *LightSemaphore, count: s32) -> void #foreign libctru;

/**
* @brief Attempts to acquire a light semaphore.
* @param semaphore Pointer to the semaphore.
* @param count Acquire count
* @return Zero on success, non-zero on failure
*/
LightSemaphore_TryAcquire :: (semaphore: *LightSemaphore, count: s32) -> s32 #foreign libctru;

/**
* @brief Releases a light semaphore.
* @param semaphore Pointer to the semaphore.
* @param count Release count
*/
LightSemaphore_Release :: (semaphore: *LightSemaphore, count: s32) -> void #foreign libctru;

Thread_tag :: struct {}
/// libctru thread handle type
Thread :: *Thread_tag;

/// Exception handler type, necessarily an ARM function that does not return.
ExceptionHandler :: #type (excep: *ERRF_ExceptionInfo, regs: *CpuRegisters) -> void #c_call;

/**
* @brief Creates a new libctru thread.
* @param entrypoint The function that will be called first upon thread creation
* @param arg The argument passed to @p entrypoint
* @param stack_size The size of the stack that will be allocated for the thread (will be rounded to a multiple of 8 bytes)
* @param prio Low values gives the thread higher priority.
*             For userland apps, this has to be within the range [0x18;0x3F].
*             The main thread usually has a priority of 0x30, but not always. Use svcGetThreadPriority() if you need
*             to create a thread with a priority that is explicitly greater or smaller than that of the main thread.
* @param core_id The ID of the processor the thread should be ran on. Processor IDs are labeled starting from 0.
*                On Old3DS it must be <2, and on New3DS it must be <4.
*                Pass -1 to execute the thread on all CPUs and -2 to execute the thread on the default CPU (read from the Exheader).
* @param detached When set to true, the thread is automatically freed when it finishes.
* @return The libctru thread handle on success, NULL on failure.
*
* - Processor #0 is the application core. It is always possible to create a thread on this core.
* - Processor #1 is the system core. If APT_SetAppCpuTimeLimit is used, it is possible to create a single thread on this core.
* - Processor #2 is New3DS exclusive. Normal applications can create threads on this core if the exheader kernel flags bitmask has 0x2000 set.
* - Processor #3 is New3DS exclusive. Normal applications cannot create threads on this core.
* - Processes in the BASE memory region can always create threads on processors #2 and #3.
*
* @note Default exit code of a thread is 0.
* @warning @ref svcExitThread should never be called from the thread, use @ref threadExit instead.
*/
threadCreate :: (entrypoint: ThreadFunc, arg: *void, stack_size: size_t, prio: s32, core_id: s32, detached: bool) -> Thread #foreign libctru;

/**
* @brief Retrieves the OS thread handle of a libctru thread.
* @param thread libctru thread handle
* @return OS thread handle
*/
threadGetHandle :: (thread: Thread) -> Handle #foreign libctru;

/**
* @brief Retrieves the exit code of a finished libctru thread.
* @param thread libctru thread handle
* @return Exit code
*/
threadGetExitCode :: (thread: Thread) -> s32 #foreign libctru;

/**
* @brief Frees a finished libctru thread.
* @param thread libctru thread handle
* @remarks This function should not be called if the thread is detached, as it is freed automatically when it finishes.
*/
threadFree :: (thread: Thread) -> void #foreign libctru;

/**
* @brief Waits for a libctru thread to finish (or returns immediately if it is already finished).
* @param thread libctru thread handle
* @param timeout_ns Timeout in nanoseconds. Pass U64_MAX if a timeout isn't desired
*/
threadJoin :: (thread: Thread, timeout_ns: u64) -> Result #foreign libctru;

/**
*  @brief Changes a thread's status from attached to detached.
*  @param thread libctru thread handle
*/
threadDetach :: (thread: Thread) -> void #foreign libctru;

/**
* @brief Retrieves the libctru thread handle of the current thread.
* @return libctru thread handle of the current thread, or NULL for the main thread
*/
threadGetCurrent :: () -> Thread #foreign libctru;

/**
* @brief Exits the current libctru thread with an exit code (not usable from the main thread).
* @param rc Exit code
*/
threadExit :: (rc: s32) -> void #foreign libctru;

/// Framebuffer information.
GSPGPU_FramebufferInfo :: struct {
    active_framebuf:        u32; ///< Active framebuffer. (0 = first, 1 = second)
    framebuf0_vaddr:        *u32 #align 4; ///< Framebuffer virtual address, for the main screen this is the 3D left framebuffer.
    framebuf1_vaddr:        *u32; ///< For the main screen: 3D right framebuffer address.
    framebuf_widthbytesize: u32; ///< Value for 0x1EF00X90, controls framebuffer width.
    format:                 u32; ///< Framebuffer format, this u16 is written to the low u16 for LCD register 0x1EF00X70.
    framebuf_dispselect:    u32; ///< Value for 0x1EF00X78, controls which framebuffer is displayed.
    unk:                    u32; ///< Unknown.
}

/// Framebuffer format.
GSPGPU_FramebufferFormat :: enum u8 {
    RGBA8_OES   :: 0;
    BGR8_OES    :: 1;
    RGB565_OES  :: 2;
    RGB5_A1_OES :: 3;
    RGBA4_OES   :: 4;
}

/// Capture info entry.
GSPGPU_CaptureInfoEntry :: struct {
    framebuf0_vaddr:        *u32; ///< Left framebuffer.
    framebuf1_vaddr:        *u32 #align 4; ///< Right framebuffer.
    format:                 u32; ///< Framebuffer format.
    framebuf_widthbytesize: u32; ///< Framebuffer pitch.
}

/// Capture info.
GSPGPU_CaptureInfo :: struct {
    screencapture: [2] GSPGPU_CaptureInfoEntry; ///< Capture info entries, one for each screen.
}

/// GSPGPU events.
GSPGPU_Event :: enum u8 {
    PSC0    :: 0;
    PSC1    :: 1;
    VBlank0 :: 2;
    VBlank1 :: 3;
    PPF     :: 4;
    P3D     :: 5;
    DMA     :: 6;
    MAX     :: 7;
}

/// Initializes GSPGPU.
gspInit :: () -> Result #foreign libctru;

/// Exits GSPGPU.
gspExit :: () -> void #foreign libctru;

/**
* @brief Gets a pointer to the current gsp::Gpu session handle.
* @return A pointer to the current gsp::Gpu session handle.
*/
gspGetSessionHandle :: () -> *Handle #foreign libctru;

/// Returns true if the application currently has GPU rights.
gspHasGpuRight :: () -> bool #foreign libctru;

/**
* @brief Presents a buffer to the specified screen.
* @param screen Screen ID (see \ref GSP_SCREEN_TOP and \ref GSP_SCREEN_BOTTOM)
* @param swap Specifies which set of framebuffer registers to configure and activate (0 or 1)
* @param fb_a Pointer to the framebuffer (in stereo mode: left eye)
* @param fb_b Pointer to the secondary framebuffer (only used in stereo mode for the right eye, otherwise pass the same as fb_a)
* @param stride Stride in bytes between scanlines
* @param mode Mode configuration to be written to LCD register
* @return true if a buffer had already been presented to the screen but not processed yet by GSP, false otherwise.
* @note The most recently presented buffer is processed and configured during the specified screen's next VBlank event.
*/
gspPresentBuffer :: (screen: u32, swap: u32, fb_a: *void, fb_b: *void, stride: u32, mode: u32) -> bool #foreign libctru;

/**
* @brief Returns true if a prior \ref gspPresentBuffer command is still pending to be processed by GSP.
* @param screen Screen ID (see \ref GSP_SCREEN_TOP and \ref GSP_SCREEN_BOTTOM)
*/
gspIsPresentPending :: (screen: u32) -> bool #foreign libctru;

/**
* @brief Configures a callback to run when a GSPGPU event occurs.
* @param id ID of the event.
* @param cb Callback to run.
* @param data Data to be passed to the callback.
* @param oneShot When true, the callback is only executed once. When false, the callback is executed every time the event occurs.
*/
gspSetEventCallback :: (id: GSPGPU_Event, cb: ThreadFunc, data: *void, oneShot: bool) -> void #foreign libctru;

/**
* @brief Waits for a GSPGPU event to occur.
* @param id ID of the event.
* @param nextEvent Whether to discard the current event and wait for the next event.
*/
gspWaitForEvent :: (id: GSPGPU_Event, nextEvent: bool) -> void #foreign libctru;

/**
* @brief Waits for any GSPGPU event to occur.
* @return The ID of the event that occurred.
*
* The function returns immediately if there are unprocessed events at the time of call.
*/
gspWaitForAnyEvent :: () -> GSPGPU_Event #foreign libctru;

/// Waits for PSC0
gspWaitForPSC0 :: () #c_call { gspWaitForEvent(GSPGPU_Event.PSC0, false); }

/// Waits for PSC1
gspWaitForPSC1 :: () #c_call { gspWaitForEvent(GSPGPU_Event.PSC1, false); }

/// Waits for VBlank.
gspWaitForVBlank :: () #c_call { gspWaitForVBlank0(); }

/// Waits for VBlank0.
gspWaitForVBlank0 :: () #c_call { gspWaitForEvent(GSPGPU_Event.VBlank0, true); }

/// Waits for VBlank1.
gspWaitForVBlank1 :: () #c_call { gspWaitForEvent(GSPGPU_Event.VBlank1, true); }

/// Waits for PPF.
gspWaitForPPF :: () #c_call { gspWaitForEvent(GSPGPU_Event.PPF, false); }

/// Waits for P3D.
gspWaitForP3D :: () #c_call { gspWaitForEvent(GSPGPU_Event.P3D, false); }

/// Waits for DMA.
gspWaitForDMA :: () #c_call { gspWaitForEvent(GSPGPU_Event.DMA, false); }

/**
* @brief Submits a GX command.
* @param gxCommand GX command to execute.
*/
gspSubmitGxCommand :: (gxCommand: *[8] u32) -> Result #foreign libctru;

/**
* @brief Acquires GPU rights.
* @param flags Flags to acquire with.
*/
GSPGPU_AcquireRight :: (flags: u8) -> Result #foreign libctru;

/// Releases GPU rights.
GSPGPU_ReleaseRight :: () -> Result #foreign libctru;

/**
* @brief Retrieves display capture info.
* @param captureinfo Pointer to output capture info to.
*/
GSPGPU_ImportDisplayCaptureInfo :: (captureinfo: *GSPGPU_CaptureInfo) -> Result #foreign libctru;

/// Saves the VRAM sys area.
GSPGPU_SaveVramSysArea :: () -> Result #foreign libctru;

/// Resets the GPU
GSPGPU_ResetGpuCore :: () -> Result #foreign libctru;

/// Restores the VRAM sys area.
GSPGPU_RestoreVramSysArea :: () -> Result #foreign libctru;

/**
* @brief Sets whether to force the LCD to black.
* @param flags Whether to force the LCD to black. (0 = no, non-zero = yes)
*/
GSPGPU_SetLcdForceBlack :: (flags: u8) -> Result #foreign libctru;

/**
* @brief Updates a screen's framebuffer state.
* @param screenid ID of the screen to update.
* @param framebufinfo Framebuffer information to update with.
*/
GSPGPU_SetBufferSwap :: (screenid: u32, framebufinfo: *GSPGPU_FramebufferInfo) -> Result #foreign libctru;

/**
* @brief Flushes memory from the data cache.
* @param adr Address to flush.
* @param size Size of the memory to flush.
*/
GSPGPU_FlushDataCache :: (adr: *void, size: u32) -> Result #foreign libctru;

/**
* @brief Invalidates memory in the data cache.
* @param adr Address to invalidate.
* @param size Size of the memory to invalidate.
*/
GSPGPU_InvalidateDataCache :: (adr: *void, size: u32) -> Result #foreign libctru;

/**
* @brief Writes to GPU hardware registers.
* @param regAddr Register address to write to.
* @param data Data to write.
* @param size Size of the data to write.
*/
GSPGPU_WriteHWRegs :: (regAddr: u32, data: *u32, size: u8) -> Result #foreign libctru;

/**
* @brief Writes to GPU hardware registers with a mask.
* @param regAddr Register address to write to.
* @param data Data to write.
* @param datasize Size of the data to write.
* @param maskdata Data of the mask.
* @param masksize Size of the mask.
*/
GSPGPU_WriteHWRegsWithMask :: (regAddr: u32, data: *u32, datasize: u8, maskdata: *u32, masksize: u8) -> Result #foreign libctru;

/**
* @brief Reads from GPU hardware registers.
* @param regAddr Register address to read from.
* @param data Buffer to read data to.
* @param size Size of the buffer.
*/
GSPGPU_ReadHWRegs :: (regAddr: u32, data: *u32, size: u8) -> Result #foreign libctru;

/**
* @brief Registers the interrupt relay queue.
* @param eventHandle Handle of the GX command event.
* @param flags Flags to register with.
* @param outMemHandle Pointer to output the shared memory handle to.
* @param threadID Pointer to output the GSP thread ID to.
*/
GSPGPU_RegisterInterruptRelayQueue :: (eventHandle: Handle, flags: u32, outMemHandle: *Handle, threadID: *u8) -> Result #foreign libctru;

/// Unregisters the interrupt relay queue.
GSPGPU_UnregisterInterruptRelayQueue :: () -> Result #foreign libctru;

/// Triggers a handling of commands written to shared memory.
GSPGPU_TriggerCmdReqQueue :: () -> Result #foreign libctru;

/**
* @brief Sets 3D_LEDSTATE to the input state value.
* @param disable False = 3D LED enable, true = 3D LED disable.
*/
GSPGPU_SetLedForceOff :: (disable: bool) -> Result #foreign libctru;

/// Screen IDs.
gfxScreen_t :: enum u8 {
    TOP    :: 0;
    BOTTOM :: 1;
}

/**
* @brief Top screen framebuffer side.
*
* This is only meaningful when stereoscopic 3D is enabled on the top screen.
* In any other case, use \ref GFX_LEFT.
*/
gfx3dSide_t :: enum u8 {
    LEFT  :: 0;
    RIGHT :: 1;
}

/**
* @brief Initializes the LCD framebuffers with default parameters
* This is equivalent to calling: @code gfxInit(GSP_BGR8_OES,GSP_BGR8_OES,false); @endcode
*/
gfxInitDefault :: () -> void #foreign libctru;

/**
* @brief Initializes the LCD framebuffers.
* @param topFormat The format of the top screen framebuffers.
* @param bottomFormat The format of the bottom screen framebuffers.
* @param vramBuffers Whether to allocate the framebuffers in VRAM.
*
* This function allocates memory for the framebuffers in the specified memory region.
* Initially, stereoscopic 3D is disabled and double buffering is enabled.
*
* @note This function internally calls \ref gspInit.
*/
gfxInit :: (topFormat: GSPGPU_FramebufferFormat, bottomFormat: GSPGPU_FramebufferFormat, vrambuffers: bool) -> void #foreign libctru;

/**
* @brief Deinitializes and frees the LCD framebuffers.
* @note This function internally calls \ref gspExit.
*/
gfxExit :: () -> void #foreign libctru;

/**
* @brief Enables or disables the 3D stereoscopic effect on the top screen.
* @param enable Pass true to enable, false to disable.
* @note Stereoscopic 3D is disabled by default.
*/
gfxSet3D :: (enable: bool) -> void #foreign libctru;

/**
* @brief Retrieves the status of the 3D stereoscopic effect on the top screen.
* @return true if 3D enabled, false otherwise.
*/
gfxIs3D :: () -> bool #foreign libctru;

/**
* @brief Retrieves the status of the 800px (double-height) high resolution display mode of the top screen.
* @return true if wide mode enabled, false otherwise.
*/
gfxIsWide :: () -> bool #foreign libctru;

/**
* @brief Enables or disables the 800px (double-height) high resolution display mode of the top screen.
* @param enable Pass true to enable, false to disable.
* @note Wide mode is disabled by default.
* @note Wide and stereoscopic 3D modes are mutually exclusive.
* @note In wide mode pixels are not square, since scanlines are half as tall as they normally are.
* @warning Wide mode does not work on Old 2DS consoles (however it does work on New 2DS XL consoles).
*/
gfxSetWide :: (enable: bool) -> void #foreign libctru;

/**
* @brief Changes the pixel format of a screen.
* @param screen Screen ID (see \ref gfxScreen_t)
* @param format Pixel format (see \ref GSPGPU_FramebufferFormat)
* @note If the currently allocated framebuffers are too small for the specified format,
*       they are freed and new ones are reallocated.
*/
gfxSetScreenFormat :: (screen: gfxScreen_t, format: GSPGPU_FramebufferFormat) -> void #foreign libctru;

/**
* @brief Retrieves the current pixel format of a screen.
* @param screen Screen ID (see \ref gfxScreen_t)
* @return Pixel format (see \ref GSPGPU_FramebufferFormat)
*/
gfxGetScreenFormat :: (screen: gfxScreen_t) -> GSPGPU_FramebufferFormat #foreign libctru;

/**
* @brief Enables or disables double buffering on a screen.
* @param screen Screen ID (see \ref gfxScreen_t)
* @param enable Pass true to enable, false to disable.
* @note Double buffering is enabled by default.
*/
gfxSetDoubleBuffering :: (screen: gfxScreen_t, enable: bool) -> void #foreign libctru;

/**
* @brief Retrieves the framebuffer of the specified screen to which graphics should be rendered.
* @param screen Screen ID (see \ref gfxScreen_t)
* @param side Framebuffer side (see \ref gfx3dSide_t) (pass \ref GFX_LEFT if not using stereoscopic 3D)
* @param width Pointer that will hold the width of the framebuffer in pixels.
* @param height Pointer that will hold the height of the framebuffer in pixels.
* @return A pointer to the current framebuffer of the chosen screen.
*
* Please remember that the returned pointer will change every frame if double buffering is enabled.
*/
gfxGetFramebuffer :: (screen: gfxScreen_t, side: gfx3dSide_t, width: *u16, height: *u16) -> *u8 #foreign libctru;

/**
* @brief Flushes the data cache for the current framebuffers.
* @warning This is **only used during software rendering**. Since this function has significant overhead,
*          it is preferred to call this only once per frame, after all software rendering is completed.
*/
gfxFlushBuffers :: () -> void #foreign libctru;

/**
* @brief Updates the configuration of the specified screen, swapping the buffers if double buffering is enabled.
* @param scr Screen ID (see \ref gfxScreen_t)
* @param hasStereo For the top screen in 3D mode: true if the framebuffer contains individual images
*                  for both eyes, or false if the left image should be duplicated to the right eye.
* @note Previously rendered content will be displayed on the screen after the next VBlank.
* @note This function is still useful even if double buffering is disabled, as it must be used to commit configuration changes.
* @warning Only call this once per screen per frame, otherwise graphical glitches will occur
*          since this API does not implement triple buffering.
*/
gfxScreenSwapBuffers :: (scr: gfxScreen_t, hasStereo: bool) -> void #foreign libctru;

/**
* @brief Same as \ref gfxScreenSwapBuffers, but with hasStereo set to true.
* @param scr Screen ID (see \ref gfxScreen_t)
* @param immediate This parameter no longer has any effect and is thus ignored.
* @deprecated This function has been superseded by \ref gfxScreenSwapBuffers, please use that instead.
*/
gfxConfigScreen :: (scr: gfxScreen_t, immediate: bool) -> void #foreign libctru;

/**
* @brief Updates the configuration of both screens.
* @note This function is equivalent to: \code gfxScreenSwapBuffers(GFX_TOP,true); gfxScreenSwapBuffers(GFX_BOTTOM,true); \endcode
*/
gfxSwapBuffers :: () -> void #foreign libctru;

/// Same as \ref gfxSwapBuffers (formerly different).
gfxSwapBuffersGpu :: () -> void #foreign libctru;

/// A callback for printing a character.
ConsolePrint :: #type (con: *void, c: s32) -> bool #c_call;

/// A font struct for the console.
ConsoleFont :: struct {
    gfx:         *u8; ///< A pointer to the font graphics
    asciiOffset: u16; ///< Offset to the first valid character in the font table
    numChars:    u16; ///< Number of characters in the font graphics
}

/**
* @brief Console structure used to store the state of a console render context.
*
* Default values from consoleGetDefault();
* @code
* PrintConsole defaultConsole =
* {
* 	//Font:
* 	{
* 		(u8*)default_font_bin, //font gfx
* 		0, //first ascii character in the set
* 		128, //number of characters in the font set
*	},
*	0,0, //cursorX cursorY
*	0,0, //prevcursorX prevcursorY
*	40, //console width
*	30, //console height
*	0,  //window x
*	0,  //window y
*	32, //window width
*	24, //window height
*	3, //tab size
*	0, //font character offset
*	0,  //print callback
*	false //console initialized
* };
* @endcode
*/
PrintConsole :: struct {
    font:               ConsoleFont; ///< Font of the console
    frameBuffer:        *u16; ///< Framebuffer address
    cursorX:            s32; ///< Current X location of the cursor (as a tile offset by default)
    cursorY:            s32; ///< Current Y location of the cursor (as a tile offset by default)
    prevCursorX:        s32; ///< Internal state
    prevCursorY:        s32; ///< Internal state
    consoleWidth:       s32; ///< Width of the console hardware layer in characters
    consoleHeight:      s32; ///< Height of the console hardware layer in characters
    windowX:            s32; ///< Window X location in characters (not implemented)
    windowY:            s32; ///< Window Y location in characters (not implemented)
    windowWidth:        s32; ///< Window width in characters (not implemented)
    windowHeight:       s32; ///< Window height in characters (not implemented)
    tabSize:            s32; ///< Size of a tab
    fg:                 u16; ///< Foreground color
    bg:                 u16; ///< Background color
    flags:              s32; ///< Reverse/bright flags
    PrintChar:          ConsolePrint; ///< Callback for printing a character. Should return true if it has handled rendering the graphics (else the print engine will attempt to render via tiles).
    consoleInitialised: bool; ///< True if the console is initialized
}

/// Console debug devices supported by libnds.
debugDevice :: enum u8 {
    NULL    :: 0;
    SVC     :: 1;
    CONSOLE :: 2;
    _3DMOO  :: 1;
}

/**
* @brief Loads the font into the console.
* @param console Pointer to the console to update, if NULL it will update the current console.
* @param font The font to load.
*/
consoleSetFont :: (console: *PrintConsole, font: *ConsoleFont) -> void #foreign libctru;

/**
* @brief Sets the print window.
* @param console Console to set, if NULL it will set the current console window.
* @param x X location of the window.
* @param y Y location of the window.
* @param width Width of the window.
* @param height Height of the window.
*/
consoleSetWindow :: (console: *PrintConsole, x: s32, y: s32, width: s32, height: s32) -> void #foreign libctru;

/**
* @brief Gets a pointer to the console with the default values.
* This should only be used when using a single console or without changing the console that is returned, otherwise use consoleInit().
* @return A pointer to the console with the default values.
*/
consoleGetDefault :: () -> *PrintConsole #foreign libctru;

/**
* @brief Make the specified console the render target.
* @param console A pointer to the console struct (must have been initialized with consoleInit(PrintConsole* console)).
* @return A pointer to the previous console.
*/
consoleSelect :: (console: *PrintConsole) -> *PrintConsole #foreign libctru;

/**
* @brief Initialise the console.
* @param screen The screen to use for the console.
* @param console A pointer to the console data to initialize (if it's NULL, the default console will be used).
* @return A pointer to the current console.
*/
consoleInit :: (screen: gfxScreen_t, console: *PrintConsole) -> *PrintConsole #foreign libctru;

/**
* @brief Initializes debug console output on stderr to the specified device.
* @param device The debug device (or devices) to output debug print statements to.
*/
consoleDebugInit :: (device: debugDevice) -> void #foreign libctru;

/// Clears the screen by using iprintf("\x1b[2J");
consoleClear :: () -> void #foreign libctru;

/// System run-flags.
RUNFLAG :: enum u8 {
    APTWORKAROUND :: 1;
    APTREINIT     :: 2;
    APTCHAINLOAD  :: 4;
}

/**
* @brief Retrieves a handle from the environment handle list.
* @param name Name of the handle.
* @return The retrieved handle.
*/
envGetHandle :: (name: *u8) -> Handle #foreign libctru;

/** @brief Compression types */
decompressType :: enum u8 {
    DUMMY :: 0;
    LZSS  :: 16;
    LZ10  :: 16;
    LZ11  :: 17;
    HUFF1 :: 33;
    HUFF2 :: 34;
    HUFF3 :: 35;
    HUFF4 :: 36;
    HUFF5 :: 37;
    HUFF6 :: 38;
    HUFF7 :: 39;
    HUFF8 :: 40;
    HUFF  :: 40;
    RLE   :: 48;
}

/** @brief I/O vector */
decompressIOVec :: struct {
    data: *void; ///< I/O buffer
    size: size_t; ///< Buffer size
}

/** @brief Data callback */
decompressCallback :: #type (userdata: *void, buffer: *void, size: size_t) -> ssize_t #c_call;

/** @brief Decompression callback for file descriptors
*  @param[in] userdata Address of file descriptor
*  @param[in] buffer   Buffer to write into
*  @param[in] size     Size to read from file descriptor
*  @returns Number of bytes read
*/
decompressCallback_FD :: (userdata: *void, buffer: *void, size: size_t) -> ssize_t #foreign libctru;

/** @brief Decompression callback for stdio FILE*
*  @param[in] userdata FILE*
*  @param[in] buffer   Buffer to write into
*  @param[in] size     Size to read from file descriptor
*  @returns Number of bytes read
*/
decompressCallback_Stdio :: (userdata: *void, buffer: *void, size: size_t) -> ssize_t #foreign libctru;

/** @brief Decode decompression header
*  @param[out] type     Decompression type
*  @param[out] size     Decompressed size
*  @param[in]  callback Data callback (see decompressV())
*  @param[in]  userdata User data passed to callback (see decompressV())
*  @param[in]  insize   Size of userdata (see decompressV())
*  @returns Bytes consumed
*  @retval -1 error
*/
decompressHeader :: (type: *decompressType, size: *size_t, callback: decompressCallback, userdata: *void, insize: size_t) -> ssize_t #foreign libctru;

/** @brief Decompress data
*  @param[in] iov      Output vector
*  @param[in] iovcnt   Number of buffers
*  @param[in] callback Data callback (see note)
*  @param[in] userdata User data passed to callback (see note)
*  @param[in] insize   Size of userdata (see note)
*  @returns Whether succeeded
*
*  @note If callback is null, userdata is a pointer to memory to read from,
*        and insize is the size of that data. If callback is not null,
*        userdata is passed to callback to fetch more data, and insize is
*        unused.
*/
decompressV :: (iov: *decompressIOVec, iovcnt: size_t, callback: decompressCallback, userdata: *void, insize: size_t) -> bool #foreign libctru;

/** @brief Decompress LZSS/LZ10
*  @param[in] iov      Output vector
*  @param[in] iovcnt   Number of buffers
*  @param[in] callback Data callback (see decompressV())
*  @param[in] userdata User data passed to callback (see decompressV())
*  @param[in] insize   Size of userdata (see decompressV())
*  @returns Whether succeeded
*/
decompressV_LZSS :: (iov: *decompressIOVec, iovcnt: size_t, callback: decompressCallback, userdata: *void, insize: size_t) -> bool #foreign libctru;

/** @brief Decompress LZ11
*  @param[in] iov      Output vector
*  @param[in] iovcnt   Number of buffers
*  @param[in] callback Data callback (see decompressV())
*  @param[in] userdata User data passed to callback (see decompressV())
*  @param[in] insize   Size of userdata (see decompressV())
*  @returns Whether succeeded
*/
decompressV_LZ11 :: (iov: *decompressIOVec, iovcnt: size_t, callback: decompressCallback, userdata: *void, insize: size_t) -> bool #foreign libctru;

/** @brief Decompress Huffman
*  @param[in] bits     Data size in bits (usually 4 or 8)
*  @param[in] iov      Output vector
*  @param[in] iovcnt   Number of buffers
*  @param[in] callback Data callback (see decompressV())
*  @param[in] userdata User data passed to callback (see decompressV())
*  @param[in] insize   Size of userdata (see decompressV())
*  @returns Whether succeeded
*/
decompressV_Huff :: (bits: size_t, iov: *decompressIOVec, iovcnt: size_t, callback: decompressCallback, userdata: *void, insize: size_t) -> bool #foreign libctru;

/** @brief Decompress run-length encoding
*  @param[in] iov      Output vector
*  @param[in] iovcnt   Number of buffers
*  @param[in] callback Data callback (see decompressV())
*  @param[in] userdata User data passed to callback (see decompressV())
*  @param[in] insize   Size of userdata (see decompressV())
*  @returns Whether succeeded
*/
decompressV_RLE :: (iov: *decompressIOVec, iovcnt: size_t, callback: decompressCallback, userdata: *void, insize: size_t) -> bool #foreign libctru;

/** Convert a UTF-8 sequence into a UTF-32 codepoint
*
*  @param[out] out Output codepoint
*  @param[in]  in  Input sequence
*
*  @returns number of input code units consumed
*  @returns -1 for error
*/
decode_utf8 :: (out: *u32, in: *u8) -> ssize_t #foreign libctru;

/** Convert a UTF-16 sequence into a UTF-32 codepoint
*
*  @param[out] out Output codepoint
*  @param[in]  in  Input sequence
*
*  @returns number of input code units consumed
*  @returns -1 for error
*/
decode_utf16 :: (out: *u32, in: *u16) -> ssize_t #foreign libctru;

/** Convert a UTF-32 codepoint into a UTF-8 sequence
*
*  @param[out] out Output sequence
*  @param[in]  in  Input codepoint
*
*  @returns number of output code units produced
*  @returns -1 for error
*
*  @note \a out must be able to store 4 code units
*/
encode_utf8 :: (out: *u8, in: u32) -> ssize_t #foreign libctru;

/** Convert a UTF-32 codepoint into a UTF-16 sequence
*
*  @param[out] out Output sequence
*  @param[in]  in  Input codepoint
*
*  @returns number of output code units produced
*  @returns -1 for error
*
*  @note \a out must be able to store 2 code units
*/
encode_utf16 :: (out: *u16, in: u32) -> ssize_t #foreign libctru;

/** Convert a UTF-8 sequence into a UTF-16 sequence
*
*  Fills the output buffer up to \a len code units.
*  Returns the number of code units that the input would produce;
*  if it returns greater than \a len, the output has been
*  truncated.
*
*  @param[out] out Output sequence
*  @param[in]  in  Input sequence (null-terminated)
*  @param[in]  len Output length
*
*  @returns number of output code units produced
*  @returns -1 for error
*
*  @note \a out is not null-terminated
*/
utf8_to_utf16 :: (out: *u16, in: *u8, len: size_t) -> ssize_t #foreign libctru;

/** Convert a UTF-8 sequence into a UTF-32 sequence
*
*  Fills the output buffer up to \a len code units.
*  Returns the number of code units that the input would produce;
*  if it returns greater than \a len, the output has been
*  truncated.
*
*  @param[out] out Output sequence
*  @param[in]  in  Input sequence (null-terminated)
*  @param[in]  len Output length
*
*  @returns number of output code units produced
*  @returns -1 for error
*
*  @note \a out is not null-terminated
*/
utf8_to_utf32 :: (out: *u32, in: *u8, len: size_t) -> ssize_t #foreign libctru;

/** Convert a UTF-16 sequence into a UTF-8 sequence
*
*  Fills the output buffer up to \a len code units.
*  Returns the number of code units that the input would produce;
*  if it returns greater than \a len, the output has been
*  truncated.
*
*  @param[out] out Output sequence
*  @param[in]  in  Input sequence (null-terminated)
*  @param[in]  len Output length
*
*  @returns number of output code units produced
*  @returns -1 for error
*
*  @note \a out is not null-terminated
*/
utf16_to_utf8 :: (out: *u8, in: *u16, len: size_t) -> ssize_t #foreign libctru;

/** Convert a UTF-16 sequence into a UTF-32 sequence
*
*  Fills the output buffer up to \a len code units.
*  Returns the number of code units that the input would produce;
*  if it returns greater than \a len, the output has been
*  truncated.
*
*  @param[out] out Output sequence
*  @param[in]  in  Input sequence (null-terminated)
*  @param[in]  len Output length
*
*  @returns number of output code units produced
*  @returns -1 for error
*
*  @note \a out is not null-terminated
*/
utf16_to_utf32 :: (out: *u32, in: *u16, len: size_t) -> ssize_t #foreign libctru;

/** Convert a UTF-32 sequence into a UTF-8 sequence
*
*  Fills the output buffer up to \a len code units.
*  Returns the number of code units that the input would produce;
*  if it returns greater than \a len, the output has been
*  truncated.
*
*  @param[out] out Output sequence
*  @param[in]  in  Input sequence (null-terminated)
*  @param[in]  len Output length
*
*  @returns number of output code units produced
*  @returns -1 for error
*
*  @note \a out is not null-terminated
*/
utf32_to_utf8 :: (out: *u8, in: *u32, len: size_t) -> ssize_t #foreign libctru;

/** Convert a UTF-32 sequence into a UTF-16 sequence
*
*  @param[out] out Output sequence
*  @param[in]  in  Input sequence (null-terminated)
*  @param[in]  len Output length
*
*  @returns number of output code units produced
*  @returns -1 for error
*
*  @note \a out is not null-terminated
*/
utf32_to_utf16 :: (out: *u16, in: *u32, len: size_t) -> ssize_t #foreign libctru;

/**
* @brief Allocates a 0x80-byte aligned buffer.
* @param size Size of the buffer to allocate.
* @return The allocated buffer.
*/
linearAlloc :: (size: size_t) -> *void #foreign libctru;

/**
* @brief Allocates a buffer aligned to the given size.
* @param size Size of the buffer to allocate.
* @param alignment Alignment to use.
* @return The allocated buffer.
*/
linearMemAlign :: (size: size_t, alignment: size_t) -> *void #foreign libctru;

/**
* @brief Reallocates a buffer.
* Note: Not implemented yet.
* @param mem Buffer to reallocate.
* @param size Size of the buffer to allocate.
* @return The reallocated buffer.
*/
linearRealloc :: (mem: *void, size: size_t) -> *void #foreign libctru;

/**
* @brief Retrieves the allocated size of a buffer.
* @return The size of the buffer.
*/
linearGetSize :: (mem: *void) -> size_t #foreign libctru;

/**
* @brief Frees a buffer.
* @param mem Buffer to free.
*/
linearFree :: (mem: *void) -> void #foreign libctru;

/**
* @brief Gets the current linear free space.
* @return The current linear free space.
*/
linearSpaceFree :: () -> u32 #foreign libctru;

/**
* @brief Initializes the mappable allocator.
* @param addrMin Minimum address.
* @param addrMax Maxium address.
*/
mappableInit :: (addrMin: u32, addrMax: u32) -> void #foreign libctru;

/**
* @brief Finds a mappable memory area.
* @param size Size of the area to find.
* @return The mappable area.
*/
mappableAlloc :: (size: size_t) -> *void #foreign libctru;

/**
* @brief Frees a mappable area (stubbed).
* @param mem Mappable area to free.
*/
mappableFree :: (mem: *void) -> void #foreign libctru;

vramAllocPos :: enum u8 {
    A   :: 1;
    B   :: 2;
    ANY :: 3;
}

/**
* @brief Allocates a 0x80-byte aligned buffer.
* @param size Size of the buffer to allocate.
* @return The allocated buffer.
*/
vramAlloc :: (size: size_t) -> *void #foreign libctru;

/**
* @brief Allocates a 0x80-byte aligned buffer in the given VRAM bank.
* @param size Size of the buffer to allocate.
* @param pos VRAM bank to use (see \ref vramAllocPos).
* @return The allocated buffer.
*/
vramAllocAt :: (size: size_t, pos: vramAllocPos) -> *void #foreign libctru;

/**
* @brief Allocates a buffer aligned to the given size.
* @param size Size of the buffer to allocate.
* @param alignment Alignment to use.
* @return The allocated buffer.
*/
vramMemAlign :: (size: size_t, alignment: size_t) -> *void #foreign libctru;

/**
* @brief Allocates a buffer aligned to the given size in the given VRAM bank.
* @param size Size of the buffer to allocate.
* @param alignment Alignment to use.
* @param pos VRAM bank to use (see \ref vramAllocPos).
* @return The allocated buffer.
*/
vramMemAlignAt :: (size: size_t, alignment: size_t, pos: vramAllocPos) -> *void #foreign libctru;

/**
* @brief Reallocates a buffer.
* Note: Not implemented yet.
* @param mem Buffer to reallocate.
* @param size Size of the buffer to allocate.
* @return The reallocated buffer.
*/
vramRealloc :: (mem: *void, size: size_t) -> *void #foreign libctru;

/**
* @brief Retrieves the allocated size of a buffer.
* @return The size of the buffer.
*/
vramGetSize :: (mem: *void) -> size_t #foreign libctru;

/**
* @brief Frees a buffer.
* @param mem Buffer to free.
*/
vramFree :: (mem: *void) -> void #foreign libctru;

/**
* @brief Gets the current VRAM free space.
* @return The current VRAM free space.
*/
vramSpaceFree :: () -> u32 #foreign libctru;

/// Wifi security modes.
acSecurityMode :: enum u8 {
    OPEN       :: 0;
    WEP_40BIT  :: 1;
    WEP_104BIT :: 2;
    WEP_128BIT :: 3;
    WPA_TKIP   :: 4;
    WPA2_TKIP  :: 5;
    WPA_AES    :: 6;
    WPA2_AES   :: 7;
}

/// Struct to contain the data for connecting to a Wifi network from a stored slot.
acuConfig :: struct {
    reserved: [512] u8;
}

/// Initializes AC.
acInit :: () -> Result #foreign libctru;

/// Exits AC.
acExit :: () -> void #foreign libctru;

/// Waits for the system to connect to the internet.
acWaitInternetConnection :: () -> Result #foreign libctru;

/**
* @brief Gets the connected Wifi status.
* @param out Pointer to output the connected Wifi status to. (0 = not connected, 1 = O3DS Internet, 2 = N3DS Internet)
*/
ACU_GetWifiStatus :: (out: *u32) -> Result #foreign libctru;

/**
* @brief Gets the connected Wifi status.
* @param out Pointer to output the connected Wifi status to. (1 = not connected, 3 = connected)
*/
ACU_GetStatus :: (out: *u32) -> Result #foreign libctru;

/**
* @brief Gets the connected Wifi security mode.
* @param mode Pointer to output the connected Wifi security mode to. (0 = Open Authentication, 1 = WEP 40-bit, 2 = WEP 104-bit, 3 = WEP 128-bit, 4 = WPA TKIP, 5 = WPA2 TKIP, 6 = WPA AES, 7 = WPA2 AES)
*/
ACU_GetSecurityMode :: (mode: *acSecurityMode) -> Result #foreign libctru;

/**
* @brief Gets the connected Wifi SSID.
* @param SSID Pointer to output the connected Wifi SSID to.
*/
ACU_GetSSID :: (SSID: *u8) -> Result #foreign libctru;

/**
* @brief Gets the connected Wifi SSID length.
* @param out Pointer to output the connected Wifi SSID length to.
*/
ACU_GetSSIDLength :: (out: *u32) -> Result #foreign libctru;

/**
* @brief Determines whether proxy is enabled for the connected network.
* @param enable Pointer to output the proxy status to.
*/
ACU_GetProxyEnable :: (enable: *bool) -> Result #foreign libctru;

/**
* @brief Gets the connected network's proxy port.
* @param out Pointer to output the proxy port to.
*/
ACU_GetProxyPort :: (out: *u32) -> Result #foreign libctru;

/**
* @brief Gets the connected network's proxy username.
* @param username Pointer to output the proxy username to. (The size must be at least 0x20-bytes)
*/
ACU_GetProxyUserName :: (username: *u8) -> Result #foreign libctru;

/**
* @brief Gets the connected network's proxy password.
* @param password Pointer to output the proxy password to. (The size must be at least 0x20-bytes)
*/
ACU_GetProxyPassword :: (password: *u8) -> Result #foreign libctru;

/**
* @brief Gets the last error to occur during a connection.
* @param errorCode Pointer to output the error code to.
*/
ACU_GetLastErrorCode :: (errorCode: *u32) -> Result #foreign libctru;

/**
* @brief Gets the last detailed error to occur during a connection.
* @param errorCode Pointer to output the error code to.
*/
ACU_GetLastDetailErrorCode :: (errorCode: *u32) -> Result #foreign libctru;

/**
* @brief Prepares a buffer to hold the configuration data to start a connection.
* @param config Pointer to an acuConfig struct to contain the data.
*/
ACU_CreateDefaultConfig :: (config: *acuConfig) -> Result #foreign libctru;

/**
* @brief Sets something that makes the connection reliable.
* @param config Pointer to an acuConfig struct used with ACU_CreateDefaultConfig previously.
* @param area Always 2 ?
*/
ACU_SetNetworkArea :: (config: *acuConfig, area: u8) -> Result #foreign libctru;

/**
* @brief Sets the slot to use when connecting.
* @param config Pointer to an acuConfig struct used with ACU_CreateDefaultConfig previously.
* @param type Allowed slots flag. BIT(0) for slot 1, BIT(1) for slot 2, BIT(2) for slot 3.
*/
ACU_SetAllowApType :: (config: *acuConfig, type: u8) -> Result #foreign libctru;

/**
* @brief Sets something that makes the connection reliable.
* @param config Pointer to an acuConfig struct used with ACU_CreateDefaultConfig previously.
*/
ACU_SetRequestEulaVersion :: (config: *acuConfig) -> Result #foreign libctru;

/**
* @brief Starts the connection procedure.
* @param config Pointer to an acuConfig struct used with ACU_CreateDefaultConfig previously.
* @param connectionHandle Handle created with svcCreateEvent to wait on until the connection succeeds or fails.
*/
ACU_ConnectAsync :: (config: *acuConfig, connectionHandle: Handle) -> Result #foreign libctru;

/// Open flags.
FS_OPEN :: enum u8 {
    READ   :: 1;
    WRITE  :: 2;
    CREATE :: 4;
}

/// Write flags.
FS_WRITE :: enum u16 {
    FLUSH       :: 1;
    UPDATE_TIME :: 256;
}

/// Attribute flags.
FS_ATTRIBUTE :: enum u32 {
    DIRECTORY :: 1;
    HIDDEN    :: 256;
    ARCHIVE   :: 65536;
    READ_ONLY :: 16777216;
}

/// Media types.
FS_MediaType :: enum u8 {
    NAND      :: 0;
    SD        :: 1;
    GAME_CARD :: 2;
}

/// System media types.
FS_SystemMediaType :: enum u8 {
    CTR_NAND  :: 0;
    TWL_NAND  :: 1;
    SD        :: 2;
    TWL_PHOTO :: 3;
}

/// Archive IDs.
FS_ArchiveID :: enum u32 {
    ROMFS                    :: 3;
    SAVEDATA                 :: 4;
    EXTDATA                  :: 6;
    SHARED_EXTDATA           :: 7;
    SYSTEM_SAVEDATA          :: 8;
    SDMC                     :: 9;
    SDMC_WRITE_ONLY          :: 10;
    BOSS_EXTDATA             :: 305419896;
    CARD_SPIFS               :: 305419897;
    EXTDATA_AND_BOSS_EXTDATA :: 305419899;
    SYSTEM_SAVEDATA2         :: 305419900;
    NAND_RW                  :: 305419901;
    NAND_RO                  :: 305419902;
    NAND_RO_WRITE_ACCESS     :: 305419903;
    SAVEDATA_AND_CONTENT     :: 591751050;
    SAVEDATA_AND_CONTENT2    :: 591751054;
    NAND_CTR_FS              :: 1450741931;
    TWL_PHOTO                :: 1450741932;
    TWL_SOUND                :: 1450741933;
    NAND_TWL_FS              :: 1450741934;
    NAND_W_FS                :: 1450741935;
    GAMECARD_SAVEDATA        :: 1450741937;
    USER_SAVEDATA            :: 1450741938;
    DEMO_SAVEDATA            :: 1450741940;
}

/// Path types.
FS_PathType :: enum u8 {
    INVALID :: 0;
    EMPTY   :: 1;
    BINARY  :: 2;
    ASCII   :: 3;
    UTF16   :: 4;
}

/// Secure value slot.
FS_SecureValueSlot :: enum u16 {
    SECUREVALUE_SLOT_SD :: 4096;
}

/// Card SPI baud rate.
FS_CardSpiBaudRate :: enum u8 {
    _512KHZ :: 0;
    _1MHZ   :: 1;
    _2MHZ   :: 2;
    _4MHZ   :: 3;
    _8MHZ   :: 4;
    _16MHZ  :: 5;
}

/// Card SPI bus mode.
FS_CardSpiBusMode :: enum u8 {
    _1BIT :: 0;
    _4BIT :: 1;
}

/// Card SPI bus mode.
FS_SpecialContentType :: enum u8 {
    UPDATE    :: 1;
    MANUAL    :: 2;
    DLP_CHILD :: 3;
}

FS_CardType :: enum u8 {
    CTR :: 0;
    TWL :: 1;
}

/// FS control actions.
FS_Action :: enum u8 {
    FS_ACTION_UNKNOWN :: 0;
}

/// Archive control actions.
FS_ArchiveAction :: enum u16 {
    COMMIT_SAVE_DATA :: 0;
    GET_TIMESTAMP    :: 1;
    UNKNOWN          :: 30877;
}

/// Secure save control actions.
FS_SecureSaveAction :: enum u8 {
    DELETE :: 0;
    FORMAT :: 1;
}

/// File control actions.
FS_FileAction :: enum u8 {
    FILE_ACTION_UNKNOWN :: 0;
}

/// Directory control actions.
FS_DirectoryAction :: enum u8 {
    DIRECTORY_ACTION_UNKNOWN :: 0;
}

/// Directory entry.
FS_DirectoryEntry :: struct {
    name:       [262] u16; ///< UTF-16 directory name.
    shortName:  [10] u8; ///< File name.
    shortExt:   [4] u8; ///< File extension.
    valid:      u8; ///< Valid flag. (Always 1)
    reserved:   u8; ///< Reserved.
    attributes: u32; ///< Attributes.
    fileSize:   u64; ///< File size.
}

/// Archive resource information.
FS_ArchiveResource :: struct {
    sectorSize:    u32; ///< Size of each sector, in bytes.
    clusterSize:   u32; ///< Size of each cluster, in bytes.
    totalClusters: u32; ///< Total number of clusters.
    freeClusters:  u32; ///< Number of free clusters.
}

/// Program information.
FS_ProgramInfo :: struct {
    programId: u64; ///< Program ID.
    mediaType: FS_MediaType; ///< Media type.
    padding:   [7] u8; ///< Padding.
}

/// Product information.
FS_ProductInfo :: struct {
    productCode:     [16] u8; ///< Product code.
    companyCode:     [2] u8; ///< Company code.
    remasterVersion: u16; ///< Remaster version.
}

/// Integrity verification seed.
FS_IntegrityVerificationSeed :: struct {
    aesCbcMac:  [16] u8; ///< AES-CBC MAC over a SHA256 hash, which hashes the first 0x110-bytes of the cleartext SEED.
    movableSed: [288] u8; ///< The "nand/private/movable.sed", encrypted with AES-CTR using the above MAC for the counter.
}

/// Ext save data information.
FS_ExtSaveDataInfo :: struct {
    mediaType: FS_MediaType; ///< Media type.
    unknown:   u8; ///< Unknown.
    reserved1: u16; ///< Reserved.
    saveId:    u64 #align 4; ///< Save ID.
    reserved2: u32; ///< Reserved.
}

/// System save data information.
FS_SystemSaveDataInfo :: struct {
    mediaType: FS_MediaType; ///< Media type.
    unknown:   u8; ///< Unknown.
    reserved:  u16; ///< Reserved.
    saveId:    u32; ///< Save ID.
}

/// Device move context.
FS_DeviceMoveContext :: struct {
    ivs:              [16] u8; ///< IVs.
    encryptParameter: [16] u8; ///< Encrypt parameter.
}

/// Filesystem path data, detailing the specific target of an operation.
FS_Path :: struct {
    type: FS_PathType; ///< FS path type.
    size: u32; ///< FS path size.
    data: *void; ///< Pointer to FS path data.
}

/// SDMC/NAND speed information
FS_SdMmcSpeedInfo :: struct {
    highSpeedModeEnabled: bool; ///< Whether or not High Speed Mode is enabled.
    usesHighestClockRate: bool; ///< Whether or not a clock divider of 2 is being used.
    sdClkCtrl:            u16; ///< The value of the SD_CLK_CTRL register.
}

/// Filesystem archive handle, providing access to a filesystem's contents.
FS_Archive :: u64;

/// Initializes FS.
fsInit :: () -> Result #foreign libctru;

/// Exits FS.
fsExit :: () -> void #foreign libctru;

/**
* @brief Sets the FSUSER session to use in the current thread.
* @param session The handle of the FSUSER session to use.
*/
fsUseSession :: (session: Handle) -> void #foreign libctru;

/// Disables the FSUSER session override in the current thread.
fsEndUseSession :: () -> void #foreign libctru;

/**
* @brief Exempts an archive from using alternate FS session handles provided with @ref fsUseSession
* Instead, the archive will use the default FS session handle, opened with @ref srvGetSessionHandle
* @param archive Archive to exempt.
*/
fsExemptFromSession :: (archive: FS_Archive) -> void #foreign libctru;

/**
* @brief Unexempts an archive from using alternate FS session handles provided with @ref fsUseSession
* @param archive Archive to remove from the exemption list.
*/
fsUnexemptFromSession :: (archive: FS_Archive) -> void #foreign libctru;

/**
* @brief Creates an FS_Path instance.
* @param type Type of path.
* @param path Path to use.
* @return The created FS_Path instance.
*/
fsMakePath :: (type: FS_PathType, path: *void) -> FS_Path #foreign libctru;

/**
* @brief Gets the current FS session handle.
* @return The current FS session handle.
*/
fsGetSessionHandle :: () -> *Handle #foreign libctru;

/**
* @brief Performs a control operation on the filesystem.
* @param action Action to perform.
* @param input Buffer to read input from.
* @param inputSize Size of the input.
* @param output Buffer to write output to.
* @param outputSize Size of the output.
*/
FSUSER_Control :: (action: FS_Action, input: *void, inputSize: u32, output: *void, outputSize: u32) -> Result #foreign libctru;

/**
* @brief Initializes a FSUSER session.
* @param session The handle of the FSUSER session to initialize.
*/
FSUSER_Initialize :: (session: Handle) -> Result #foreign libctru;

/**
* @brief Opens a file.
* @param out Pointer to output the file handle to.
* @param archive Archive containing the file.
* @param path Path of the file.
* @param openFlags Flags to open the file with.
* @param attributes Attributes of the file.
*/
FSUSER_OpenFile :: (out: *Handle, archive: FS_Archive, path: FS_Path, openFlags: u32, attributes: u32) -> Result #foreign libctru;

/**
* @brief Opens a file directly, bypassing the requirement of an opened archive handle.
* @param out Pointer to output the file handle to.
* @param archiveId ID of the archive containing the file.
* @param archivePath Path of the archive containing the file.
* @param filePath Path of the file.
* @param openFlags Flags to open the file with.
* @param attributes Attributes of the file.
*/
FSUSER_OpenFileDirectly :: (out: *Handle, archiveId: FS_ArchiveID, archivePath: FS_Path, filePath: FS_Path, openFlags: u32, attributes: u32) -> Result #foreign libctru;

/**
* @brief Deletes a file.
* @param archive Archive containing the file.
* @param path Path of the file.
*/
FSUSER_DeleteFile :: (archive: FS_Archive, path: FS_Path) -> Result #foreign libctru;

/**
* @brief Renames a file.
* @param srcArchive Archive containing the source file.
* @param srcPath Path of the source file.
* @param dstArchive Archive containing the destination file.
* @param dstPath Path of the destination file.
*/
FSUSER_RenameFile :: (srcArchive: FS_Archive, srcPath: FS_Path, dstArchive: FS_Archive, dstPath: FS_Path) -> Result #foreign libctru;

/**
* @brief Deletes a directory, failing if it is not empty.
* @param archive Archive containing the directory.
* @param path Path of the directory.
*/
FSUSER_DeleteDirectory :: (archive: FS_Archive, path: FS_Path) -> Result #foreign libctru;

/**
* @brief Deletes a directory, also deleting its contents.
* @param archive Archive containing the directory.
* @param path Path of the directory.
*/
FSUSER_DeleteDirectoryRecursively :: (archive: FS_Archive, path: FS_Path) -> Result #foreign libctru;

/**
* @brief Creates a file.
* @param archive Archive to create the file in.
* @param path Path of the file.
* @param attributes Attributes of the file.
* @param fileSize Size of the file.
*/
FSUSER_CreateFile :: (archive: FS_Archive, path: FS_Path, attributes: u32, fileSize: u64) -> Result #foreign libctru;

/**
* @brief Creates a directory
* @param archive Archive to create the directory in.
* @param path Path of the directory.
* @param attributes Attributes of the directory.
*/
FSUSER_CreateDirectory :: (archive: FS_Archive, path: FS_Path, attributes: u32) -> Result #foreign libctru;

/**
* @brief Renames a directory.
* @param srcArchive Archive containing the source directory.
* @param srcPath Path of the source directory.
* @param dstArchive Archive containing the destination directory.
* @param dstPath Path of the destination directory.
*/
FSUSER_RenameDirectory :: (srcArchive: FS_Archive, srcPath: FS_Path, dstArchive: FS_Archive, dstPath: FS_Path) -> Result #foreign libctru;

/**
* @brief Opens a directory.
* @param out Pointer to output the directory handle to.
* @param archive Archive containing the directory.
* @param path Path of the directory.
*/
FSUSER_OpenDirectory :: (out: *Handle, archive: FS_Archive, path: FS_Path) -> Result #foreign libctru;

/**
* @brief Opens an archive.
* @param archive Pointer to output the opened archive to.
* @param id ID of the archive.
* @param path Path of the archive.
*/
FSUSER_OpenArchive :: (archive: *FS_Archive, id: FS_ArchiveID, path: FS_Path) -> Result #foreign libctru;

/**
* @brief Performs a control operation on an archive.
* @param archive Archive to control.
* @param action Action to perform.
* @param input Buffer to read input from.
* @param inputSize Size of the input.
* @param output Buffer to write output to.
* @param outputSize Size of the output.
*/
FSUSER_ControlArchive :: (archive: FS_Archive, action: FS_ArchiveAction, input: *void, inputSize: u32, output: *void, outputSize: u32) -> Result #foreign libctru;

/**
* @brief Closes an archive.
* @param archive Archive to close.
*/
FSUSER_CloseArchive :: (archive: FS_Archive) -> Result #foreign libctru;

/**
* @brief Gets the number of free bytes within an archive.
* @param freeBytes Pointer to output the free bytes to.
* @param archive Archive to check.
*/
FSUSER_GetFreeBytes :: (freeBytes: *u64, archive: FS_Archive) -> Result #foreign libctru;

/**
* @brief Gets the inserted card type.
* @param type Pointer to output the card type to.
*/
FSUSER_GetCardType :: (type: *FS_CardType) -> Result #foreign libctru;

/**
* @brief Gets the SDMC archive resource information.
* @param archiveResource Pointer to output the archive resource information to.
*/
FSUSER_GetSdmcArchiveResource :: (archiveResource: *FS_ArchiveResource) -> Result #foreign libctru;

/**
* @brief Gets the NAND archive resource information.
* @param archiveResource Pointer to output the archive resource information to.
*/
FSUSER_GetNandArchiveResource :: (archiveResource: *FS_ArchiveResource) -> Result #foreign libctru;

/**
* @brief Gets the last SDMC fatfs error.
* @param error Pointer to output the error to.
*/
FSUSER_GetSdmcFatfsError :: (error: *u32) -> Result #foreign libctru;

/**
* @brief Gets whether an SD card is detected.
* @param detected Pointer to output the detection status to.
*/
FSUSER_IsSdmcDetected :: (detected: *bool) -> Result #foreign libctru;

/**
* @brief Gets whether the SD card is writable.
* @param writable Pointer to output the writable status to.
*/
FSUSER_IsSdmcWritable :: (writable: *bool) -> Result #foreign libctru;

/**
* @brief Gets the SDMC CID.
* @param out Pointer to output the CID to.
* @param length Length of the CID buffer. (should be 0x10)
*/
FSUSER_GetSdmcCid :: (out: *u8, length: u32) -> Result #foreign libctru;

/**
* @brief Gets the NAND CID.
* @param out Pointer to output the CID to.
* @param length Length of the CID buffer. (should be 0x10)
*/
FSUSER_GetNandCid :: (out: *u8, length: u32) -> Result #foreign libctru;

/**
* @brief Gets the SDMC speed info.
* @param speedInfo Pointer to output the speed info to.
*/
FSUSER_GetSdmcSpeedInfo :: (speedInfo: *FS_SdMmcSpeedInfo) -> Result #foreign libctru;

/**
* @brief Gets the NAND speed info.
* @param speedInfo Pointer to output the speed info to.
*/
FSUSER_GetNandSpeedInfo :: (speedInfo: *FS_SdMmcSpeedInfo) -> Result #foreign libctru;

/**
* @brief Gets the SDMC log.
* @param out Pointer to output the log to.
* @param length Length of the log buffer.
*/
FSUSER_GetSdmcLog :: (out: *u8, length: u32) -> Result #foreign libctru;

/**
* @brief Gets the NAND log.
* @param out Pointer to output the log to.
* @param length Length of the log buffer.
*/
FSUSER_GetNandLog :: (out: *u8, length: u32) -> Result #foreign libctru;

/// Clears the SDMC log.
FSUSER_ClearSdmcLog :: () -> Result #foreign libctru;

/// Clears the NAND log.
FSUSER_ClearNandLog :: () -> Result #foreign libctru;

/**
* @brief Gets whether a card is inserted.
* @param inserted Pointer to output the insertion status to.
*/
FSUSER_CardSlotIsInserted :: (inserted: *bool) -> Result #foreign libctru;

/**
* @brief Powers on the card slot.
* @param status Pointer to output the power status to.
*/
FSUSER_CardSlotPowerOn :: (status: *bool) -> Result #foreign libctru;

/**
* @brief Powers off the card slot.
* @param status Pointer to output the power status to.
*/
FSUSER_CardSlotPowerOff :: (status: *bool) -> Result #foreign libctru;

/**
* @brief Gets the card's power status.
* @param status Pointer to output the power status to.
*/
FSUSER_CardSlotGetCardIFPowerStatus :: (status: *bool) -> Result #foreign libctru;

/**
* @brief Executes a CARDNOR direct command.
* @param commandId ID of the command.
*/
FSUSER_CardNorDirectCommand :: (commandId: u8) -> Result #foreign libctru;

/**
* @brief Executes a CARDNOR direct command with an address.
* @param commandId ID of the command.
* @param address Address to provide.
*/
FSUSER_CardNorDirectCommandWithAddress :: (commandId: u8, address: u32) -> Result #foreign libctru;

/**
* @brief Executes a CARDNOR direct read.
* @param commandId ID of the command.
* @param size Size of the output buffer.
* @param output Output buffer.
*/
FSUSER_CardNorDirectRead :: (commandId: u8, size: u32, output: *void) -> Result #foreign libctru;

/**
* @brief Executes a CARDNOR direct read with an address.
* @param commandId ID of the command.
* @param address Address to provide.
* @param size Size of the output buffer.
* @param output Output buffer.
*/
FSUSER_CardNorDirectReadWithAddress :: (commandId: u8, address: u32, size: u32, output: *void) -> Result #foreign libctru;

/**
* @brief Executes a CARDNOR direct write.
* @param commandId ID of the command.
* @param size Size of the input buffer.
* @param output Input buffer.
*/
FSUSER_CardNorDirectWrite :: (commandId: u8, size: u32, input: *void) -> Result #foreign libctru;

/**
* @brief Executes a CARDNOR direct write with an address.
* @param commandId ID of the command.
* @param address Address to provide.
* @param size Size of the input buffer.
* @param input Input buffer.
*/
FSUSER_CardNorDirectWriteWithAddress :: (commandId: u8, address: u32, size: u32, input: *void) -> Result #foreign libctru;

/**
* @brief Executes a CARDNOR 4xIO direct read.
* @param commandId ID of the command.
* @param address Address to provide.
* @param size Size of the output buffer.
* @param output Output buffer.
*/
FSUSER_CardNorDirectRead_4xIO :: (commandId: u8, address: u32, size: u32, output: *void) -> Result #foreign libctru;

/**
* @brief Executes a CARDNOR direct CPU write without verify.
* @param address Address to provide.
* @param size Size of the input buffer.
* @param output Input buffer.
*/
FSUSER_CardNorDirectCpuWriteWithoutVerify :: (address: u32, size: u32, input: *void) -> Result #foreign libctru;

/**
* @brief Executes a CARDNOR direct sector erase without verify.
* @param address Address to provide.
*/
FSUSER_CardNorDirectSectorEraseWithoutVerify :: (address: u32) -> Result #foreign libctru;

/**
* @brief Gets a process's product info.
* @param info Pointer to output the product info to.
* @param processId ID of the process.
*/
FSUSER_GetProductInfo :: (info: *FS_ProductInfo, processId: u32) -> Result #foreign libctru;

/**
* @brief Gets a process's program launch info.
* @param info Pointer to output the program launch info to.
* @param processId ID of the process.
*/
FSUSER_GetProgramLaunchInfo :: (info: *FS_ProgramInfo, processId: u32) -> Result #foreign libctru;

/**
* @brief Sets the CARDSPI baud rate.
* @param baudRate Baud rate to set.
*/
FSUSER_SetCardSpiBaudRate :: (baudRate: FS_CardSpiBaudRate) -> Result #foreign libctru;

/**
* @brief Sets the CARDSPI bus mode.
* @param busMode Bus mode to set.
*/
FSUSER_SetCardSpiBusMode :: (busMode: FS_CardSpiBusMode) -> Result #foreign libctru;

/// Sends initialization info to ARM9.
FSUSER_SendInitializeInfoTo9 :: () -> Result #foreign libctru;

/**
* @brief Gets a special content's index.
* @param index Pointer to output the index to.
* @param mediaType Media type of the special content.
* @param programId Program ID owning the special content.
* @param type Type of special content.
*/
FSUSER_GetSpecialContentIndex :: (index: *u16, mediaType: FS_MediaType, programId: u64, type: FS_SpecialContentType) -> Result #foreign libctru;

/**
* @brief Gets the legacy ROM header of a program.
* @param mediaType Media type of the program.
* @param programId ID of the program.
* @param header Pointer to output the legacy ROM header to. (size = 0x3B4)
*/
FSUSER_GetLegacyRomHeader :: (mediaType: FS_MediaType, programId: u64, header: *void) -> Result #foreign libctru;

/**
* @brief Gets the legacy banner data of a program.
* @param mediaType Media type of the program.
* @param programId ID of the program.
* @param header Pointer to output the legacy banner data to. (size = 0x23C0)
*/
FSUSER_GetLegacyBannerData :: (mediaType: FS_MediaType, programId: u64, banner: *void) -> Result #foreign libctru;

/**
* @brief Checks a process's authority to access a save data archive.
* @param access Pointer to output the access status to.
* @param mediaType Media type of the save data.
* @param saveId ID of the save data.
* @param processId ID of the process to check.
*/
FSUSER_CheckAuthorityToAccessExtSaveData :: (access: *bool, mediaType: FS_MediaType, saveId: u64, processId: u32) -> Result #foreign libctru;

/**
* @brief Queries the total quota size of a save data archive.
* @param quotaSize Pointer to output the quota size to.
* @param directories Number of directories.
* @param files Number of files.
* @param fileSizeCount Number of file sizes to provide.
* @param fileSizes File sizes to provide.
*/
FSUSER_QueryTotalQuotaSize :: (quotaSize: *u64, directories: u32, files: u32, fileSizeCount: u32, fileSizes: *u64) -> Result #foreign libctru;

/**
* @brief Abnegates an access right.
* @param accessRight Access right to abnegate.
*/
FSUSER_AbnegateAccessRight :: (accessRight: u32) -> Result #foreign libctru;

/// Deletes the 3DS SDMC root.
FSUSER_DeleteSdmcRoot :: () -> Result #foreign libctru;

/// Deletes all ext save data on the NAND.
FSUSER_DeleteAllExtSaveDataOnNand :: () -> Result #foreign libctru;

/// Initializes the CTR file system.
FSUSER_InitializeCtrFileSystem :: () -> Result #foreign libctru;

/// Creates the FS seed.
FSUSER_CreateSeed :: () -> Result #foreign libctru;

/**
* @brief Retrieves archive format info.
* @param totalSize Pointer to output the total size to.
* @param directories Pointer to output the number of directories to.
* @param files Pointer to output the number of files to.
* @param duplicateData Pointer to output whether to duplicate data to.
* @param archiveId ID of the archive.
* @param path Path of the archive.
*/
FSUSER_GetFormatInfo :: (totalSize: *u32, directories: *u32, files: *u32, duplicateData: *bool, archiveId: FS_ArchiveID, path: FS_Path) -> Result #foreign libctru;

/**
* @brief Gets the legacy ROM header of a program.
* @param headerSize Size of the ROM header.
* @param mediaType Media type of the program.
* @param programId ID of the program.
* @param header Pointer to output the legacy ROM header to.
*/
FSUSER_GetLegacyRomHeader2 :: (headerSize: u32, mediaType: FS_MediaType, programId: u64, header: *void) -> Result #foreign libctru;

/**
* @brief Gets the CTR SDMC root path.
* @param out Pointer to output the root path to.
* @param length Length of the output buffer.
*/
FSUSER_GetSdmcCtrRootPath :: (out: *u8, length: u32) -> Result #foreign libctru;

/**
* @brief Gets an archive's resource information.
* @param archiveResource Pointer to output the archive resource information to.
* @param mediaType System media type to check.
*/
FSUSER_GetArchiveResource :: (archiveResource: *FS_ArchiveResource, mediaType: FS_SystemMediaType) -> Result #foreign libctru;

/**
* @brief Exports the integrity verification seed.
* @param seed Pointer to output the seed to.
*/
FSUSER_ExportIntegrityVerificationSeed :: (seed: *FS_IntegrityVerificationSeed) -> Result #foreign libctru;

/**
* @brief Imports an integrity verification seed.
* @param seed Seed to import.
*/
FSUSER_ImportIntegrityVerificationSeed :: (seed: *FS_IntegrityVerificationSeed) -> Result #foreign libctru;

/**
* @brief Formats save data.
* @param archiveId ID of the save data archive.
* @param path Path of the save data.
* @param blocks Size of the save data in blocks. (512 bytes)
* @param directories Number of directories.
* @param files Number of files.
* @param directoryBuckets Directory hash tree bucket count.
* @param fileBuckets File hash tree bucket count.
* @param duplicateData Whether to store an internal duplicate of the data.
*/
FSUSER_FormatSaveData :: (archiveId: FS_ArchiveID, path: FS_Path, blocks: u32, directories: u32, files: u32, directoryBuckets: u32, fileBuckets: u32, duplicateData: bool) -> Result #foreign libctru;

/**
* @brief Gets the legacy sub banner data of a program.
* @param bannerSize Size of the banner.
* @param mediaType Media type of the program.
* @param programId ID of the program.
* @param header Pointer to output the legacy sub banner data to.
*/
FSUSER_GetLegacySubBannerData :: (bannerSize: u32, mediaType: FS_MediaType, programId: u64, banner: *void) -> Result #foreign libctru;

/**
* @brief Hashes the given data and outputs a SHA256 hash.
* @param data Pointer to the data to be hashed.
* @param inputSize The size of the data.
* @param hash Hash output pointer.
*/
FSUSER_UpdateSha256Context :: (data: *void, inputSize: u32, hash: *u8) -> Result #foreign libctru;

/**
* @brief Reads from a special file.
* @param bytesRead Pointer to output the number of bytes read to.
* @param fileOffset Offset of the file.
* @param size Size of the buffer.
* @param data Buffer to read to.
*/
FSUSER_ReadSpecialFile :: (bytesRead: *u32, fileOffset: u64, size: u32, data: *void) -> Result #foreign libctru;

/**
* @brief Gets the size of a special file.
* @param fileSize Pointer to output the size to.
*/
FSUSER_GetSpecialFileSize :: (fileSize: *u64) -> Result #foreign libctru;

/**
* @brief Creates ext save data.
* @param info Info of the save data.
* @param directories Number of directories.
* @param files Number of files.
* @param sizeLimit Size limit of the save data.
* @param smdhSize Size of the save data's SMDH data.
* @param smdh SMDH data.
*/
FSUSER_CreateExtSaveData :: (info: FS_ExtSaveDataInfo, directories: u32, files: u32, sizeLimit: u64, smdhSize: u32, smdh: *u8) -> Result #foreign libctru;

/**
* @brief Deletes ext save data.
* @param info Info of the save data.
*/
FSUSER_DeleteExtSaveData :: (info: FS_ExtSaveDataInfo) -> Result #foreign libctru;

/**
* @brief Reads the SMDH icon of ext save data.
* @param bytesRead Pointer to output the number of bytes read to.
* @param info Info of the save data.
* @param smdhSize Size of the save data SMDH.
* @param smdh Pointer to output SMDH data to.
*/
FSUSER_ReadExtSaveDataIcon :: (bytesRead: *u32, info: FS_ExtSaveDataInfo, smdhSize: u32, smdh: *u8) -> Result #foreign libctru;

/**
* @brief Gets an ext data archive's block information.
* @param totalBlocks Pointer to output the total blocks to.
* @param freeBlocks Pointer to output the free blocks to.
* @param blockSize Pointer to output the block size to.
* @param info Info of the save data.
*/
FSUSER_GetExtDataBlockSize :: (totalBlocks: *u64, freeBlocks: *u64, blockSize: *u32, info: FS_ExtSaveDataInfo) -> Result #foreign libctru;

/**
* @brief Enumerates ext save data.
* @param idsWritten Pointer to output the number of IDs written to.
* @param idsSize Size of the IDs buffer.
* @param mediaType Media type to enumerate over.
* @param idSize Size of each ID element.
* @param shared Whether to enumerate shared ext save data.
* @param ids Pointer to output IDs to.
*/
FSUSER_EnumerateExtSaveData :: (idsWritten: *u32, idsSize: u32, mediaType: FS_MediaType, idSize: u32, shared: bool, ids: *u8) -> Result #foreign libctru;

/**
* @brief Creates system save data.
* @param info Info of the save data.
* @param totalSize Total size of the save data.
* @param blockSize Block size of the save data. (usually 0x1000)
* @param directories Number of directories.
* @param files Number of files.
* @param directoryBuckets Directory hash tree bucket count.
* @param fileBuckets File hash tree bucket count.
* @param duplicateData Whether to store an internal duplicate of the data.
*/
FSUSER_CreateSystemSaveData :: (info: FS_SystemSaveDataInfo, totalSize: u32, blockSize: u32, directories: u32, files: u32, directoryBuckets: u32, fileBuckets: u32, duplicateData: bool) -> Result #foreign libctru;

/**
* @brief Deletes system save data.
* @param info Info of the save data.
*/
FSUSER_DeleteSystemSaveData :: (info: FS_SystemSaveDataInfo) -> Result #foreign libctru;

/**
* @brief Initiates a device move as the source device.
* @param context Pointer to output the context to.
*/
FSUSER_StartDeviceMoveAsSource :: (_context: *FS_DeviceMoveContext) -> Result #foreign libctru;

/**
* @brief Initiates a device move as the destination device.
* @param context Context to use.
* @param clear Whether to clear the device's data first.
*/
FSUSER_StartDeviceMoveAsDestination :: (_context: FS_DeviceMoveContext, clear: bool) -> Result #foreign libctru;

/**
* @brief Sets an archive's priority.
* @param archive Archive to use.
* @param priority Priority to set.
*/
FSUSER_SetArchivePriority :: (archive: FS_Archive, priority: u32) -> Result #foreign libctru;

/**
* @brief Gets an archive's priority.
* @param priority Pointer to output the priority to.
* @param archive Archive to use.
*/
FSUSER_GetArchivePriority :: (priority: *u32, archive: FS_Archive) -> Result #foreign libctru;

/**
* @brief Configures CTRCARD latency emulation.
* @param latency Latency to apply, in milliseconds.
* @param emulateEndurance Whether to emulate card endurance.
*/
FSUSER_SetCtrCardLatencyParameter :: (latency: u64, emulateEndurance: bool) -> Result #foreign libctru;

/**
* @brief Toggles cleaning up invalid save data.
* @param enable Whether to enable cleaning up invalid save data.
*/
FSUSER_SwitchCleanupInvalidSaveData :: (enable: bool) -> Result #foreign libctru;

/**
* @brief Enumerates system save data.
* @param idsWritten Pointer to output the number of IDs written to.
* @param idsSize Size of the IDs buffer.
* @param ids Pointer to output IDs to.
*/
FSUSER_EnumerateSystemSaveData :: (idsWritten: *u32, idsSize: u32, ids: *u32) -> Result #foreign libctru;

/**
* @brief Initializes a FSUSER session with an SDK version.
* @param session The handle of the FSUSER session to initialize.
* @param version SDK version to initialize with.
*/
FSUSER_InitializeWithSdkVersion :: (session: Handle, version: u32) -> Result #foreign libctru;

/**
* @brief Sets the file system priority.
* @param priority Priority to set.
*/
FSUSER_SetPriority :: (priority: u32) -> Result #foreign libctru;

/**
* @brief Gets the file system priority.
* @param priority Pointer to output the priority to.
*/
FSUSER_GetPriority :: (priority: *u32) -> Result #foreign libctru;

/**
* @brief Sets the save data secure value.
* @param value Secure value to set.
* @param slot Slot of the secure value.
* @param titleUniqueId Unique ID of the title. (default = 0)
* @param titleVariation Variation of the title. (default = 0)
*/
FSUSER_SetSaveDataSecureValue :: (value: u64, slot: FS_SecureValueSlot, titleUniqueId: u32, titleVariation: u8) -> Result #foreign libctru;

/**
* @brief Gets the save data secure value.
* @param exists Pointer to output whether the secure value exists to.
* @param value Pointer to output the secure value to.
* @param slot Slot of the secure value.
* @param titleUniqueId Unique ID of the title. (default = 0)
* @param titleVariation Variation of the title. (default = 0)
*/
FSUSER_GetSaveDataSecureValue :: (exists: *bool, value: *u64, slot: FS_SecureValueSlot, titleUniqueId: u32, titleVariation: u8) -> Result #foreign libctru;

/**
* @brief Performs a control operation on a secure save.
* @param action Action to perform.
* @param input Buffer to read input from.
* @param inputSize Size of the input.
* @param output Buffer to write output to.
* @param outputSize Size of the output.
*/
FSUSER_ControlSecureSave :: (action: FS_SecureSaveAction, input: *void, inputSize: u32, output: *void, outputSize: u32) -> Result #foreign libctru;

/**
* @brief Gets the media type of the current application.
* @param mediaType Pointer to output the media type to.
*/
FSUSER_GetMediaType :: (mediaType: *FS_MediaType) -> Result #foreign libctru;

/**
* @brief Performs a control operation on a file.
* @param handle Handle of the file.
* @param action Action to perform.
* @param input Buffer to read input from.
* @param inputSize Size of the input.
* @param output Buffer to write output to.
* @param outputSize Size of the output.
*/
FSFILE_Control :: (handle: Handle, action: FS_FileAction, input: *void, inputSize: u32, output: *void, outputSize: u32) -> Result #foreign libctru;

/**
* @brief Opens a handle to a sub-section of a file.
* @param handle Handle of the file.
* @param subFile Pointer to output the sub-file to.
* @param offset Offset of the sub-section.
* @param size Size of the sub-section.
*/
FSFILE_OpenSubFile :: (handle: Handle, subFile: *Handle, offset: u64, size: u64) -> Result #foreign libctru;

/**
* @brief Reads from a file.
* @param handle Handle of the file.
* @param bytesRead Pointer to output the number of bytes read to.
* @param offset Offset to read from.
* @param buffer Buffer to read to.
* @param size Size of the buffer.
*/
FSFILE_Read :: (handle: Handle, bytesRead: *u32, offset: u64, buffer: *void, size: u32) -> Result #foreign libctru;

/**
* @brief Writes to a file.
* @param handle Handle of the file.
* @param bytesWritten Pointer to output the number of bytes written to.
* @param offset Offset to write to.
* @param buffer Buffer to write from.
* @param size Size of the buffer.
* @param flags Flags to use when writing.
*/
FSFILE_Write :: (handle: Handle, bytesWritten: *u32, offset: u64, buffer: *void, size: u32, flags: u32) -> Result #foreign libctru;

/**
* @brief Gets the size of a file.
* @param handle Handle of the file.
* @param size Pointer to output the size to.
*/
FSFILE_GetSize :: (handle: Handle, size: *u64) -> Result #foreign libctru;

/**
* @brief Sets the size of a file.
* @param handle Handle of the file.
* @param size Size to set.
*/
FSFILE_SetSize :: (handle: Handle, size: u64) -> Result #foreign libctru;

/**
* @brief Gets the attributes of a file.
* @param handle Handle of the file.
* @param attributes Pointer to output the attributes to.
*/
FSFILE_GetAttributes :: (handle: Handle, attributes: *u32) -> Result #foreign libctru;

/**
* @brief Sets the attributes of a file.
* @param handle Handle of the file.
* @param attributes Attributes to set.
*/
FSFILE_SetAttributes :: (handle: Handle, attributes: u32) -> Result #foreign libctru;

/**
* @brief Closes a file.
* @param handle Handle of the file.
*/
FSFILE_Close :: (handle: Handle) -> Result #foreign libctru;

/**
* @brief Flushes a file's contents.
* @param handle Handle of the file.
*/
FSFILE_Flush :: (handle: Handle) -> Result #foreign libctru;

/**
* @brief Sets a file's priority.
* @param handle Handle of the file.
* @param priority Priority to set.
*/
FSFILE_SetPriority :: (handle: Handle, priority: u32) -> Result #foreign libctru;

/**
* @brief Gets a file's priority.
* @param handle Handle of the file.
* @param priority Pointer to output the priority to.
*/
FSFILE_GetPriority :: (handle: Handle, priority: *u32) -> Result #foreign libctru;

/**
* @brief Opens a duplicate handle to a file.
* @param handle Handle of the file.
* @param linkFile Pointer to output the link handle to.
*/
FSFILE_OpenLinkFile :: (handle: Handle, linkFile: *Handle) -> Result #foreign libctru;

/**
* @brief Performs a control operation on a directory.
* @param handle Handle of the directory.
* @param action Action to perform.
* @param input Buffer to read input from.
* @param inputSize Size of the input.
* @param output Buffer to write output to.
* @param outputSize Size of the output.
*/
FSDIR_Control :: (handle: Handle, action: FS_DirectoryAction, input: *void, inputSize: u32, output: *void, outputSize: u32) -> Result #foreign libctru;

/**
* @brief Reads one or more directory entries.
* @param handle Handle of the directory.
* @param entriesRead Pointer to output the number of entries read to.
* @param entryCount Number of entries to read.
* @param entryOut Pointer to output directory entries to.
*/
FSDIR_Read :: (handle: Handle, entriesRead: *u32, entryCount: u32, entries: *FS_DirectoryEntry) -> Result #foreign libctru;

/**
* @brief Closes a directory.
* @param handle Handle of the directory.
*/
FSDIR_Close :: (handle: Handle) -> Result #foreign libctru;

/**
* @brief Sets a directory's priority.
* @param handle Handle of the directory.
* @param priority Priority to set.
*/
FSDIR_SetPriority :: (handle: Handle, priority: u32) -> Result #foreign libctru;

/**
* @brief Gets a directory's priority.
* @param handle Handle of the directory.
* @param priority Pointer to output the priority to.
*/
FSDIR_GetPriority :: (handle: Handle, priority: *u32) -> Result #foreign libctru;

/// Contains basic information about a title.
AM_TitleEntry :: struct {
    titleID: u64; ///< The title's ID.
    size:    u64; ///< The title's installed size.
    version: u16; ///< The title's version.
    unk:     [6] u8; ///< Unknown title data.
}

/// Pending title status mask values.
AM_STATUS_MASK :: enum u8 {
    INSTALLING            :: 1;
    AWAITING_FINALIZATION :: 2;
}

/// Pending title status values.
AM_InstallStatus :: enum u16 {
    ABORTED               :: 2;
    SAVED                 :: 3;
    INSTALL_IN_PROGRESS   :: 2050;
    AWAITING_FINALIZATION :: 2051;
}

// Contains basic information about a pending title.
AM_PendingTitleEntry :: struct {
    titleId:   u64; ///< Title ID
    version:   u16; ///< Version
    status:    u16; ///< @ref AM_InstallStatus
    titleType: u32; ///< Title Type
    unk:       [8] u8; ///< Unknown
}

/// Pending title deletion flags.
AM_DELETE_PENDING :: enum u8 {
    NON_SYSTEM :: 1;
    SYSTEM     :: 2;
}

/// Information about the TWL NAND partition.
AM_TWLPartitionInfo :: struct {
    capacity:        u64; ///< Total capacity.
    freeSpace:       u64; ///< Total free space.
    titlesCapacity:  u64; ///< Capacity for titles.
    titlesFreeSpace: u64; ///< Free space for titles.
}

/// Contains information about a title's content.
AM_ContentInfo :: struct {
    index:     u16; ///< Index of the content in the title.
    type:      u16; ///< ?
    contentId: u32; ///< ID of the content in the title.
    size:      u64; ///< Size of the content in the title.
    flags:     u8; ///< @ref AM_ContentInfoFlags
    padding:   [7] u8; ///< Padding
}

/// Title ContentInfo flags.
AM_ContentInfoFlags :: enum u8 {
    DOWNLOADED :: 1;
    OWNED      :: 2;
}

/// Initializes AM. This doesn't initialize with "am:app", see amAppInit().
amInit :: () -> Result #foreign libctru;

/// Initializes AM with a service which has access to the amapp-commands. This should only be used when using the amapp commands, not non-amapp AM commands.
amAppInit :: () -> Result #foreign libctru;

/// Exits AM.
amExit :: () -> void #foreign libctru;

/// Gets the current AM session handle.
amGetSessionHandle :: () -> *Handle #foreign libctru;

/**
* @brief Gets the number of titles for a given media type.
* @param mediatype Media type to get titles from.
* @param[out] count Pointer to write the title count to.
*/
AM_GetTitleCount :: (mediatype: FS_MediaType, count: *u32) -> Result #foreign libctru;

/**
* @brief Gets a list of title IDs present in a mediatype.
* @param[out] titlesRead Pointer to output the number of read titles to.
* @param mediatype Media type to get titles from.
* @param titleCount Number of title IDs to get.
* @param titleIds Buffer to output the retrieved title IDs to.
*/
AM_GetTitleList :: (titlesRead: *u32, mediatype: FS_MediaType, titleCount: u32, titleIds: *u64) -> Result #foreign libctru;

/**
* @brief Gets a list of details about installed titles.
* @param mediatype Media type to get titles from.
* @param titleCount Number of titles to list.
* @param titleIds List of title IDs to retrieve details for.
* @param titleInfo Buffer to write AM_TitleEntry's to.
*/
AM_GetTitleInfo :: (mediatype: FS_MediaType, titleCount: u32, titleIds: *u64, titleInfo: *AM_TitleEntry) -> Result #foreign libctru;

/**
* @brief Gets the number of tickets installed on the system.
* @param[out] count Pointer to output the ticket count to.
*/
AM_GetTicketCount :: (count: *u32) -> Result #foreign libctru;

/**
* @brief Gets a list of tickets installed on the system.
* @param[out] ticketsRead Pointer to output the number of read tickets to.
* @param ticketCount Number of tickets to read.
* @param skip Number of tickets to skip.
* @param ticketIds Buffer to output the retrieved ticket IDs to.
*/
AM_GetTicketList :: (ticketsRead: *u32, ticketCount: u32, skip: u32, ticketIds: *u64) -> Result #foreign libctru;

/**
* @brief Gets the number of pending titles on this system.
* @param[out] count Pointer to output the pending title count to.
* @param mediatype Media type of pending titles to count.
* @param statusMask Bit mask of status values to include.
*/
AM_GetPendingTitleCount :: (count: *u32, mediatype: FS_MediaType, statusMask: u32) -> Result #foreign libctru;

/**
* @brief Gets a list of pending titles on this system.
* @param[out] titlesRead Pointer to output the number of read pending titles to.
* @param titleCount Number of pending titles to read.
* @param mediatype Media type of pending titles to list.
* @param statusMask Bit mask of status values to include.
* @param titleIds Buffer to output the retrieved pending title IDs to.
*/
AM_GetPendingTitleList :: (titlesRead: *u32, titleCount: u32, mediatype: FS_MediaType, statusMask: u32, titleIds: *u64) -> Result #foreign libctru;

/**
* @brief Gets information about pending titles on this system.
* @param titleCount Number of pending titles to read.
* @param mediatype Media type of pending titles to get information on.
* @param titleIds IDs of the titles to get information about.
* @param titleInfo Buffer to output the retrieved pending title info to.
*/
AM_GetPendingTitleInfo :: (titleCount: u32, mediatype: FS_MediaType, titleIds: *u64, titleInfo: *AM_PendingTitleEntry) -> Result #foreign libctru;

/**
* @brief Gets a 32-bit device-specific ID.
* @param deviceID Pointer to write the device ID to.
*/
AM_GetDeviceId :: (deviceID: *u32) -> Result #foreign libctru;

/**
* @brief Exports DSiWare to the specified filepath.
* @param titleID TWL titleID.
* @param operation DSiWare operation type.
* @param workbuf Work buffer.
* @param workbuf_size Work buffer size, must be >=0x20000.
* @param filepath UTF-8 filepath(converted to UTF-16 internally).
*/
AM_ExportTwlBackup :: (titleID: u64, operation: u8, workbuf: *void, workbuf_size: u32, filepath: *u8) -> Result #foreign libctru;

/**
* @brief Imports DSiWare from the specified file.
* @param filehandle FSUSER file handle.
* @param operation DSiWare operation type.
* @param buffer Work buffer.
* @param size Buffer size, must be >=0x20000.
*/
AM_ImportTwlBackup :: (filehandle: Handle, operation: u8, buffer: *void, size: u32) -> Result #foreign libctru;

/**
* @brief Reads info from the specified DSiWare export file. This can only be used with DSiWare exported with certain operation value(s).
* @param filehandle FSUSER file handle.
* @param outinfo Output info buffer.
* @param outinfo_size Output info buffer size.
* @param workbuf Work buffer.
* @param workbuf_size Work buffer size.
* @param banner Output banner buffer.
* @param banner_size Output banner buffer size.
*/
AM_ReadTwlBackupInfo :: (filehandle: Handle, outinfo: *void, outinfo_size: u32, workbuf: *void, workbuf_size: u32, banner: *void, banner_size: u32) -> Result #foreign libctru;

/**
* @brief Retrieves information about the NAND TWL partition.
* @param[out] info Pointer to output the TWL partition info to.
*/
AM_GetTWLPartitionInfo :: (info: *AM_TWLPartitionInfo) -> Result #foreign libctru;

/**
* @brief Initializes the CIA install process, returning a handle to write CIA data to.
* @param mediatype Media type to install the CIA to.
* @param[out] ciaHandle Pointer to write the CIA handle to.
*/
AM_StartCiaInstall :: (mediatype: FS_MediaType, ciaHandle: *Handle) -> Result #foreign libctru;

/**
* @brief Initializes the CIA install process for Download Play CIAs, returning a handle to write CIA data to.
* @param[out] ciaHandle Pointer to write the CIA handle to.
*/
AM_StartDlpChildCiaInstall :: (ciaHandle: *Handle) -> Result #foreign libctru;

/**
* @brief Aborts the CIA install process.
* @param ciaHandle CIA handle to cancel.
*/
AM_CancelCIAInstall :: (ciaHandle: Handle) -> Result #foreign libctru;

/**
* @brief Finalizes the CIA install process.
* @param ciaHandle CIA handle to finalize.
*/
AM_FinishCiaInstall :: (ciaHandle: Handle) -> Result #foreign libctru;

/**
* @brief Finalizes the CIA install process without committing the title to title.db or tmp*.db.
* @param ciaHandle CIA handle to finalize.
*/
AM_FinishCiaInstallWithoutCommit :: (ciaHandle: Handle) -> Result #foreign libctru;

/**
* @brief Commits installed CIAs.
* @param mediaType Location of the titles to finalize.
* @param titleCount Number of titles to finalize.
* @param temp Whether the titles being finalized are in the temporary database.
* @param titleIds Title IDs to finalize.
*/
AM_CommitImportPrograms :: (mediaType: FS_MediaType, titleCount: u32, temp: bool, titleIds: *u64) -> Result #foreign libctru;

/**
* @brief Deletes a title.
* @param mediatype Media type to delete from.
* @param titleID ID of the title to delete.
*/
AM_DeleteTitle :: (mediatype: FS_MediaType, titleID: u64) -> Result #foreign libctru;

/**
* @brief Deletes a title, provided that it is not a system title.
* @param mediatype Media type to delete from.
* @param titleID ID of the title to delete.
*/
AM_DeleteAppTitle :: (mediatype: FS_MediaType, titleID: u64) -> Result #foreign libctru;

/**
* @brief Deletes a ticket.
* @param titleID ID of the ticket to delete.
*/
AM_DeleteTicket :: (ticketId: u64) -> Result #foreign libctru;

/**
* @brief Deletes a pending title.
* @param mediatype Media type to delete from.
* @param titleId ID of the pending title to delete.
*/
AM_DeletePendingTitle :: (mediatype: FS_MediaType, titleId: u64) -> Result #foreign libctru;

/**
* @brief Deletes pending titles.
* @param mediatype Media type to delete from.
* @param flags Flags used to select pending titles.
*/
AM_DeletePendingTitles :: (mediatype: FS_MediaType, flags: u32) -> Result #foreign libctru;

/**
* @brief Deletes all pending titles.
* @param mediatype Media type to delete from.
*/
AM_DeleteAllPendingTitles :: (mediatype: FS_MediaType) -> Result #foreign libctru;

/// Installs the current NATIVE_FIRM title to NAND (firm0:/ & firm1:/)
AM_InstallNativeFirm :: () -> Result #foreign libctru;

/**
* @brief Installs a NATIVE_FIRM title to NAND. Accepts 0004013800000002 or 0004013820000002 (N3DS).
* @param titleID Title ID of the NATIVE_FIRM to install.
*/
AM_InstallFirm :: (titleID: u64) -> Result #foreign libctru;

/**
* @brief Gets the product code of a title.
* @param mediatype Media type of the title.
* @param titleID ID of the title.
* @param[out] productCode Pointer to output the product code to. (length = 16)
*/
AM_GetTitleProductCode :: (mediatype: FS_MediaType, titleId: u64, productCode: *u8) -> Result #foreign libctru;

/**
* @brief Gets the ext data ID of a title.
* @param[out] extDataId Pointer to output the ext data ID to.
* @param mediatype Media type of the title.
* @param titleID ID of the title.
*/
AM_GetTitleExtDataId :: (extDataId: *u64, mediatype: FS_MediaType, titleId: u64) -> Result #foreign libctru;

/**
* @brief Gets an AM_TitleEntry instance for a CIA file.
* @param mediatype Media type that this CIA would be installed to.
* @param[out] titleEntry Pointer to write the AM_TitleEntry instance to.
* @param fileHandle Handle of the CIA file.
*/
AM_GetCiaFileInfo :: (mediatype: FS_MediaType, titleEntry: *AM_TitleEntry, fileHandle: Handle) -> Result #foreign libctru;

/**
* @brief Gets the SMDH icon data of a CIA file.
* @param icon Buffer to store the icon data in. Must be of size 0x36C0 bytes.
* @param fileHandle Handle of the CIA file.
*/
AM_GetCiaIcon :: (icon: *void, fileHandle: Handle) -> Result #foreign libctru;

/**
* @brief Gets the title ID dependency list of a CIA file.
* @param dependencies Buffer to store dependency title IDs in. Must be of size 0x300 bytes.
* @param fileHandle Handle of the CIA file.
*/
AM_GetCiaDependencies :: (dependencies: *u64, fileHandle: Handle) -> Result #foreign libctru;

/**
* @brief Gets the meta section offset of a CIA file.
* @param[out] metaOffset Pointer to output the meta section offset to.
* @param fileHandle Handle of the CIA file.
*/
AM_GetCiaMetaOffset :: (metaOffset: *u64, fileHandle: Handle) -> Result #foreign libctru;

/**
* @brief Gets the core version of a CIA file.
* @param[out] coreVersion Pointer to output the core version to.
* @param fileHandle Handle of the CIA file.
*/
AM_GetCiaCoreVersion :: (coreVersion: *u32, fileHandle: Handle) -> Result #foreign libctru;

/**
* @brief Gets the free space, in bytes, required to install a CIA file.
* @param[out] requiredSpace Pointer to output the required free space to.
* @param mediaType Media type to check free space needed to install to.
* @param fileHandle Handle of the CIA file.
*/
AM_GetCiaRequiredSpace :: (requiredSpace: *u64, mediaType: FS_MediaType, fileHandle: Handle) -> Result #foreign libctru;

/**
* @brief Gets the full meta section of a CIA file.
* @param meta Buffer to store the meta section in.
* @param size Size of the buffer. Must be greater than or equal to the actual section data's size.
* @param fileHandle Handle of the CIA file.
*/
AM_GetCiaMetaSection :: (meta: *void, size: u32, fileHandle: Handle) -> Result #foreign libctru;

/**
* @brief Initializes the external (SD) title database.
* @param overwrite Overwrites the database if it already exists.
*/
AM_InitializeExternalTitleDatabase :: (overwrite: bool) -> Result #foreign libctru;

/**
* @brief Queries whether the external title database is available.
* @param[out] available Pointer to output the availability status to.
*/
AM_QueryAvailableExternalTitleDatabase :: (available: *bool) -> Result #foreign libctru;

/**
* @brief Begins installing a ticket.
* @param[out] ticketHandle Pointer to output a handle to write ticket data to.
*/
AM_InstallTicketBegin :: (ticketHandle: *Handle) -> Result #foreign libctru;

/**
* @brief Aborts installing a ticket.
* @param ticketHandle Handle of the installation to abort.
*/
AM_InstallTicketAbort :: (ticketHandle: Handle) -> Result #foreign libctru;

/**
* @brief Finishes installing a ticket.
* @param ticketHandle Handle of the installation to finalize.
*/
AM_InstallTicketFinish :: (ticketHandle: Handle) -> Result #foreign libctru;

/**
* @brief Begins installing a title.
* @param mediaType Destination to install to.
* @param titleId ID of the title to install.
* @param unk Unknown. (usually false)
*/
AM_InstallTitleBegin :: (mediaType: FS_MediaType, titleId: u64, unk: bool) -> Result #foreign libctru;

/// Stops installing a title, generally to be resumed later.
AM_InstallTitleStop :: () -> Result #foreign libctru;

/**
* @brief Resumes installing a title.
* @param mediaType Destination to install to.
* @param titleId ID of the title to install.
*/
AM_InstallTitleResume :: (mediaType: FS_MediaType, titleId: u64) -> Result #foreign libctru;

/// Aborts installing a title.
AM_InstallTitleAbort :: () -> Result #foreign libctru;

/// Finishes installing a title.
AM_InstallTitleFinish :: () -> Result #foreign libctru;

/**
* @brief Commits installed titles.
* @param mediaType Location of the titles to finalize.
* @param titleCount Number of titles to finalize.
* @param temp Whether the titles being finalized are in the temporary database.
* @param titleIds Title IDs to finalize.
*/
AM_CommitImportTitles :: (mediaType: FS_MediaType, titleCount: u32, temp: bool, titleIds: *u64) -> Result #foreign libctru;

/**
* @brief Begins installing a TMD.
* @param[out] tmdHandle Pointer to output a handle to write TMD data to.
*/
AM_InstallTmdBegin :: (tmdHandle: *Handle) -> Result #foreign libctru;

/**
* @brief Aborts installing a TMD.
* @param tmdHandle Handle of the installation to abort.
*/
AM_InstallTmdAbort :: (tmdHandle: Handle) -> Result #foreign libctru;

/**
* @brief Finishes installing a TMD.
* @param tmdHandle Handle of the installation to finalize.
* @param unk Unknown. (usually true)
*/
AM_InstallTmdFinish :: (tmdHandle: Handle, unk: bool) -> Result #foreign libctru;

/**
* @brief Prepares to import title contents.
* @param contentCount Number of contents to be imported.
* @param contentIndices Indices of the contents to be imported.
*/
AM_CreateImportContentContexts :: (contentCount: u32, contentIndices: *u16) -> Result #foreign libctru;

/**
* @brief Begins installing title content.
* @param[out] contentHandle Pointer to output a handle to write content data to.
* @param index Index of the content to install.
*/
AM_InstallContentBegin :: (contentHandle: *Handle, index: u16) -> Result #foreign libctru;

/**
* @brief Stops installing title content, generally to be resumed later.
* @param contentHandle Handle of the installation to abort.
*/
AM_InstallContentStop :: (contentHandle: Handle) -> Result #foreign libctru;

/**
* @brief Resumes installing title content.
* @param[out] contentHandle Pointer to output a handle to write content data to.
* @param[out] resumeOffset Pointer to write the offset to resume content installation at to.
* @param index Index of the content to install.
*/
AM_InstallContentResume :: (contentHandle: *Handle, resumeOffset: *u64, index: u16) -> Result #foreign libctru;

/**
* @brief Cancels installing title content.
* @param contentHandle Handle of the installation to finalize.
*/
AM_InstallContentCancel :: (contentHandle: Handle) -> Result #foreign libctru;

/**
* @brief Finishes installing title content.
* @param contentHandle Handle of the installation to finalize.
*/
AM_InstallContentFinish :: (contentHandle: Handle) -> Result #foreign libctru;

/**
* @brief Imports up to four certificates into the ticket certificate chain.
* @param cert1Size Size of the first certificate.
* @param cert1 Data of the first certificate.
* @param cert2Size Size of the second certificate.
* @param cert2 Data of the second certificate.
* @param cert3Size Size of the third certificate.
* @param cert3 Data of the third certificate.
* @param cert4Size Size of the fourth certificate.
* @param cert4 Data of the fourth certificate.
*/
AM_ImportCertificates :: (cert1Size: u32, cert1: *void, cert2Size: u32, cert2: *void, cert3Size: u32, cert3: *void, cert4Size: u32, cert4: *void) -> Result #foreign libctru;

/**
* @brief Imports a certificate into the ticket certificate chain.
* @param certSize Size of the certificate.
* @param cert Data of the certificate.
*/
AM_ImportCertificate :: (certSize: u32, cert: *void) -> Result #foreign libctru;

/**
* @brief Commits installed titles, and updates FIRM if necessary.
* @param mediaType Location of the titles to finalize.
* @param titleCount Number of titles to finalize.
* @param temp Whether the titles being finalized are in the temporary database.
* @param titleIds Title IDs to finalize.
*/
AM_CommitImportTitlesAndUpdateFirmwareAuto :: (mediaType: FS_MediaType, titleCount: u32, temp: bool, titleIds: *u64) -> Result #foreign libctru;

/// Resets play count of all installed demos by deleting their launch info.
AM_DeleteAllDemoLaunchInfos :: () -> Result #foreign libctru;

/// Deletes temporary titles.
AM_DeleteAllTemporaryTitles :: () -> Result #foreign libctru;

/**
* @brief Deletes all expired titles.
* @param mediatype Media type to delete from.
*/
AM_DeleteAllExpiredTitles :: (mediatype: FS_MediaType) -> Result #foreign libctru;

/// Deletes all TWL titles.
AM_DeleteAllTwlTitles :: () -> Result #foreign libctru;

/**
* @brief Gets the number of content index installed under the specified DLC title.
* @param[out] count Pointer to output the number of content indices to.
* @param mediatype Media type of the title.
* @param titleID Title ID to retrieve the count for (high-id is 0x0004008C).
*/
AMAPP_GetDLCContentInfoCount :: (count: *u32, mediatype: FS_MediaType, titleID: u64) -> Result #foreign libctru;

/**
* @brief Gets content infos installed under the specified DLC title.
* @param[out] contentInfoRead Pointer to output the number of content infos read to.
* @param mediatype Media type of the title.
* @param titleID Title ID to retrieve the content infos for (high-id is 0x0004008C).
* @param contentInfoCount Number of content infos to retrieve.
* @param offset Offset from the first content index the count starts at.
* @param[out] contentInfos Pointer to output the content infos read to.
*/
AMAPP_ListDLCContentInfos :: (contentInfoRead: *u32, mediatype: FS_MediaType, titleID: u64, contentInfoCount: u32, offset: u32, contentInfos: *AM_ContentInfo) -> Result #foreign libctru;

/**
* @brief Initializes AMPXI.
* @param servhandle Optional service session handle to use for AMPXI, if zero srvGetServiceHandle() will be used.
*/
ampxiInit :: (servhandle: Handle) -> Result #foreign libctru;

/// Exits AMPXI.
ampxiExit :: () -> void #foreign libctru;

/**
* @brief Writes a TWL save-file to NAND. https://www.3dbrew.org/wiki/AMPXI:WriteTWLSavedata
* @param titleid ID of the TWL title.
* @param buffer Savedata buffer ptr.
* @param size Size of the savedata buffer.
* @param image_filepos Filepos to use for writing the data to the NAND savedata file.
* @param section_type https://www.3dbrew.org/wiki/AMPXI:WriteTWLSavedata
* @param operation https://3dbrew.org/wiki/AM:ImportDSiWare
*/
AMPXI_WriteTWLSavedata :: (titleid: u64, buffer: *u8, size: u32, image_filepos: u32, section_type: u8, operation: u8) -> Result #foreign libctru;

/**
* @brief Finalizes title installation. https://3dbrew.org/wiki/AMPXI:InstallTitlesFinish
* @param mediaType Mediatype of the titles to finalize.
* @param db Which title database to use.
* @param size Size of the savedata buffer.
* @param titlecount Total titles.
* @param tidlist List of titleIDs.
*/
AMPXI_InstallTitlesFinish :: (mediaType: FS_MediaType, db: u8, titlecount: u32, tidlist: *u64) -> Result #foreign libctru;

/**
* @brief NS Application IDs.
*
* Retrieved from http://3dbrew.org/wiki/NS_and_APT_Services#AppIDs
*/
NS_APPID :: enum u16 {
    NONE               :: 0;
    HOMEMENU           :: 257;
    CAMERA             :: 272;
    FRIENDS_LIST       :: 274;
    GAME_NOTES         :: 275;
    WEB                :: 276;
    INSTRUCTION_MANUAL :: 277;
    NOTIFICATIONS      :: 278;
    MIIVERSE           :: 279;
    MIIVERSE_POSTING   :: 280;
    AMIIBO_SETTINGS    :: 281;
    APPLICATION        :: 768;
    ESHOP              :: 769;
    SOFTWARE_KEYBOARD  :: 1025;
    APPLETED           :: 1026;
    PNOTE_AP           :: 1028;
    SNOTE_AP           :: 1029;
    ERROR              :: 1030;
    MINT               :: 1031;
    EXTRAPAD           :: 1032;
    MEMOLIB            :: 1033;
}

/// APT applet position.
APT_AppletPos :: enum s8 {
    NONE     :: -1;
    APP      :: 0;
    APPLIB   :: 1;
    SYS      :: 2;
    SYSLIB   :: 3;
    RESIDENT :: 4;
}

APT_AppletAttr :: u8;

/// APT query reply.
APT_QueryReply :: enum u8 {
    REJECT :: 0;
    ACCEPT :: 1;
    LATER  :: 2;
}

/// APT signals.
APT_Signal :: enum u8 {
    NONE         :: 0;
    HOMEBUTTON   :: 1;
    HOMEBUTTON2  :: 2;
    SLEEP_QUERY  :: 3;
    SLEEP_CANCEL :: 4;
    SLEEP_ENTER  :: 5;
    SLEEP_WAKEUP :: 6;
    SHUTDOWN     :: 7;
    POWERBUTTON  :: 8;
    POWERBUTTON2 :: 9;
    TRY_SLEEP    :: 10;
    ORDERTOCLOSE :: 11;
}

/// APT commands.
APT_Command :: enum u8 {
    NONE               :: 0;
    WAKEUP             :: 1;
    REQUEST            :: 2;
    RESPONSE           :: 3;
    EXIT               :: 4;
    MESSAGE            :: 5;
    HOMEBUTTON_ONCE    :: 6;
    HOMEBUTTON_TWICE   :: 7;
    DSP_SLEEP          :: 8;
    DSP_WAKEUP         :: 9;
    WAKEUP_EXIT        :: 10;
    WAKEUP_PAUSE       :: 11;
    WAKEUP_CANCEL      :: 12;
    WAKEUP_CANCELALL   :: 13;
    WAKEUP_POWERBUTTON :: 14;
    WAKEUP_JUMPTOHOME  :: 15;
    SYSAPPLET_REQUEST  :: 16;
    WAKEUP_LAUNCHAPP   :: 17;
}

/// APT capture buffer information.
aptCaptureBufInfo :: struct {
    size:   u32;
    is3D:   u32;
    top:    struct {
        leftOffset:  u32;
        rightOffset: u32;
        format:      u32;
    };
    bottom: struct {
        leftOffset:  u32;
        rightOffset: u32;
        format:      u32;
    };
}

/// APT hook types.
APT_HookType :: enum u8 {
    ONSUSPEND :: 0;
    ONRESTORE :: 1;
    ONSLEEP   :: 2;
    ONWAKEUP  :: 3;
    ONEXIT    :: 4;
    COUNT     :: 5;
}

/// APT hook function.
aptHookFn :: #type (hook: APT_HookType, param: *void) -> void #c_call;

/// APT hook cookie.
tag_aptHookCookie :: struct {
    next:     *tag_aptHookCookie; ///< Next cookie.
    callback: aptHookFn #align 4; ///< Hook callback.
    param:    *void; ///< Callback parameter.
}

/// APT hook cookie.
aptHookCookie :: tag_aptHookCookie;

/// APT message callback.
aptMessageCb :: #type (user: *void, sender: NS_APPID, msg: *void, msgsize: size_t) -> void #c_call;

/// Initializes APT.
aptInit :: () -> Result #foreign libctru;

/// Exits APT.
aptExit :: () -> void #foreign libctru;

/**
* @brief Sends an APT command through IPC, taking care of locking, opening and closing an APT session.
* @param aptcmdbuf Pointer to command buffer (should have capacity for at least 16 words).
*/
aptSendCommand :: (aptcmdbuf: *u32) -> Result #foreign libctru;

/// Returns true if the application is currently in the foreground.
aptIsActive :: () -> bool #foreign libctru;

/// Returns true if the system has told the application to close.
aptShouldClose :: () -> bool #foreign libctru;

/// Returns true if the system can enter sleep mode while the application is active.
aptIsSleepAllowed :: () -> bool #foreign libctru;

/// Configures whether the system can enter sleep mode while the application is active.
aptSetSleepAllowed :: (allowed: bool) -> void #foreign libctru;

/// Handles incoming sleep mode requests.
aptHandleSleep :: () -> void #foreign libctru;

/// Returns true if the user can press the HOME button to jump back to the HOME menu while the application is active.
aptIsHomeAllowed :: () -> bool #foreign libctru;

/// Configures whether the user can press the HOME button to jump back to the HOME menu while the application is active.
aptSetHomeAllowed :: (allowed: bool) -> void #foreign libctru;

/// Returns true if the system requires the application to jump back to the HOME menu.
aptShouldJumpToHome :: () -> bool #foreign libctru;

/// Returns true if there is an incoming HOME button press rejected by the policy set by \ref aptSetHomeAllowed (use this to show a "no HOME allowed" icon).
aptCheckHomePressRejected :: () -> bool #foreign libctru;

/// Jumps back to the HOME menu.
aptJumpToHomeMenu :: () -> void #foreign libctru;

/**
* @brief Main function which handles sleep mode and HOME/power buttons - call this at the beginning of every frame.
* @return true if the application should keep running, false otherwise (see \ref aptShouldClose).
*/
aptMainLoop :: () -> bool #foreign libctru;

/**
* @brief Sets up an APT status hook.
* @param cookie Hook cookie to use.
* @param callback Function to call when APT's status changes.
* @param param User-defined parameter to pass to the callback.
*/
aptHook :: (cookie: *aptHookCookie, callback: aptHookFn, param: *void) -> void #foreign libctru;

/**
* @brief Removes an APT status hook.
* @param cookie Hook cookie to remove.
*/
aptUnhook :: (cookie: *aptHookCookie) -> void #foreign libctru;

/**
* @brief Sets the function to be called when an APT message from another applet is received.
* @param callback Callback function.
* @param user User-defined data to be passed to the callback.
*/
aptSetMessageCallback :: (callback: aptMessageCb, user: *void) -> void #foreign libctru;

/**
* @brief Launches a library applet.
* @param appId ID of the applet to launch.
* @param buf Input/output buffer that contains launch parameters on entry and result data on exit.
* @param bufsize Size of the buffer.
* @param handle Handle to pass to the library applet.
*/
aptLaunchLibraryApplet :: (appId: NS_APPID, buf: *void, bufsize: size_t, handle: Handle) -> void #foreign libctru;

/// Clears the chainloader state.
aptClearChainloader :: () -> void #foreign libctru;

/**
* @brief Configures the chainloader to launch a specific application.
* @param programID ID of the program to chainload to.
* @param mediatype Media type of the program to chainload to.
*/
aptSetChainloader :: (programID: u64, mediatype: u8) -> void #foreign libctru;

/// Configures the chainloader to relaunch the current application (i.e. soft-reset)
aptSetChainloaderToSelf :: () -> void #foreign libctru;

/**
* @brief Gets an APT lock handle.
* @param flags Flags to use.
* @param lockHandle Pointer to output the lock handle to.
*/
APT_GetLockHandle :: (flags: u16, lockHandle: *Handle) -> Result #foreign libctru;

/**
* @brief Initializes an application's registration with APT.
* @param appId ID of the application.
* @param attr Attributes of the application.
* @param signalEvent Pointer to output the signal event handle to.
* @param resumeEvent Pointer to output the resume event handle to.
*/
APT_Initialize :: (appId: NS_APPID, attr: APT_AppletAttr, signalEvent: *Handle, resumeEvent: *Handle) -> Result #foreign libctru;

/**
* @brief Terminates an application's registration with APT.
* @param appID ID of the application.
*/
APT_Finalize :: (appId: NS_APPID) -> Result #foreign libctru;

/// Asynchronously resets the hardware.
APT_HardwareResetAsync :: () -> Result #foreign libctru;

/**
* @brief Enables APT.
* @param attr Attributes of the application.
*/
APT_Enable :: (attr: APT_AppletAttr) -> Result #foreign libctru;

/**
* @brief Gets applet management info.
* @param inpos Requested applet position.
* @param outpos Pointer to output the position of the current applet to.
* @param req_appid Pointer to output the AppID of the applet at the requested position to.
* @param menu_appid Pointer to output the HOME menu AppID to.
* @param active_appid Pointer to output the AppID of the currently active applet to.
*/
APT_GetAppletManInfo :: (inpos: APT_AppletPos, outpos: *APT_AppletPos, req_appid: *NS_APPID, menu_appid: *NS_APPID, active_appid: *NS_APPID) -> Result #foreign libctru;

/**
* @brief Gets an applet's information.
* @param appID AppID of the applet.
* @param pProgramID Pointer to output the program ID to.
* @param pMediaType Pointer to output the media type to.
* @param pRegistered Pointer to output the registration status to.
* @param pLoadState Pointer to output the load state to.
* @param pAttributes Pointer to output the applet atrributes to.
*/
APT_GetAppletInfo :: (appID: NS_APPID, pProgramID: *u64, pMediaType: *u8, pRegistered: *bool, pLoadState: *bool, pAttributes: *APT_AppletAttr) -> Result #foreign libctru;

/**
* @brief Gets an applet's program information.
* @param id ID of the applet.
* @param flags Flags to use when retreiving the information.
* @param titleversion Pointer to output the applet's title version to.
*
* Flags:
* - 0x01: Use AM_ListTitles with NAND media type.
* - 0x02: Use AM_ListTitles with SDMC media type.
* - 0x04: Use AM_ListTitles with GAMECARD media type.
* - 0x10: Input ID is an app ID. Must be set if 0x20 is not.
* - 0x20: Input ID is a program ID. Must be set if 0x10 is not.
* - 0x100: Sets program ID high to 0x00040000, else it is 0x00040010. Only used when 0x20 is set.
*/
APT_GetAppletProgramInfo :: (id: u32, flags: u32, titleversion: *u16) -> Result #foreign libctru;

/**
* @brief Gets the current application's program ID.
* @param pProgramID Pointer to output the program ID to.
*/
APT_GetProgramID :: (pProgramID: *u64) -> Result #foreign libctru;

/// Prepares to jump to the home menu.
APT_PrepareToJumpToHomeMenu :: () -> Result #foreign libctru;

/**
* @brief Jumps to the home menu.
* @param param Parameters to jump with.
* @param Size of the parameter buffer.
* @param handle Handle to pass.
*/
APT_JumpToHomeMenu :: (param: *void, paramSize: size_t, handle: Handle) -> Result #foreign libctru;

/**
* @brief Prepares to jump to an application.
* @param exiting Specifies whether the applet is exiting.
*/
APT_PrepareToJumpToApplication :: (exiting: bool) -> Result #foreign libctru;

/**
* @brief Jumps to an application.
* @param param Parameters to jump with.
* @param Size of the parameter buffer.
* @param handle Handle to pass.
*/
APT_JumpToApplication :: (param: *void, paramSize: size_t, handle: Handle) -> Result #foreign libctru;

/**
* @brief Gets whether an application is registered.
* @param appID ID of the application.
* @param out Pointer to output the registration state to.
*/
APT_IsRegistered :: (appID: NS_APPID, out: *bool) -> Result #foreign libctru;

/**
* @brief Inquires as to whether a signal has been received.
* @param appID ID of the application.
* @param signalType Pointer to output the signal type to.
*/
APT_InquireNotification :: (appID: u32, signalType: *APT_Signal) -> Result #foreign libctru;

/**
* @brief Requests to enter sleep mode, and later sets wake events if allowed to.
* @param wakeEvents The wake events. Limited to "shell" (bit 1) for the PDN wake events part
* and "shell opened", "shell closed" and "HOME button pressed" for the MCU interrupts part.
*/
APT_SleepSystem :: (wakeEvents: *PtmWakeEvents) -> Result #foreign libctru;

/**
* @brief Notifies an application to wait.
* @param appID ID of the application.
*/
APT_NotifyToWait :: (appID: NS_APPID) -> Result #foreign libctru;

/**
* @brief Calls an applet utility function.
* @param id Utility function to call.
* @param out Pointer to write output data to.
* @param outSize Size of the output buffer.
* @param in Pointer to the input data.
* @param inSize Size of the input buffer.
*/
APT_AppletUtility :: (id: s32, out: *void, outSize: size_t, in: *void, inSize: size_t) -> Result #foreign libctru;

/// Sleeps if shell is closed (?).
APT_SleepIfShellClosed :: () -> Result #foreign libctru;

/**
* @brief Locks a transition (?).
* @param transition Transition ID.
* @param flag Flag (?)
*/
APT_LockTransition :: (transition: u32, flag: bool) -> Result #foreign libctru;

/**
* @brief Tries to lock a transition (?).
* @param transition Transition ID.
* @param succeeded Pointer to output whether the lock was successfully applied.
*/
APT_TryLockTransition :: (transition: u32, succeeded: *bool) -> Result #foreign libctru;

/**
* @brief Unlocks a transition (?).
* @param transition Transition ID.
*/
APT_UnlockTransition :: (transition: u32) -> Result #foreign libctru;

/**
* @brief Glances at a receieved parameter without removing it from the queue.
* @param appID AppID of the application.
* @param buffer Buffer to receive to.
* @param bufferSize Size of the buffer.
* @param sender Pointer to output the sender's AppID to.
* @param command Pointer to output the command ID to.
* @param actualSize Pointer to output the actual received data size to.
* @param parameter Pointer to output the parameter handle to.
*/
APT_GlanceParameter :: (appID: NS_APPID, buffer: *void, bufferSize: size_t, sender: *NS_APPID, command: *APT_Command, actualSize: *size_t, parameter: *Handle) -> Result #foreign libctru;

/**
* @brief Receives a parameter.
* @param appID AppID of the application.
* @param buffer Buffer to receive to.
* @param bufferSize Size of the buffer.
* @param sender Pointer to output the sender's AppID to.
* @param command Pointer to output the command ID to.
* @param actualSize Pointer to output the actual received data size to.
* @param parameter Pointer to output the parameter handle to.
*/
APT_ReceiveParameter :: (appID: NS_APPID, buffer: *void, bufferSize: size_t, sender: *NS_APPID, command: *APT_Command, actualSize: *size_t, parameter: *Handle) -> Result #foreign libctru;

/**
* @brief Sends a parameter.
* @param source AppID of the source application.
* @param dest AppID of the destination application.
* @param command Command to send.
* @param buffer Buffer to send.
* @param bufferSize Size of the buffer.
* @param parameter Parameter handle to pass.
*/
APT_SendParameter :: (source: NS_APPID, dest: NS_APPID, command: APT_Command, buffer: *void, bufferSize: u32, parameter: Handle) -> Result #foreign libctru;

/**
* @brief Cancels a parameter which matches the specified source and dest AppIDs.
* @param source AppID of the source application (use APPID_NONE to disable the check).
* @param dest AppID of the destination application (use APPID_NONE to disable the check).
* @param success Pointer to output true if a parameter was cancelled, or false otherwise.
*/
APT_CancelParameter :: (source: NS_APPID, dest: NS_APPID, success: *bool) -> Result #foreign libctru;

/**
* @brief Sends capture buffer information.
* @param captureBuf Capture buffer information to send.
*/
APT_SendCaptureBufferInfo :: (captureBuf: *aptCaptureBufInfo) -> Result #foreign libctru;

/**
* @brief Replies to a sleep query.
* @param appID ID of the application.
* @param reply Query reply value.
*/
APT_ReplySleepQuery :: (appID: NS_APPID, reply: APT_QueryReply) -> Result #foreign libctru;

/**
* @brief Replies that a sleep notification has been completed.
* @param appID ID of the application.
*/
APT_ReplySleepNotificationComplete :: (appID: NS_APPID) -> Result #foreign libctru;

/**
* @brief Prepares to close the application.
* @param cancelPreload Whether applet preloads should be cancelled.
*/
APT_PrepareToCloseApplication :: (cancelPreload: bool) -> Result #foreign libctru;

/**
* @brief Closes the application.
* @param param Parameters to close with.
* @param paramSize Size of param.
* @param handle Handle to pass.
*/
APT_CloseApplication :: (param: *void, paramSize: size_t, handle: Handle) -> Result #foreign libctru;

/**
* @brief Sets the application's CPU time limit.
* @param percent CPU time limit percentage to set.
*/
APT_SetAppCpuTimeLimit :: (percent: u32) -> Result #foreign libctru;

/**
* @brief Gets the application's CPU time limit.
* @param percent Pointer to output the CPU time limit percentage to.
*/
APT_GetAppCpuTimeLimit :: (percent: *u32) -> Result #foreign libctru;

/**
* @brief Checks whether the system is a New 3DS.
* @param out Pointer to write the New 3DS flag to.
*/
APT_CheckNew3DS :: (out: *bool) -> Result #foreign libctru;

/**
* @brief Prepares for an applicaton jump.
* @param flags Flags to use.
* @param programID ID of the program to jump to.
* @param mediatype Media type of the program to jump to.
*/
APT_PrepareToDoApplicationJump :: (flags: u8, programID: u64, mediatype: u8) -> Result #foreign libctru;

/**
* @brief Performs an application jump.
* @param param Parameter buffer.
* @param paramSize Size of parameter buffer.
* @param hmac HMAC buffer (should be 0x20 bytes long).
*/
APT_DoApplicationJump :: (param: *void, paramSize: size_t, hmac: *void) -> Result #foreign libctru;

/**
* @brief Prepares to start a library applet.
* @param appID AppID of the applet to start.
*/
APT_PrepareToStartLibraryApplet :: (appID: NS_APPID) -> Result #foreign libctru;

/**
* @brief Starts a library applet.
* @param appID AppID of the applet to launch.
* @param param Buffer containing applet parameters.
* @param paramsize Size of the buffer.
* @param handle Handle to pass to the applet.
*/
APT_StartLibraryApplet :: (appID: NS_APPID, param: *void, paramSize: size_t, handle: Handle) -> Result #foreign libctru;

/**
* @brief Prepares to start a system applet.
* @param appID AppID of the applet to start.
*/
APT_PrepareToStartSystemApplet :: (appID: NS_APPID) -> Result #foreign libctru;

/**
* @brief Starts a system applet.
* @param appID AppID of the applet to launch.
* @param param Buffer containing applet parameters.
* @param paramSize Size of the parameter buffer.
* @param handle Handle to pass to the applet.
*/
APT_StartSystemApplet :: (appID: NS_APPID, param: *void, paramSize: size_t, handle: Handle) -> Result #foreign libctru;

/**
* @brief Retrieves the shared system font.
* @brief fontHandle Pointer to write the handle of the system font memory block to.
* @brief mapAddr Pointer to write the mapping address of the system font memory block to.
*/
APT_GetSharedFont :: (fontHandle: *Handle, mapAddr: *u32) -> Result #foreign libctru;

/**
* @brief Receives the deliver (launch) argument
* @param param Parameter buffer.
* @param paramSize Size of parameter buffer.
* @param hmac HMAC buffer (should be 0x20 bytes long).
* @param sender Pointer to output the sender's AppID to.
* @param received Pointer to output whether an argument was received to.
*/
APT_ReceiveDeliverArg :: (param: *void, paramSize: size_t, hmac: *void, sender: *u64, received: *bool) -> Result #foreign libctru;

/// BOSS context.
bossContext :: struct {
    property:     [7] u32;
    url:          [512] u8;
    property_x8:  u32;
    property_x9:  u8;
    property_xa:  [256] u8;
    property_xb:  [512] u8;
    property_xd:  [864] u8; //Additonal optional HTTP request headers.
    property_xe:  u32;
    property_xf:  [3] u32;
    property_x10: u8;
    property_x11: u8;
    property_x12: u8;
    property_x13: u32;
    property_x14: u32;
    property_x15: [64] u8;
    property_x16: u32;
    property_x3b: u32;
    property_x3e: [512] u8;
}

/// BOSS task status.
bossTaskStatus :: enum u8 {
    STARTED :: 2;
    ERROR   :: 7;
}

/// Type values for bossGetNsDataHeaderInfo().
bossNsDataHeaderInfoTypes :: enum u8 {
    bossNsDataHeaderInfoType_ContentSize :: 3;
}

/// Size of the output data for bossGetNsDataHeaderInfo().
bossNsDataHeaderInfoTypeSizes :: enum u8 {
    bossNsDataHeaderInfoTypeSize_ContentSize :: 4;
}

/**
* @brief Initializes BOSS.
* @param programID programID to use, 0 for the current process. Only used when BOSSP is available without *hax payload.
* @param force_user When true, just use bossU instead of trying to initialize with bossP first.
*/
bossInit :: (programID: u64, force_user: bool) -> Result #foreign libctru;

/**
* @brief Run the InitializeSession service cmd. This is mainly for changing the programID associated with the current BOSS session.
* @param programID programID to use, 0 for the current process.
*/
bossReinit :: (programID: u64) -> Result #foreign libctru;

/// Exits BOSS.
bossExit :: () -> void #foreign libctru;

/// Returns the BOSS session handle.
bossGetSessionHandle :: () -> Handle #foreign libctru;

/**
* @brief Set the content data storage location.
* @param extdataID u64 extdataID, must have the high word set to the shared-extdata value when it's for NAND.
* @param boss_size Probably the max size in the extdata which BOSS can use.
* @param mediaType Roughly the same as FS mediatype.
*/
bossSetStorageInfo :: (extdataID: u64, boss_size: u32, mediaType: u8) -> Result #foreign libctru;

/**
* @brief Unregister the content data storage location, which includes unregistering the BOSS-session programID with BOSS.
*/
bossUnregisterStorage :: () -> Result #foreign libctru;

/**
* @brief Register a task.
* @param taskID BOSS taskID.
* @param unk0 Unknown, usually zero.
* @param unk1 Unknown, usually zero.
*/
bossRegisterTask :: (taskID: *u8, unk0: u8, unk1: u8) -> Result #foreign libctru;

/**
* @brief Send a property.
* @param PropertyID PropertyID
* @param buf Input buffer data.
* @param size Buffer size.
*/
bossSendProperty :: (PropertyID: u16, buf: *void, size: u32) -> Result #foreign libctru;

/**
* @brief Deletes the content file for the specified NsDataId.
* @param NsDataId NsDataId
*/
bossDeleteNsData :: (NsDataId: u32) -> Result #foreign libctru;

/**
* @brief Gets header info for the specified NsDataId.
* @param NsDataId NsDataId
* @param type Type of data to load.
* @param buffer Output buffer.
* @param size Output buffer size.
*/
bossGetNsDataHeaderInfo :: (NsDataId: u32, type: u8, buffer: *void, size: u32) -> Result #foreign libctru;

/**
* @brief Reads data from the content for the specified NsDataId.
* @param NsDataId NsDataId
* @param offset Offset in the content.
* @param buffer Output buffer.
* @param size Output buffer size.
* @param transfer_total Optional output actual read size, can be NULL.
* @param unk_out Optional unknown output, can be NULL.
*/
bossReadNsData :: (NsDataId: u32, offset: u64, buffer: *void, size: u32, transfer_total: *u32, unk_out: *u32) -> Result #foreign libctru;

/**
* @brief Starts a task soon after running this command.
* @param taskID BOSS taskID.
*/
bossStartTaskImmediate :: (taskID: *u8) -> Result #foreign libctru;

/**
* @brief Similar to bossStartTaskImmediate?
* @param taskID BOSS taskID.
*/
bossStartBgImmediate :: (taskID: *u8) -> Result #foreign libctru;

/**
* @brief Deletes a task by using CancelTask and UnregisterTask internally.
* @param taskID BOSS taskID.
* @param unk Unknown, usually zero?
*/
bossDeleteTask :: (taskID: *u8, unk: u32) -> Result #foreign libctru;

/**
* @brief Returns task state.
* @param taskID BOSS taskID.
* @param inval Unknown, normally 0?
* @param status Output status, see bossTaskStatus.
* @param out1 Output field.
* @param out2 Output field.
*/
bossGetTaskState :: (taskID: *u8, inval: s8, status: *u8, out1: *u32, out2: *u8) -> Result #foreign libctru;

/**
* @brief This loads the current state of PropertyID 0x0 for the specified task.
* @param taskID BOSS taskID.
*/
bossGetTaskProperty0 :: (taskID: *u8, out: *u8) -> Result #foreign libctru;

/**
* @brief Setup a BOSS context with the default config.
* @param bossContext BOSS context.
* @param seconds_interval Interval in seconds for running the task automatically.
* @param url Task URL.
*/
bossSetupContextDefault :: (ctx: *bossContext, seconds_interval: u32, url: *u8) -> void #foreign libctru;

/**
* @brief Sends the config stored in the context. Used before registering a task.
* @param bossContext BOSS context.
*/
bossSendContextConfig :: (ctx: *bossContext) -> Result #foreign libctru;

/**
* @brief Input color formats
*
* For the 16-bit per component formats, bits 15-8 are padding and 7-0 contains the value.
*/
Y2RU_InputFormat :: enum u8 {
    _2_INDIV_8  :: 0;
    _0_INDIV_8  :: 1;
    _2_INDIV_16 :: 2;
    _0_INDIV_16 :: 3;
    _2_BATCH    :: 4;
}

/**
* @brief Output color formats
*
* Those are the same as the framebuffer and GPU texture formats.
*/
Y2RU_OutputFormat :: enum u8 {
    _32     :: 0;
    _24     :: 1;
    _16_555 :: 2;
    _16_565 :: 3;
}

/// Rotation to be applied to the output.
Y2RU_Rotation :: enum u8 {
    NONE          :: 0;
    CLOCKWISE_90  :: 1;
    CLOCKWISE_180 :: 2;
    CLOCKWISE_270 :: 3;
}

/**
* @brief Block alignment of output
*
* Defines the way the output will be laid out in memory.
*/
Y2RU_BlockAlignment :: enum u8 {
    LINE    :: 0;
    _8_BY_8 :: 1;
}

/**
* @brief Coefficients of the YUV->RGB conversion formula.
*
* A set of coefficients configuring the RGB to YUV conversion. Coefficients 0-4 are unsigned 2.8
* fixed pointer numbers representing entries on the conversion matrix, while coefficient 5-7 are
* signed 11.5 fixed point numbers added as offsets to the RGB result.
*
* The overall conversion process formula is:
* @code
* R = trunc((rgb_Y * Y           + r_V * V) + 0.75 + r_offset)
* G = trunc((rgb_Y * Y - g_U * U - g_V * V) + 0.75 + g_offset)
* B = trunc((rgb_Y * Y + b_U * U          ) + 0.75 + b_offset)
* @endcode
*/
Y2RU_ColorCoefficients :: struct {
    rgb_Y:    u16; ///< RGB per unit Y.
    r_V:      u16; ///< Red per unit V.
    g_V:      u16; ///< Green per unit V.
    g_U:      u16; ///< Green per unit U.
    b_U:      u16; ///< Blue per unit U.
    r_offset: u16; ///< Red offset.
    g_offset: u16; ///< Green offset.
    b_offset: u16; ///< Blue offset.
}

/**
* @brief Preset conversion coefficients based on ITU standards for the YUV->RGB formula.
*
* For more details refer to @ref Y2RU_ColorCoefficients
*/
Y2RU_StandardCoefficient :: enum u8 {
    _601         :: 0;
    _709         :: 1;
    _601_SCALING :: 2;
    _709_SCALING :: 3;
}

/**
* @brief Structure used to configure all parameters at once.
*
* You can send a batch of configuration parameters using this structure and @ref Y2RU_SetConversionParams.
*/
Y2RU_ConversionParams :: struct {
    input_format:         Y2RU_InputFormat; ///< Value passed to @ref Y2RU_SetInputFormat
    output_format:        Y2RU_OutputFormat; ///< Value passed to @ref Y2RU_SetOutputFormat
    rotation:             Y2RU_Rotation; ///< Value passed to @ref Y2RU_SetRotation
    block_alignment:      Y2RU_BlockAlignment; ///< Value passed to @ref Y2RU_SetBlockAlignment
    input_line_width:     s16; ///< Value passed to @ref Y2RU_SetInputLineWidth
    input_lines:          s16; ///< Value passed to @ref Y2RU_SetInputLines
    standard_coefficient: Y2RU_StandardCoefficient; ///< Value passed to @ref Y2RU_SetStandardCoefficient
    unused:               u8; ///< Unused.
    alpha:                u16; ///< Value passed to @ref Y2RU_SetAlpha
}

/// Dithering weights.
Y2RU_DitheringWeightParams :: struct {
    w0_xEven_yEven: u16; ///< Weight 0 for even X, even Y.
    w0_xOdd_yEven:  u16; ///< Weight 0 for odd X, even Y.
    w0_xEven_yOdd:  u16; ///< Weight 0 for even X, odd Y.
    w0_xOdd_yOdd:   u16; ///< Weight 0 for odd X, odd Y.
    w1_xEven_yEven: u16; ///< Weight 1 for even X, even Y.
    w1_xOdd_yEven:  u16; ///< Weight 1 for odd X, even Y.
    w1_xEven_yOdd:  u16; ///< Weight 1 for even X, odd Y.
    w1_xOdd_yOdd:   u16; ///< Weight 1 for odd X, odd Y.
    w2_xEven_yEven: u16; ///< Weight 2 for even X, even Y.
    w2_xOdd_yEven:  u16; ///< Weight 2 for odd X, even Y.
    w2_xEven_yOdd:  u16; ///< Weight 2 for even X, odd Y.
    w2_xOdd_yOdd:   u16; ///< Weight 2 for odd X, odd Y.
    w3_xEven_yEven: u16; ///< Weight 3 for even X, even Y.
    w3_xOdd_yEven:  u16; ///< Weight 3 for odd X, even Y.
    w3_xEven_yOdd:  u16; ///< Weight 3 for even X, odd Y.
    w3_xOdd_yOdd:   u16; ///< Weight 3 for odd X, odd Y.
}

/**
* @brief Initializes the y2r service.
*
* This will internally get the handle of the service, and on success call Y2RU_DriverInitialize.
*/
y2rInit :: () -> Result #foreign libctru;

/**
* @brief Closes the y2r service.
*
* This will internally call Y2RU_DriverFinalize and close the handle of the service.
*/
y2rExit :: () -> void #foreign libctru;

/**
* @brief Used to configure the input format.
* @param format Input format to use.
*
* @note Prefer using @ref Y2RU_SetConversionParams if you have to set multiple parameters.
*/
Y2RU_SetInputFormat :: (format: Y2RU_InputFormat) -> Result #foreign libctru;

/**
* @brief Gets the configured input format.
* @param format Pointer to output the input format to.
*/
Y2RU_GetInputFormat :: (format: *Y2RU_InputFormat) -> Result #foreign libctru;

/**
* @brief Used to configure the output format.
* @param format Output format to use.
*
* @note Prefer using @ref Y2RU_SetConversionParams if you have to set multiple parameters.
*/
Y2RU_SetOutputFormat :: (format: Y2RU_OutputFormat) -> Result #foreign libctru;

/**
* @brief Gets the configured output format.
* @param format Pointer to output the output format to.
*/
Y2RU_GetOutputFormat :: (format: *Y2RU_OutputFormat) -> Result #foreign libctru;

/**
* @brief Used to configure the rotation of the output.
* @param rotation Rotation to use.
*
* It seems to apply the rotation per batch of 8 lines, so the output will be (height/8) images of size 8 x width.
*
* @note Prefer using @ref Y2RU_SetConversionParams if you have to set multiple parameters.
*/
Y2RU_SetRotation :: (rotation: Y2RU_Rotation) -> Result #foreign libctru;

/**
* @brief Gets the configured rotation.
* @param rotation Pointer to output the rotation to.
*/
Y2RU_GetRotation :: (rotation: *Y2RU_Rotation) -> Result #foreign libctru;

/**
* @brief Used to configure the alignment of the output buffer.
* @param alignment Alignment to use.
*
* @note Prefer using @ref Y2RU_SetConversionParams if you have to set multiple parameters.
*/
Y2RU_SetBlockAlignment :: (alignment: Y2RU_BlockAlignment) -> Result #foreign libctru;

/**
* @brief Gets the configured alignment.
* @param alignment Pointer to output the alignment to.
*/
Y2RU_GetBlockAlignment :: (alignment: *Y2RU_BlockAlignment) -> Result #foreign libctru;

/**
* @brief Sets whether to use spacial dithering.
* @param enable Whether to use spacial dithering.
*/
Y2RU_SetSpacialDithering :: (enable: bool) -> Result #foreign libctru;

/**
* @brief Gets whether to use spacial dithering.
* @param enable Pointer to output the spacial dithering state to.
*/
Y2RU_GetSpacialDithering :: (enabled: *bool) -> Result #foreign libctru;

/**
* @brief Sets whether to use temporal dithering.
* @param enable Whether to use temporal dithering.
*/
Y2RU_SetTemporalDithering :: (enable: bool) -> Result #foreign libctru;

/**
* @brief Gets whether to use temporal dithering.
* @param enable Pointer to output the temporal dithering state to.
*/
Y2RU_GetTemporalDithering :: (enabled: *bool) -> Result #foreign libctru;

/**
* @brief Used to configure the width of the image.
* @param line_width Width of the image in pixels. Must be a multiple of 8, up to 1024.
*
* @note Prefer using @ref Y2RU_SetConversionParams if you have to set multiple parameters.
*/
Y2RU_SetInputLineWidth :: (line_width: u16) -> Result #foreign libctru;

/**
* @brief Gets the configured input line width.
* @param line_width Pointer to output the line width to.
*/
Y2RU_GetInputLineWidth :: (line_width: *u16) -> Result #foreign libctru;

/**
* @brief Used to configure the height of the image.
* @param num_lines Number of lines to be converted.
*
* A multiple of 8 seems to be preferred.
* If using the @ref BLOCK_8_BY_8 mode, it must be a multiple of 8.
*
* @note Prefer using @ref Y2RU_SetConversionParams if you have to set multiple parameters.
*/
Y2RU_SetInputLines :: (num_lines: u16) -> Result #foreign libctru;

/**
* @brief Gets the configured number of input lines.
* @param num_lines Pointer to output the input lines to.
*/
Y2RU_GetInputLines :: (num_lines: *u16) -> Result #foreign libctru;

/**
* @brief Used to configure the color conversion formula.
* @param coefficients Coefficients to use.
*
* See @ref Y2RU_ColorCoefficients for more information about the coefficients.
*
* @note Prefer using @ref Y2RU_SetConversionParams if you have to set multiple parameters.
*/
Y2RU_SetCoefficients :: (coefficients: *Y2RU_ColorCoefficients) -> Result #foreign libctru;

/**
* @brief Gets the configured color coefficients.
* @param num_lines Pointer to output the coefficients to.
*/
Y2RU_GetCoefficients :: (coefficients: *Y2RU_ColorCoefficients) -> Result #foreign libctru;

/**
* @brief Used to configure the color conversion formula with ITU stantards coefficients.
* @param coefficient Standard coefficient to use.
*
* See @ref Y2RU_ColorCoefficients for more information about the coefficients.
*
* @note Prefer using @ref Y2RU_SetConversionParams if you have to set multiple parameters.
*/
Y2RU_SetStandardCoefficient :: (coefficient: Y2RU_StandardCoefficient) -> Result #foreign libctru;

/**
* @brief Gets the color coefficient parameters of a standard coefficient.
* @param coefficients Pointer to output the coefficients to.
* @param standardCoeff Standard coefficient to check.
*/
Y2RU_GetStandardCoefficient :: (coefficients: *Y2RU_ColorCoefficients, standardCoeff: Y2RU_StandardCoefficient) -> Result #foreign libctru;

/**
* @brief Used to configure the alpha value of the output.
* @param alpha 8-bit value to be used for the output when the format requires it.
*
* @note Prefer using @ref Y2RU_SetConversionParams if you have to set multiple parameters.
*/
Y2RU_SetAlpha :: (alpha: u16) -> Result #foreign libctru;

/**
* @brief Gets the configured output alpha value.
* @param alpha Pointer to output the alpha value to.
*/
Y2RU_GetAlpha :: (alpha: *u16) -> Result #foreign libctru;

/**
* @brief Used to enable the end of conversion interrupt.
* @param should_interrupt Enables the interrupt if true, disable it if false.
*
* It is possible to fire an interrupt when the conversion is finished, and that the DMA is done copying the data.
* This interrupt will then be used to fire an event. See @ref Y2RU_GetTransferEndEvent.
* By default the interrupt is enabled.
*
* @note It seems that the event can be fired too soon in some cases, depending the transfer_unit size.\n Please see the note at @ref Y2RU_SetReceiving
*/
Y2RU_SetTransferEndInterrupt :: (should_interrupt: bool) -> Result #foreign libctru;

/**
* @brief Gets whether the transfer end interrupt is enabled.
* @param should_interrupt Pointer to output the interrupt state to.
*/
Y2RU_GetTransferEndInterrupt :: (should_interrupt: *bool) -> Result #foreign libctru;

/**
* @brief Gets an handle to the end of conversion event.
* @param end_event Pointer to the event handle to be set to the end of conversion event. It isn't necessary to create or close this handle.
*
* To enable this event you have to use @code{C} Y2RU_SetTransferEndInterrupt(true);@endcode
* The event will be triggered when the corresponding interrupt is fired.
*
* @note It is recommended to use a timeout when waiting on this event, as it sometimes (but rarely) isn't triggered.
*/
Y2RU_GetTransferEndEvent :: (end_event: *Handle) -> Result #foreign libctru;

/**
* @brief Configures the Y plane buffer.
* @param src_buf A pointer to the beginning of your Y data buffer.
* @param image_size The total size of the data buffer.
* @param transfer_unit Specifies the size of 1 DMA transfer. Usually set to 1 line. This has to be a divisor of image_size.
* @param transfer_gap Specifies the gap (offset) to be added after each transfer. Can be used to convert images with stride or only a part of it.
*
* @warning transfer_unit+transfer_gap must be less than 32768 (0x8000)
*
* This specifies the Y data buffer for the planar input formats (INPUT_YUV42*_INDIV_*).
* The actual transfer will only happen after calling @ref Y2RU_StartConversion.
*/
Y2RU_SetSendingY :: (src_buf: *void, image_size: u32, transfer_unit: s16, transfer_gap: s16) -> Result #foreign libctru;

/**
* @brief Configures the U plane buffer.
* @param src_buf A pointer to the beginning of your Y data buffer.
* @param image_size The total size of the data buffer.
* @param transfer_unit Specifies the size of 1 DMA transfer. Usually set to 1 line. This has to be a divisor of image_size.
* @param transfer_gap Specifies the gap (offset) to be added after each transfer. Can be used to convert images with stride or only a part of it.
*
* @warning transfer_unit+transfer_gap must be less than 32768 (0x8000)
*
* This specifies the U data buffer for the planar input formats (INPUT_YUV42*_INDIV_*).
* The actual transfer will only happen after calling @ref Y2RU_StartConversion.
*/
Y2RU_SetSendingU :: (src_buf: *void, image_size: u32, transfer_unit: s16, transfer_gap: s16) -> Result #foreign libctru;

/**
* @brief Configures the V plane buffer.
* @param src_buf A pointer to the beginning of your Y data buffer.
* @param image_size The total size of the data buffer.
* @param transfer_unit Specifies the size of 1 DMA transfer. Usually set to 1 line. This has to be a divisor of image_size.
* @param transfer_gap Specifies the gap (offset) to be added after each transfer. Can be used to convert images with stride or only a part of it.
*
* @warning transfer_unit+transfer_gap must be less than 32768 (0x8000)
*
* This specifies the V data buffer for the planar input formats (INPUT_YUV42*_INDIV_*).
* The actual transfer will only happen after calling @ref Y2RU_StartConversion.
*/
Y2RU_SetSendingV :: (src_buf: *void, image_size: u32, transfer_unit: s16, transfer_gap: s16) -> Result #foreign libctru;

/**
* @brief Configures the YUYV source buffer.
* @param src_buf A pointer to the beginning of your Y data buffer.
* @param image_size The total size of the data buffer.
* @param transfer_unit Specifies the size of 1 DMA transfer. Usually set to 1 line. This has to be a divisor of image_size.
* @param transfer_gap Specifies the gap (offset) to be added after each transfer. Can be used to convert images with stride or only a part of it.
*
* @warning transfer_unit+transfer_gap must be less than 32768 (0x8000)
*
* This specifies the YUYV data buffer for the packed input format @ref INPUT_YUV422_BATCH.
* The actual transfer will only happen after calling @ref Y2RU_StartConversion.
*/
Y2RU_SetSendingYUYV :: (src_buf: *void, image_size: u32, transfer_unit: s16, transfer_gap: s16) -> Result #foreign libctru;

/**
* @brief Configures the destination buffer.
* @param src_buf A pointer to the beginning of your destination buffer in FCRAM
* @param image_size The total size of the data buffer.
* @param transfer_unit Specifies the size of 1 DMA transfer. Usually set to 1 line. This has to be a divisor of image_size.
* @param transfer_gap Specifies the gap (offset) to be added after each transfer. Can be used to convert images with stride or only a part of it.
*
* This specifies the destination buffer of the conversion.
* The actual transfer will only happen after calling @ref Y2RU_StartConversion.
* The buffer does NOT need to be allocated in the linear heap.
*
* @warning transfer_unit+transfer_gap must be less than 32768 (0x8000)
*
* @note
*      It seems that depending on the size of the image and of the transfer unit,\n
*      it is possible for the end of conversion interrupt to be triggered right after the conversion began.\n
*      One line as transfer_unit seems to trigger this issue for 400x240, setting to 2/4/8 lines fixes it.
*
* @note Setting a transfer_unit of 4 or 8 lines seems to bring the best results in terms of speed for a 400x240 image.
*/
Y2RU_SetReceiving :: (dst_buf: *void, image_size: u32, transfer_unit: s16, transfer_gap: s16) -> Result #foreign libctru;

/**
* @brief Checks if the DMA has finished sending the Y buffer.
* @param is_done Pointer to the boolean that will hold the result.
*
* True if the DMA has finished transferring the Y plane, false otherwise. To be used with @ref Y2RU_SetSendingY.
*/
Y2RU_IsDoneSendingY :: (is_done: *bool) -> Result #foreign libctru;

/**
* @brief Checks if the DMA has finished sending the U buffer.
* @param is_done Pointer to the boolean that will hold the result.
*
* True if the DMA has finished transferring the U plane, false otherwise. To be used with @ref Y2RU_SetSendingU.
*/
Y2RU_IsDoneSendingU :: (is_done: *bool) -> Result #foreign libctru;

/**
* @brief Checks if the DMA has finished sending the V buffer.
* @param is_done Pointer to the boolean that will hold the result.
*
* True if the DMA has finished transferring the V plane, false otherwise. To be used with @ref Y2RU_SetSendingV.
*/
Y2RU_IsDoneSendingV :: (is_done: *bool) -> Result #foreign libctru;

/**
* @brief Checks if the DMA has finished sending the YUYV buffer.
* @param is_done Pointer to the boolean that will hold the result.
*
* True if the DMA has finished transferring the YUYV buffer, false otherwise. To be used with @ref Y2RU_SetSendingYUYV.
*/
Y2RU_IsDoneSendingYUYV :: (is_done: *bool) -> Result #foreign libctru;

/**
* @brief Checks if the DMA has finished sending the converted result.
* @param is_done Pointer to the boolean that will hold the result.
*
* True if the DMA has finished transferring data to your destination buffer, false otherwise.
*/
Y2RU_IsDoneReceiving :: (is_done: *bool) -> Result #foreign libctru;

/**
* @brief Configures the dithering weight parameters.
* @param params Dithering weight parameters to use.
*/
Y2RU_SetDitheringWeightParams :: (params: *Y2RU_DitheringWeightParams) -> Result #foreign libctru;

/**
* @brief Gets the configured dithering weight parameters.
* @param params Pointer to output the dithering weight parameters to.
*/
Y2RU_GetDitheringWeightParams :: (params: *Y2RU_DitheringWeightParams) -> Result #foreign libctru;

/**
* @brief Sets all of the parameters of Y2RU_ConversionParams at once.
* @param params Conversion parameters to set.
*
* Faster than calling the individual value through Y2R_Set* because only one system call is made.
*/
Y2RU_SetConversionParams :: (params: *Y2RU_ConversionParams) -> Result #foreign libctru;

/// Starts the conversion process
Y2RU_StartConversion :: () -> Result #foreign libctru;

/// Cancels the conversion
Y2RU_StopConversion :: () -> Result #foreign libctru;

/**
* @brief Checks if the conversion and DMA transfer are finished.
* @param is_busy Pointer to output the busy state to.
*
* This can have the same problems as the event and interrupt. See @ref Y2RU_SetTransferEndInterrupt.
*/
Y2RU_IsBusyConversion :: (is_busy: *bool) -> Result #foreign libctru;

/**
* @brief Checks whether Y2R is ready to be used.
* @param ping Pointer to output the ready status to.
*/
Y2RU_PingProcess :: (ping: *u8) -> Result #foreign libctru;

/// Initializes the Y2R driver.
Y2RU_DriverInitialize :: () -> Result #foreign libctru;

/// Terminates the Y2R driver.
Y2RU_DriverFinalize :: () -> Result #foreign libctru;

/// Camera connection target ports.
PORT :: enum u8 {
    NONE :: 0;
    CAM1 :: 1;
    CAM2 :: 2;
    BOTH :: 3;
}

/// Camera combinations.
SELECT :: enum u8 {
    NONE      :: 0;
    OUT1      :: 1;
    IN1       :: 2;
    OUT2      :: 4;
    IN1_OUT1  :: 3;
    OUT1_OUT2 :: 5;
    IN1_OUT2  :: 6;
    ALL       :: 7;
}

/// Camera contexts.
CAMU_Context :: enum u8 {
    NONE :: 0;
    A    :: 1;
    B    :: 2;
    BOTH :: 3;
}

/// Ways to flip the camera image.
CAMU_Flip :: enum u8 {
    NONE       :: 0;
    HORIZONTAL :: 1;
    VERTICAL   :: 2;
    REVERSE    :: 3;
}

/// Camera image resolutions.
CAMU_Size :: enum u8 {
    VGA            :: 0;
    QVGA           :: 1;
    QQVGA          :: 2;
    CIF            :: 3;
    QCIF           :: 4;
    DS_LCD         :: 5;
    DS_LCDx4       :: 6;
    CTR_TOP_LCD    :: 7;
    CTR_BOTTOM_LCD :: 1;
}

/// Camera capture frame rates.
CAMU_FrameRate :: enum u8 {
    _15       :: 0;
    _15_TO_5  :: 1;
    _15_TO_2  :: 2;
    _10       :: 3;
    _8_5      :: 4;
    _5        :: 5;
    _20       :: 6;
    _20_TO_5  :: 7;
    _30       :: 8;
    _30_TO_5  :: 9;
    _15_TO_10 :: 10;
    _20_TO_10 :: 11;
    _30_TO_10 :: 12;
}

/// Camera white balance modes.
CAMU_WhiteBalance :: enum u8 {
    AUTO                    :: 0;
    _3200K                  :: 1;
    _4150K                  :: 2;
    _5200K                  :: 3;
    _6000K                  :: 4;
    _7000K                  :: 5;
    NORMAL                  :: 0;
    TUNGSTEN                :: 1;
    WHITE_FLUORESCENT_LIGHT :: 2;
    DAYLIGHT                :: 3;
    CLOUDY                  :: 4;
    HORIZON                 :: 4;
    SHADE                   :: 5;
}

/// Camera photo modes.
CAMU_PhotoMode :: enum u8 {
    NORMAL    :: 0;
    PORTRAIT  :: 1;
    LANDSCAPE :: 2;
    NIGHTVIEW :: 3;
    LETTER    :: 4;
}

/// Camera special effects.
CAMU_Effect :: enum u8 {
    NONE     :: 0;
    MONO     :: 1;
    SEPIA    :: 2;
    NEGATIVE :: 3;
    NEGAFILM :: 4;
    SEPIA01  :: 5;
}

/// Camera contrast patterns.
CAMU_Contrast :: enum u8 {
    PATTERN_01 :: 0;
    PATTERN_02 :: 1;
    PATTERN_03 :: 2;
    PATTERN_04 :: 3;
    PATTERN_05 :: 4;
    PATTERN_06 :: 5;
    PATTERN_07 :: 6;
    PATTERN_08 :: 7;
    PATTERN_09 :: 8;
    PATTERN_10 :: 9;
    PATTERN_11 :: 10;
    LOW        :: 4;
    NORMAL     :: 5;
    HIGH       :: 6;
}

/// Camera lens correction modes.
CAMU_LensCorrection :: enum u8 {
    OFF    :: 0;
    ON_70  :: 1;
    ON_90  :: 2;
    DARK   :: 0;
    NORMAL :: 1;
    BRIGHT :: 2;
}

/// Camera image output formats.
CAMU_OutputFormat :: enum u8 {
    YUV_422 :: 0;
    RGB_565 :: 1;
}

/// Camera shutter sounds.
CAMU_ShutterSoundType :: enum u8 {
    NORMAL    :: 0;
    MOVIE     :: 1;
    MOVIE_END :: 2;
}

/// Image quality calibration data.
CAMU_ImageQualityCalibrationData :: struct {
    aeBaseTarget:   s16; ///< Auto exposure base target brightness.
    kRL:            s16; ///< Left color correction matrix red normalization coefficient.
    kGL:            s16; ///< Left color correction matrix green normalization coefficient.
    kBL:            s16; ///< Left color correction matrix blue normalization coefficient.
    ccmPosition:    s16; ///< Color correction matrix position.
    awbCcmL9Right:  u16; ///< Right camera, left color correction matrix red/green gain.
    awbCcmL9Left:   u16; ///< Left camera, left color correction matrix red/green gain.
    awbCcmL10Right: u16; ///< Right camera, left color correction matrix blue/green gain.
    awbCcmL10Left:  u16; ///< Left camera, left color correction matrix blue/green gain.
    awbX0Right:     u16; ///< Right camera, color correction matrix position threshold.
    awbX0Left:      u16; ///< Left camera, color correction matrix position threshold.
}

/// Stereo camera calibration data.
CAMU_StereoCameraCalibrationData :: struct {
    isValidRotationXY: u8; ///< #bool Whether the X and Y rotation data is valid.
    padding:           [3] u8; ///< Padding. (Aligns isValidRotationXY to 4 bytes)
    scale:             float; ///< Scale to match the left camera image with the right.
    rotationZ:         float; ///< Z axis rotation to match the left camera image with the right.
    translationX:      float; ///< X axis translation to match the left camera image with the right.
    translationY:      float; ///< Y axis translation to match the left camera image with the right.
    rotationX:         float; ///< X axis rotation to match the left camera image with the right.
    rotationY:         float; ///< Y axis rotation to match the left camera image with the right.
    angleOfViewRight:  float; ///< Right camera angle of view.
    angleOfViewLeft:   float; ///< Left camera angle of view.
    distanceToChart:   float; ///< Distance between cameras and measurement chart.
    distanceCameras:   float; ///< Distance between left and right cameras.
    imageWidth:        s16; ///< Image width.
    imageHeight:       s16; ///< Image height.
    reserved:          [16] u8; ///< Reserved for future use. (unused)
}

/// Batch camera configuration for use without a context.
CAMU_PackageParameterCameraSelect :: struct {
    camera:                       u8; ///< Selected camera.
    exposure:                     s8; ///< Camera exposure.
    whiteBalance:                 u8; ///< #CAMU_WhiteBalance Camera white balance.
    sharpness:                    s8; ///< Camera sharpness.
    autoExposureOn:               u8; ///< #bool Whether to automatically determine the proper exposure.
    autoWhiteBalanceOn:           u8; ///< #bool Whether to automatically determine the white balance mode.
    frameRate:                    u8; ///< #CAMU_FrameRate Camera frame rate.
    photoMode:                    u8; ///< #CAMU_PhotoMode Camera photo mode.
    contrast:                     u8; ///< #CAMU_Contrast Camera contrast.
    lensCorrection:               u8; ///< #CAMU_LensCorrection Camera lens correction.
    noiseFilterOn:                u8; ///< #bool Whether to enable the camera's noise filter.
    padding:                      u8; ///< Padding. (Aligns last 3 fields to 4 bytes)
    autoExposureWindowX:          s16; ///< X of the region to use for auto exposure.
    autoExposureWindowY:          s16; ///< Y of the region to use for auto exposure.
    autoExposureWindowWidth:      s16; ///< Width of the region to use for auto exposure.
    autoExposureWindowHeight:     s16; ///< Height of the region to use for auto exposure.
    autoWhiteBalanceWindowX:      s16; ///< X of the region to use for auto white balance.
    autoWhiteBalanceWindowY:      s16; ///< Y of the region to use for auto white balance.
    autoWhiteBalanceWindowWidth:  s16; ///< Width of the region to use for auto white balance.
    autoWhiteBalanceWindowHeight: s16; ///< Height of the region to use for auto white balance.
}

/// Batch camera configuration for use with a context.
CAMU_PackageParameterContext :: struct {
    camera:   u8; ///< Selected camera.
    _context: u8; ///< #CAMU_Context Selected context.
    flip:     u8; ///< #CAMU_Flip Camera image flip mode.
    effect:   u8; ///< #CAMU_Effect Camera image special effects.
    size:     u8; ///< #CAMU_Size Camera image resolution.
}

/// Batch camera configuration for use with a context and with detailed size information.
CAMU_PackageParameterContextDetail :: struct {
    camera:   u8; ///< Selected camera.
    _context: u8; ///< #CAMU_Context Selected context.
    flip:     u8; ///< #CAMU_Flip Camera image flip mode.
    effect:   u8; ///< #CAMU_Effect Camera image special effects.
    width:    s16; ///< Image width.
    height:   s16; ///< Image height.
    cropX0:   s16; ///< First crop point X.
    cropY0:   s16; ///< First crop point Y.
    cropX1:   s16; ///< Second crop point X.
    cropY1:   s16; ///< Second crop point Y.
}

/**
* @brief Initializes the cam service.
*
* This will internally get the handle of the service, and on success call CAMU_DriverInitialize.
*/
camInit :: () -> Result #foreign libctru;

/**
* @brief Closes the cam service.
*
* This will internally call CAMU_DriverFinalize and close the handle of the service.
*/
camExit :: () -> void #foreign libctru;

/**
* Begins capture on the specified camera port.
* @param port Port to begin capture on.
*/
CAMU_StartCapture :: (port: u32) -> Result #foreign libctru;

/**
* Terminates capture on the specified camera port.
* @param port Port to terminate capture on.
*/
CAMU_StopCapture :: (port: u32) -> Result #foreign libctru;

/**
* @brief Gets whether the specified camera port is busy.
* @param busy Pointer to output the busy state to.
* @param port Port to check.
*/
CAMU_IsBusy :: (busy: *bool, port: u32) -> Result #foreign libctru;

/**
* @brief Clears the buffer and error flags of the specified camera port.
* @param port Port to clear.
*/
CAMU_ClearBuffer :: (port: u32) -> Result #foreign libctru;

/**
* @brief Gets a handle to the event signaled on vsync interrupts.
* @param event Pointer to output the event handle to.
* @param port Port to use.
*/
CAMU_GetVsyncInterruptEvent :: (event: *Handle, port: u32) -> Result #foreign libctru;

/**
* @brief Gets a handle to the event signaled on camera buffer errors.
* @param event Pointer to output the event handle to.
* @param port Port to use.
*/
CAMU_GetBufferErrorInterruptEvent :: (event: *Handle, port: u32) -> Result #foreign libctru;

/**
* @brief Initiates the process of receiving a camera frame.
* @param event Pointer to output the completion event handle to.
* @param dst Buffer to write data to.
* @param port Port to receive from.
* @param imageSize Size of the image to receive.
* @param transferUnit Transfer unit to use when receiving.
*/
CAMU_SetReceiving :: (event: *Handle, dst: *void, port: u32, imageSize: u32, transferUnit: s16) -> Result #foreign libctru;

/**
* @brief Gets whether the specified camera port has finished receiving image data.
* @param finishedReceiving Pointer to output the receiving status to.
* @param port Port to check.
*/
CAMU_IsFinishedReceiving :: (finishedReceiving: *bool, port: u32) -> Result #foreign libctru;

/**
* @brief Sets the number of lines to transfer into an image buffer.
* @param port Port to use.
* @param lines Lines to transfer.
* @param width Width of the image.
* @param height Height of the image.
*/
CAMU_SetTransferLines :: (port: u32, lines: s16, width: s16, height: s16) -> Result #foreign libctru;

/**
* @brief Gets the maximum number of lines that can be saved to an image buffer.
* @param maxLines Pointer to write the maximum number of lines to.
* @param width Width of the image.
* @param height Height of the image.
*/
CAMU_GetMaxLines :: (maxLines: *s16, width: s16, height: s16) -> Result #foreign libctru;

/**
* @brief Sets the number of bytes to transfer into an image buffer.
* @param port Port to use.
* @param bytes Bytes to transfer.
* @param width Width of the image.
* @param height Height of the image.
*/
CAMU_SetTransferBytes :: (port: u32, bytes: u32, width: s16, height: s16) -> Result #foreign libctru;

/**
* @brief Gets the number of bytes to transfer into an image buffer.
* @param transferBytes Pointer to write the number of bytes to.
* @param port Port to use.
*/
CAMU_GetTransferBytes :: (transferBytes: *u32, port: u32) -> Result #foreign libctru;

/**
* @brief Gets the maximum number of bytes that can be saved to an image buffer.
* @param maxBytes Pointer to write the maximum number of bytes to.
* @param width Width of the image.
* @param height Height of the image.
*/
CAMU_GetMaxBytes :: (maxBytes: *u32, width: s16, height: s16) -> Result #foreign libctru;

/**
* @brief Sets whether image trimming is enabled.
* @param port Port to use.
* @param trimming Whether image trimming is enabled.
*/
CAMU_SetTrimming :: (port: u32, trimming: bool) -> Result #foreign libctru;

/**
* @brief Gets whether image trimming is enabled.
* @param trimming Pointer to output the trim state to.
* @param port Port to use.
*/
CAMU_IsTrimming :: (trimming: *bool, port: u32) -> Result #foreign libctru;

/**
* @brief Sets the parameters used for trimming images.
* @param port Port to use.
* @param xStart Start X coordinate.
* @param yStart Start Y coordinate.
* @param xEnd End X coordinate.
* @param yEnd End Y coordinate.
*/
CAMU_SetTrimmingParams :: (port: u32, xStart: s16, yStart: s16, xEnd: s16, yEnd: s16) -> Result #foreign libctru;

/**
* @brief Gets the parameters used for trimming images.
* @param xStart Pointer to write the start X coordinate to.
* @param yStart Pointer to write the start Y coordinate to.
* @param xEnd Pointer to write the end X coordinate to.
* @param yEnd Pointer to write the end Y coordinate to.
* @param port Port to use.
*/
CAMU_GetTrimmingParams :: (xStart: *s16, yStart: *s16, xEnd: *s16, yEnd: *s16, port: u32) -> Result #foreign libctru;

/**
* @brief Sets the parameters used for trimming images, relative to the center of the image.
* @param port Port to use.
* @param trimWidth Trim width.
* @param trimHeight Trim height.
* @param camWidth Camera width.
* @param camHeight Camera height.
*/
CAMU_SetTrimmingParamsCenter :: (port: u32, trimWidth: s16, trimHeight: s16, camWidth: s16, camHeight: s16) -> Result #foreign libctru;

/**
* @brief Activates the specified camera.
* @param select Camera to use.
*/
CAMU_Activate :: (select: u32) -> Result #foreign libctru;

/**
* @brief Switches the specified camera's active context.
* @param select Camera to use.
* @param context Context to use.
*/
CAMU_SwitchContext :: (select: u32, _context: CAMU_Context) -> Result #foreign libctru;

/**
* @brief Sets the exposure value of the specified camera.
* @param select Camera to use.
* @param exposure Exposure value to use.
*/
CAMU_SetExposure :: (select: u32, exposure: s8) -> Result #foreign libctru;

/**
* @brief Sets the white balance mode of the specified camera.
* @param select Camera to use.
* @param whiteBalance White balance mode to use.
*/
CAMU_SetWhiteBalance :: (select: u32, whiteBalance: CAMU_WhiteBalance) -> Result #foreign libctru;

/**
* @brief Sets the white balance mode of the specified camera.
* TODO: Explain "without base up"?
* @param select Camera to use.
* @param whiteBalance White balance mode to use.
*/
CAMU_SetWhiteBalanceWithoutBaseUp :: (select: u32, whiteBalance: CAMU_WhiteBalance) -> Result #foreign libctru;

/**
* @brief Sets the sharpness of the specified camera.
* @param select Camera to use.
* @param sharpness Sharpness to use.
*/
CAMU_SetSharpness :: (select: u32, sharpness: s8) -> Result #foreign libctru;

/**
* @brief Sets whether auto exposure is enabled on the specified camera.
* @param select Camera to use.
* @param autoWhiteBalance Whether auto exposure is enabled.
*/
CAMU_SetAutoExposure :: (select: u32, autoExposure: bool) -> Result #foreign libctru;

/**
* @brief Gets whether auto exposure is enabled on the specified camera.
* @param autoExposure Pointer to output the auto exposure state to.
* @param select Camera to use.
*/
CAMU_IsAutoExposure :: (autoExposure: *bool, select: u32) -> Result #foreign libctru;

/**
* @brief Sets whether auto white balance is enabled on the specified camera.
* @param select Camera to use.
* @param autoWhiteBalance Whether auto white balance is enabled.
*/
CAMU_SetAutoWhiteBalance :: (select: u32, autoWhiteBalance: bool) -> Result #foreign libctru;

/**
* @brief Gets whether auto white balance is enabled on the specified camera.
* @param autoWhiteBalance Pointer to output the auto white balance state to.
* @param select Camera to use.
*/
CAMU_IsAutoWhiteBalance :: (autoWhiteBalance: *bool, select: u32) -> Result #foreign libctru;

/**
* @brief Flips the image of the specified camera in the specified context.
* @param select Camera to use.
* @param flip Flip mode to use.
* @param context Context to use.
*/
CAMU_FlipImage :: (select: u32, flip: CAMU_Flip, _context: CAMU_Context) -> Result #foreign libctru;

/**
* @brief Sets the image resolution of the given camera in the given context, in detail.
* @param select Camera to use.
* @param width Width to use.
* @param height Height to use.
* @param cropX0 First crop point X.
* @param cropY0 First crop point Y.
* @param cropX1 Second crop point X.
* @param cropY1 Second crop point Y.
* @param context Context to use.
*/
CAMU_SetDetailSize :: (select: u32, width: s16, height: s16, cropX0: s16, cropY0: s16, cropX1: s16, cropY1: s16, _context: CAMU_Context) -> Result #foreign libctru;

/**
* @brief Sets the image resolution of the given camera in the given context.
* @param select Camera to use.
* @param size Size to use.
* @param context Context to use.
*/
CAMU_SetSize :: (select: u32, size: CAMU_Size, _context: CAMU_Context) -> Result #foreign libctru;

/**
* @brief Sets the frame rate of the given camera.
* @param select Camera to use.
* @param frameRate Frame rate to use.
*/
CAMU_SetFrameRate :: (select: u32, frameRate: CAMU_FrameRate) -> Result #foreign libctru;

/**
* @brief Sets the photo mode of the given camera.
* @param select Camera to use.
* @param photoMode Photo mode to use.
*/
CAMU_SetPhotoMode :: (select: u32, photoMode: CAMU_PhotoMode) -> Result #foreign libctru;

/**
* @brief Sets the special effects of the given camera in the given context.
* @param select Camera to use.
* @param effect Effect to use.
* @param context Context to use.
*/
CAMU_SetEffect :: (select: u32, effect: CAMU_Effect, _context: CAMU_Context) -> Result #foreign libctru;

/**
* @brief Sets the contrast mode of the given camera.
* @param select Camera to use.
* @param contrast Contrast mode to use.
*/
CAMU_SetContrast :: (select: u32, contrast: CAMU_Contrast) -> Result #foreign libctru;

/**
* @brief Sets the lens correction mode of the given camera.
* @param select Camera to use.
* @param lensCorrection Lens correction mode to use.
*/
CAMU_SetLensCorrection :: (select: u32, lensCorrection: CAMU_LensCorrection) -> Result #foreign libctru;

/**
* @brief Sets the output format of the given camera in the given context.
* @param select Camera to use.
* @param format Format to output.
* @param context Context to use.
*/
CAMU_SetOutputFormat :: (select: u32, format: CAMU_OutputFormat, _context: CAMU_Context) -> Result #foreign libctru;

/**
* @brief Sets the region to base auto exposure off of for the specified camera.
* @param select Camera to use.
* @param x X of the region.
* @param y Y of the region.
* @param width Width of the region.
* @param height Height of the region.
*/
CAMU_SetAutoExposureWindow :: (select: u32, x: s16, y: s16, width: s16, height: s16) -> Result #foreign libctru;

/**
* @brief Sets the region to base auto white balance off of for the specified camera.
* @param select Camera to use.
* @param x X of the region.
* @param y Y of the region.
* @param width Width of the region.
* @param height Height of the region.
*/
CAMU_SetAutoWhiteBalanceWindow :: (select: u32, x: s16, y: s16, width: s16, height: s16) -> Result #foreign libctru;

/**
* @brief Sets whether the specified camera's noise filter is enabled.
* @param select Camera to use.
* @param noiseFilter Whether the noise filter is enabled.
*/
CAMU_SetNoiseFilter :: (select: u32, noiseFilter: bool) -> Result #foreign libctru;

/**
* @brief Synchronizes the specified cameras' vsync timing.
* @param select1 First camera.
* @param select2 Second camera.
*/
CAMU_SynchronizeVsyncTiming :: (select1: u32, select2: u32) -> Result #foreign libctru;

/**
* @brief Gets the vsync timing record of the specified camera for the specified number of signals.
* @param timing Pointer to write timing data to. (size "past * sizeof(s64)")
* @param port Port to use.
* @param past Number of past timings to retrieve.
*/
CAMU_GetLatestVsyncTiming :: (timing: *s64, port: u32, past: u32) -> Result #foreign libctru;

/**
* @brief Gets the specified camera's stereo camera calibration data.
* @param data Pointer to output the stereo camera data to.
*/
CAMU_GetStereoCameraCalibrationData :: (data: *CAMU_StereoCameraCalibrationData) -> Result #foreign libctru;

/**
* @brief Sets the specified camera's stereo camera calibration data.
* @param data Data to set.
*/
CAMU_SetStereoCameraCalibrationData :: (data: CAMU_StereoCameraCalibrationData) -> Result #foreign libctru;

/**
* @brief Writes to the specified I2C register of the specified camera.
* @param select Camera to write to.
* @param addr Address to write to.
* @param data Data to write.
*/
CAMU_WriteRegisterI2c :: (select: u32, addr: u16, data: u16) -> Result #foreign libctru;

/**
* @brief Writes to the specified MCU variable of the specified camera.
* @param select Camera to write to.
* @param addr Address to write to.
* @param data Data to write.
*/
CAMU_WriteMcuVariableI2c :: (select: u32, addr: u16, data: u16) -> Result #foreign libctru;

/**
* @brief Reads the specified I2C register of the specified camera.
* @param data Pointer to read data to.
* @param select Camera to read from.
* @param addr Address to read.
*/
CAMU_ReadRegisterI2cExclusive :: (data: *u16, select: u32, addr: u16) -> Result #foreign libctru;

/**
* @brief Reads the specified MCU variable of the specified camera.
* @param data Pointer to read data to.
* @param select Camera to read from.
* @param addr Address to read.
*/
CAMU_ReadMcuVariableI2cExclusive :: (data: *u16, select: u32, addr: u16) -> Result #foreign libctru;

/**
* @brief Sets the specified camera's image quality calibration data.
* @param data Data to set.
*/
CAMU_SetImageQualityCalibrationData :: (data: CAMU_ImageQualityCalibrationData) -> Result #foreign libctru;

/**
* @brief Gets the specified camera's image quality calibration data.
* @param data Pointer to write the quality data to.
*/
CAMU_GetImageQualityCalibrationData :: (data: *CAMU_ImageQualityCalibrationData) -> Result #foreign libctru;

/**
* @brief Configures a camera with pre-packaged configuration data without a context.
* @param Parameter to use.
*/
CAMU_SetPackageParameterWithoutContext :: (param: CAMU_PackageParameterCameraSelect) -> Result #foreign libctru;

/**
* @brief Configures a camera with pre-packaged configuration data with a context.
* @param Parameter to use.
*/
CAMU_SetPackageParameterWithContext :: (param: CAMU_PackageParameterContext) -> Result #foreign libctru;

/**
* @brief Configures a camera with pre-packaged configuration data without a context and extra resolution details.
* @param Parameter to use.
*/
CAMU_SetPackageParameterWithContextDetail :: (param: CAMU_PackageParameterContextDetail) -> Result #foreign libctru;

/**
* @brief Gets the Y2R coefficient applied to image data by the camera.
* @param coefficient Pointer to output the Y2R coefficient to.
*/
CAMU_GetSuitableY2rStandardCoefficient :: (coefficient: *Y2RU_StandardCoefficient) -> Result #foreign libctru;

/**
* @brief Plays the specified shutter sound.
* @param sound Shutter sound to play.
*/
CAMU_PlayShutterSound :: (sound: CAMU_ShutterSoundType) -> Result #foreign libctru;

/// Initializes the camera driver.
CAMU_DriverInitialize :: () -> Result #foreign libctru;

/// Finalizes the camera driver.
CAMU_DriverFinalize :: () -> Result #foreign libctru;

/**
* @brief Gets the current activated camera.
* @param select Pointer to output the current activated camera to.
*/
CAMU_GetActivatedCamera :: (select: *u32) -> Result #foreign libctru;

/**
* @brief Gets the current sleep camera.
* @param select Pointer to output the current sleep camera to.
*/
CAMU_GetSleepCamera :: (select: *u32) -> Result #foreign libctru;

/**
* @brief Sets the current sleep camera.
* @param select Camera to set.
*/
CAMU_SetSleepCamera :: (select: u32) -> Result #foreign libctru;

/**
* @brief Sets whether to enable synchronization of left and right camera brightnesses.
* @param brightnessSynchronization Whether to enable brightness synchronization.
*/
CAMU_SetBrightnessSynchronization :: (brightnessSynchronization: bool) -> Result #foreign libctru;

/**
* @brief Initializes CFGNOR.
* @param value Unknown, usually 1.
*/
cfgnorInit :: (value: u8) -> Result #foreign libctru;

/// Exits CFGNOR
cfgnorExit :: () -> void #foreign libctru;

/**
* @brief Dumps the NOR flash.
* @param buf Buffer to dump to.
* @param size Size of the buffer.
*/
cfgnorDumpFlash :: (buf: *u32, size: u32) -> Result #foreign libctru;

/**
* @brief Writes the NOR flash.
* @param buf Buffer to write from.
* @param size Size of the buffer.
*/
cfgnorWriteFlash :: (buf: *u32, size: u32) -> Result #foreign libctru;

/**
* @brief Initializes the CFGNOR session.
* @param value Unknown, usually 1.
*/
CFGNOR_Initialize :: (value: u8) -> Result #foreign libctru;

/// Shuts down the CFGNOR session.
CFGNOR_Shutdown :: () -> Result #foreign libctru;

/**
* @brief Reads data from NOR.
* @param offset Offset to read from.
* @param buf Buffer to read data to.
* @param size Size of the buffer.
*/
CFGNOR_ReadData :: (offset: u32, buf: *u32, size: u32) -> Result #foreign libctru;

/**
* @brief Writes data to NOR.
* @param offset Offset to write to.
* @param buf Buffer to write data from.
* @param size Size of the buffer.
*/
CFGNOR_WriteData :: (offset: u32, buf: *u32, size: u32) -> Result #foreign libctru;

/// Configuration region values.
CFG_Region :: enum u8 {
    JPN :: 0;
    USA :: 1;
    EUR :: 2;
    AUS :: 3;
    CHN :: 4;
    KOR :: 5;
    TWN :: 6;
}

/// Configuration language values.
CFG_Language :: enum u8 {
    JP :: 0;
    EN :: 1;
    FR :: 2;
    DE :: 3;
    IT :: 4;
    ES :: 5;
    ZH :: 6;
    KO :: 7;
    NL :: 8;
    PT :: 9;
    RU :: 10;
    TW :: 11;
}

// Configuration system model values.
CFG_SystemModel :: enum u8 {
    _3DS   :: 0;
    _3DSXL :: 1;
    N3DS   :: 2;
    _2DS   :: 3;
    N3DSXL :: 4;
    N2DSXL :: 5;
}

/// Initializes CFGU.
cfguInit :: () -> Result #foreign libctru;

/// Exits CFGU.
cfguExit :: () -> void #foreign libctru;

/**
* @brief Gets the system's region from secure info.
* @param region Pointer to output the region to. (see @ref CFG_Region)
*/
CFGU_SecureInfoGetRegion :: (region: *u8) -> Result #foreign libctru;

/**
* @brief Generates a console-unique hash.
* @param appIDSalt Salt to use.
* @param hash Pointer to output the hash to.
*/
CFGU_GenHashConsoleUnique :: (appIDSalt: u32, hash: *u64) -> Result #foreign libctru;

/**
* @brief Gets whether the system's region is Canada or USA.
* @param value Pointer to output the result to. (0 = no, 1 = yes)
*/
CFGU_GetRegionCanadaUSA :: (value: *u8) -> Result #foreign libctru;

/**
* @brief Gets the system's model.
* @param model Pointer to output the model to. (see @ref CFG_SystemModel)
*/
CFGU_GetSystemModel :: (model: *u8) -> Result #foreign libctru;

/**
* @brief Gets whether the system is a 2DS.
* @param value Pointer to output the result to. (0 = yes, 1 = no)
*/
CFGU_GetModelNintendo2DS :: (value: *u8) -> Result #foreign libctru;

/**
* @brief Gets a string representing a country code.
* @param code Country code to use.
* @param string Pointer to output the string to.
*/
CFGU_GetCountryCodeString :: (code: u16, _string: *u16) -> Result #foreign libctru;

/**
* @brief Gets a country code ID from its string.
* @param string String to use.
* @param code Pointer to output the country code to.
*/
CFGU_GetCountryCodeID :: (_string: u16, code: *u16) -> Result #foreign libctru;

/**
* @brief Checks if NFC (code name: fangate) is supported.
* @param isSupported pointer to the output the result to.
*/
CFGU_IsNFCSupported :: (isSupported: *bool) -> Result #foreign libctru;

/**
* @brief Gets a config info block with flags = 2.
* @param size Size of the data to retrieve.
* @param blkID ID of the block to retrieve.
* @param outData Pointer to write the block data to.
*/
CFGU_GetConfigInfoBlk2 :: (size: u32, blkID: u32, outData: *void) -> Result #foreign libctru;

/**
* @brief Gets a config info block with flags = 4.
* @param size Size of the data to retrieve.
* @param blkID ID of the block to retrieve.
* @param outData Pointer to write the block data to.
*/
CFG_GetConfigInfoBlk4 :: (size: u32, blkID: u32, outData: *void) -> Result #foreign libctru;

/**
* @brief Gets a config info block with flags = 8.
* @param size Size of the data to retrieve.
* @param blkID ID of the block to retrieve.
* @param outData Pointer to write the block data to.
*/
CFG_GetConfigInfoBlk8 :: (size: u32, blkID: u32, outData: *void) -> Result #foreign libctru;

/**
* @brief Sets a config info block with flags = 4.
* @param size Size of the data to retrieve.
* @param blkID ID of the block to retrieve.
* @param inData Pointer to block data to write.
*/
CFG_SetConfigInfoBlk4 :: (size: u32, blkID: u32, inData: *void) -> Result #foreign libctru;

/**
* @brief Sets a config info block with flags = 8.
* @param size Size of the data to retrieve.
* @param blkID ID of the block to retrieve.
* @param inData Pointer to block data to write.
*/
CFG_SetConfigInfoBlk8 :: (size: u32, blkID: u32, inData: *void) -> Result #foreign libctru;

/**
* @brief Writes the CFG buffer in memory to the savegame in NAND.
*/
CFG_UpdateConfigSavegame :: () -> Result #foreign libctru;

/**
* @brief Gets the system's language.
* @param language Pointer to write the language to. (see @ref CFG_Language)
*/
CFGU_GetSystemLanguage :: (language: *u8) -> Result #foreign libctru;

/**
* @brief Deletes the NAND LocalFriendCodeSeed file, then recreates it using the LocalFriendCodeSeed data stored in memory.
*/
CFGI_RestoreLocalFriendCodeSeed :: () -> Result #foreign libctru;

/**
* @brief Deletes the NAND SecureInfo file, then recreates it using the SecureInfo data stored in memory.
*/
CFGI_RestoreSecureInfo :: () -> Result #foreign libctru;

/**
* @brief Deletes the "config" file stored in the NAND Config_Savegame.
*/
CFGI_DeleteConfigSavefile :: () -> Result #foreign libctru;

/**
* @brief Formats Config_Savegame.
*/
CFGI_FormatConfig :: () -> Result #foreign libctru;

/**
* @brief Clears parental controls
*/
CFGI_ClearParentalControls :: () -> Result #foreign libctru;

/**
* @brief Verifies the RSA signature for the LocalFriendCodeSeed data already stored in memory.
*/
CFGI_VerifySigLocalFriendCodeSeed :: () -> Result #foreign libctru;

/**
* @brief Verifies the RSA signature for the SecureInfo data already stored in memory.
*/
CFGI_VerifySigSecureInfo :: () -> Result #foreign libctru;

/**
* @brief Gets the system's serial number.
* @param serial Pointer to output the serial to. (This is normally 0xF)
*/
CFGI_SecureInfoGetSerialNumber :: (serial: *u8) -> Result #foreign libctru;

/**
* @brief Gets the 0x110-byte buffer containing the data for the LocalFriendCodeSeed.
* @param data Pointer to output the buffer. (The size must be at least 0x110-bytes)
*/
CFGI_GetLocalFriendCodeSeedData :: (data: *u8) -> Result #foreign libctru;

/**
* @brief Gets the 64-bit local friend code seed.
* @param seed Pointer to write the friend code seed to.
*/
CFGI_GetLocalFriendCodeSeed :: (seed: *u64) -> Result #foreign libctru;

/**
* @brief Gets the 0x11-byte data following the SecureInfo signature.
* @param data Pointer to output the buffer. (The size must be at least 0x11-bytes)
*/
CFGI_GetSecureInfoData :: (data: *u8) -> Result #foreign libctru;

/**
* @brief Gets the 0x100-byte RSA-2048 SecureInfo signature.
* @param data Pointer to output the buffer. (The size must be at least 0x100-bytes)
*/
CFGI_GetSecureInfoSignature :: (data: *u8) -> Result #foreign libctru;

/// CSND encodings.
CSND_ENCODING :: enum u8 {
    PCM8  :: 0;
    PCM16 :: 1;
    ADPCM :: 2;
    PSG   :: 3;
}

/// CSND loop modes.
CSND_LOOPMODE :: enum u8 {
    MANUAL   :: 0;
    NORMAL   :: 1;
    ONESHOT  :: 2;
    NORELOAD :: 3;
}

/// Sound flags.
SOUND :: enum u16 {
    LINEAR_INTERP :: 64;
    REPEAT        :: 1024;
    ONE_SHOT      :: 2048;
    FORMAT_8BIT   :: 0;
    FORMAT_16BIT  :: 4096;
    FORMAT_ADPCM  :: 8192;
    FORMAT_PSG    :: 12288;
    ENABLE        :: 16384;
}

/// Capture modes.
CAPTURE :: enum u16 {
    REPEAT       :: 0;
    ONE_SHOT     :: 1;
    FORMAT_16BIT :: 0;
    FORMAT_8BIT  :: 2;
    ENABLE       :: 32768;
}

/// Duty cycles for a PSG channel.
CSND_DutyCycle :: enum u8 {
    _0  :: 7;
    _12 :: 0;
    _25 :: 1;
    _37 :: 2;
    _50 :: 3;
    _62 :: 4;
    _75 :: 5;
    _87 :: 6;
}

/// Channel info.
CSND_ChnInfo :: union {
    value: [3] u32; ///< Raw values.
    struct {
        active:      u8; ///< Channel active.
        _pad1:       u8; ///< Padding.
        _pad2:       u16; ///< Padding.
        adpcmSample: s16; ///< Current ADPCM sample.
        adpcmIndex:  u8; ///< Current ADPCM index.
        _pad3:       u8; ///< Padding.
        unknownZero: u32; ///< Unknown.
    }
}

/// Capture info.
CSND_CapInfo :: union {
    value: [2] u32; ///< Raw values.
    struct {
        active:      u8; ///< Capture active.
        _pad1:       u8; ///< Padding.
        _pad2:       u16; ///< Padding.
        unknownZero: u32; ///< Unknown.
    }
}

/**
* @brief Acquires a capture unit.
* @param capUnit Pointer to output the capture unit to.
*/
CSND_AcquireCapUnit :: (capUnit: *u32) -> Result #foreign libctru;

/**
* @brief Releases a capture unit.
* @param capUnit Capture unit to release.
*/
CSND_ReleaseCapUnit :: (capUnit: u32) -> Result #foreign libctru;

/**
* @brief Flushes the data cache of a memory region.
* @param adr Address of the memory region.
* @param size Size of the memory region.
*/
CSND_FlushDataCache :: (adr: *void, size: u32) -> Result #foreign libctru;

/**
* @brief Stores the data cache of a memory region.
* @param adr Address of the memory region.
* @param size Size of the memory region.
*/
CSND_StoreDataCache :: (adr: *void, size: u32) -> Result #foreign libctru;

/**
* @brief Invalidates the data cache of a memory region.
* @param adr Address of the memory region.
* @param size Size of the memory region.
*/
CSND_InvalidateDataCache :: (adr: *void, size: u32) -> Result #foreign libctru;

/**
* @brief Resets CSND.
* Note: Currently breaks sound, don't use for now!
*/
CSND_Reset :: () -> Result #foreign libctru;

/// Initializes CSND.
csndInit :: () -> Result #foreign libctru;

/// Exits CSND.
csndExit :: () -> void #foreign libctru;

/**
* @brief Adds a command to the list, returning a buffer to write arguments to.
* @param cmdid ID of the command to add.
* @return A buffer to write command arguments to.
*/
csndAddCmd :: (cmdid: s32) -> *u32 #foreign libctru;

/**
* @brief Adds a command to the list, copying its arguments from a buffer.
* @param cmdid ID of the command to add.
* @param cmdparams Buffer containing the command's parameters.
*/
csndWriteCmd :: (cmdid: s32, cmdparams: *u8) -> void #foreign libctru;

/**
* @brief Executes pending CSND commands.
* @param waitDone Whether to wait until the commands have finished executing.
*/
csndExecCmds :: (waitDone: bool) -> Result #foreign libctru;

/**
* @brief Sets a channel's play state, resetting registers on stop.
* @param channel Channel to use.
* @param value Play state to set.
*/
CSND_SetPlayStateR :: (channel: u32, value: u32) -> void #foreign libctru;

/**
* @brief Sets a channel's play state.
* @param channel Channel to use.
* @param value Play state to set.
*/
CSND_SetPlayState :: (channel: u32, value: u32) -> void #foreign libctru;

/**
* @brief Sets a channel's encoding.
* @param channel Channel to use.
* @param value Encoding to set.
*/
CSND_SetEncoding :: (channel: u32, value: u32) -> void #foreign libctru;

/**
* @brief Sets the data of a channel's block.
* @param channel Channel to use.
* @param block Block to set.
* @param physaddr Physical address to set the block to.
* @param size Size of the block.
*/
CSND_SetBlock :: (channel: u32, block: s32, physaddr: u32, size: u32) -> void #foreign libctru;

/**
* @brief Sets whether to loop a channel.
* @param channel Channel to use.
* @param value Whether to loop the channel.
*/
CSND_SetLooping :: (channel: u32, value: u32) -> void #foreign libctru;

/**
* @brief Sets bit 7 of a channel.
* @param channel Channel to use.
* @param set Value to set.
*/
CSND_SetBit7 :: (channel: u32, set: bool) -> void #foreign libctru;

/**
* @brief Sets whether a channel should use interpolation.
* @param channel Channel to use.
* @param interp Whether to use interpolation.
*/
CSND_SetInterp :: (channel: u32, interp: bool) -> void #foreign libctru;

/**
* @brief Sets a channel's duty.
* @param channel Channel to use.
* @param duty Duty to set.
*/
CSND_SetDuty :: (channel: u32, duty: CSND_DutyCycle) -> void #foreign libctru;

/**
* @brief Sets a channel's timer.
* @param channel Channel to use.
* @param timer Timer to set.
*/
CSND_SetTimer :: (channel: u32, timer: u32) -> void #foreign libctru;

/**
* @brief Sets a channel's volume.
* @param channel Channel to use.
* @param chnVolumes Channel volume data to set.
* @param capVolumes Capture volume data to set.
*/
CSND_SetVol :: (channel: u32, chnVolumes: u32, capVolumes: u32) -> void #foreign libctru;

/**
* @brief Sets a channel's ADPCM state.
* @param channel Channel to use.
* @param block Current block.
* @param sample Current sample.
* @param index Current index.
*/
CSND_SetAdpcmState :: (channel: u32, block: s32, sample: s32, index: s32) -> void #foreign libctru;

/**
* @brief Sets a whether channel's ADPCM data should be reloaded when the second block is played.
* @param channel Channel to use.
* @param reload Whether to reload ADPCM data.
*/
CSND_SetAdpcmReload :: (channel: u32, reload: bool) -> void #foreign libctru;

/**
* @brief Sets CSND's channel registers.
* @param flags Flags to set.
* @param physaddr0 Physical address of the first buffer to play.
* @param physaddr1 Physical address of the second buffer to play.
* @param totalbytesize Total size of the data to play.
* @param chnVolumes Channel volume data.
* @param capVolumes Capture volume data.
*/
CSND_SetChnRegs :: (flags: u32, physaddr0: u32, physaddr1: u32, totalbytesize: u32, chnVolumes: u32, capVolumes: u32) -> void #foreign libctru;

/**
* @brief Sets CSND's PSG channel registers.
* @param flags Flags to set.
* @param chnVolumes Channel volume data.
* @param capVolumes Capture volume data.
* @param duty Duty value to set.
*/
CSND_SetChnRegsPSG :: (flags: u32, chnVolumes: u32, capVolumes: u32, duty: CSND_DutyCycle) -> void #foreign libctru;

/**
* @brief Sets CSND's noise channel registers.
* @param flags Flags to set.
* @param chnVolumes Channel volume data.
* @param capVolumes Capture volume data.
*/
CSND_SetChnRegsNoise :: (flags: u32, chnVolumes: u32, capVolumes: u32) -> void #foreign libctru;

/**
* @brief Sets whether a capture unit is enabled.
* @param capUnit Capture unit to use.
* @param enable Whether to enable the capture unit.
*/
CSND_CapEnable :: (capUnit: u32, enable: bool) -> void #foreign libctru;

/**
* @brief Sets whether a capture unit should repeat.
* @param capUnit Capture unit to use.
* @param repeat Whether the capture unit should repeat.
*/
CSND_CapSetRepeat :: (capUnit: u32, repeat: bool) -> void #foreign libctru;

/**
* @brief Sets a capture unit's format.
* @param capUnit Capture unit to use.
* @param eightbit Format to use.
*/
CSND_CapSetFormat :: (capUnit: u32, eightbit: bool) -> void #foreign libctru;

/**
* @brief Sets a capture unit's second bit.
* @param capUnit Capture unit to use.
* @param set Value to set.
*/
CSND_CapSetBit2 :: (capUnit: u32, set: bool) -> void #foreign libctru;

/**
* @brief Sets a capture unit's timer.
* @param capUnit Capture unit to use.
* @param timer Timer to set.
*/
CSND_CapSetTimer :: (capUnit: u32, timer: u32) -> void #foreign libctru;

/**
* @brief Sets a capture unit's buffer.
* @param capUnit Capture unit to use.
* @param addr Buffer address to use.
* @param size Size of the buffer.
*/
CSND_CapSetBuffer :: (capUnit: u32, addr: u32, size: u32) -> void #foreign libctru;

/**
* @brief Sets a capture unit's capture registers.
* @param capUnit Capture unit to use.
* @param flags Capture unit flags.
* @param addr Capture unit buffer address.
* @param size Buffer size.
*/
CSND_SetCapRegs :: (capUnit: u32, flags: u32, addr: u32, size: u32) -> void #foreign libctru;

/**
* @brief Sets up DSP flags.
* @param waitDone Whether to wait for completion.
*/
CSND_SetDspFlags :: (waitDone: bool) -> Result #foreign libctru;

/**
* @brief Updates CSND information.
* @param waitDone Whether to wait for completion.
*/
CSND_UpdateInfo :: (waitDone: bool) -> Result #foreign libctru;

/**
* @brief Plays a sound.
* @param chn Channel to play the sound on.
* @param flags Flags containing information about the sound.
* @param sampleRate Sample rate of the sound.
* @param vol The volume, ranges from 0.0 to 1.0 included.
* @param pan The pan, ranges from -1.0 to 1.0 included.
* @param data0 First block of sound data.
* @param data1 Second block of sound data. This is the block that will be looped over.
* @param size Size of the sound data.
*
* In this implementation if the loop mode is used, data1 must be in the range [data0 ; data0 + size]. Sound will be played once from data0 to data0 + size and then loop between data1 and data0+size.
*/
csndPlaySound :: (chn: s32, flags: u32, sampleRate: u32, vol: float, pan: float, data0: *void, data1: *void, size: u32) -> Result #foreign libctru;

/**
* @brief Gets CSND's DSP flags.
* Note: Requires previous CSND_UpdateInfo()
* @param outSemFlags Pointer to write semaphore flags to.
* @param outIrqFlags Pointer to write interrupt flags to.
*/
csndGetDspFlags :: (outSemFlags: *u32, outIrqFlags: *u32) -> void #foreign libctru;

/**
* @brief Gets a channel's information.
* Note: Requires previous CSND_UpdateInfo()
* @param channel Channel to get information for.
* @return The channel's information.
*/
csndGetChnInfo :: (channel: u32) -> *CSND_ChnInfo #foreign libctru;

/**
* @brief Gets a capture unit's information.
* Note: Requires previous CSND_UpdateInfo()
* @param capUnit Capture unit to get information for.
* @return The capture unit's information.
*/
csndGetCapInfo :: (capUnit: u32) -> *CSND_CapInfo #foreign libctru;

/**
* @brief Gets a channel's state.
* @param channel Channel to get the state of.
* @param out Pointer to output channel information to.
*/
csndGetState :: (channel: u32, out: *CSND_ChnInfo) -> Result #foreign libctru;

/**
* @brief Gets whether a channel is playing.
* @param channel Channel to check.
* @param status Pointer to output the channel status to.
*/
csndIsPlaying :: (channel: u32, status: *u8) -> Result #foreign libctru;

/// DSP interrupt types.
DSP_InterruptType :: enum u8 {
    DSP_INTERRUPT_PIPE :: 2;
}

/// DSP hook types.
DSP_HookType :: enum u8 {
    SLEEP  :: 0;
    WAKEUP :: 1;
    CANCEL :: 2;
}

/// DSP hook function.
dspHookFn :: #type (hook: DSP_HookType) -> void #c_call;

/// DSP hook cookie.
tag_dspHookCookie :: struct {
    next:     *tag_dspHookCookie; ///< Next cookie.
    callback: dspHookFn #align 4; ///< Hook callback.
}

/// DSP hook cookie.
dspHookCookie :: tag_dspHookCookie;

/**
* @brief Initializes the dsp service.
*
* Call this before calling any DSP_* function.
* @note This will also unload any previously loaded DSP binary.
*       It is done this way since you have to provide your binary when the 3DS leaves sleep mode anyway.
*/
dspInit :: () -> Result #foreign libctru;

/**
* @brief Closes the dsp service.
* @note This will also unload the DSP binary.
*/
dspExit :: () -> void #foreign libctru;

/// Returns true if a component is loaded, false otherwise.
dspIsComponentLoaded :: () -> bool #foreign libctru;

/**
* @brief Sets up a DSP status hook.
* @param cookie Hook cookie to use.
* @param callback Function to call when DSP's status changes.
*/
dspHook :: (cookie: *dspHookCookie, callback: dspHookFn) -> void #foreign libctru;

/**
* @brief Removes a DSP status hook.
* @param cookie Hook cookie to remove.
*/
dspUnhook :: (cookie: *dspHookCookie) -> void #foreign libctru;

/**
* @brief Checks if a headphone is inserted.
* @param is_inserted Pointer to output the insertion status to.
*/
DSP_GetHeadphoneStatus :: (is_inserted: *bool) -> Result #foreign libctru;

/**
* @brief Flushes the cache
* @param address   Beginning of the memory range to flush, inside the Linear or DSP memory regions
* @param size      Size of the memory range to flush
*
* Flushes the cache for the specified memory range and invalidates the cache
*/
DSP_FlushDataCache :: (address: *void, size: u32) -> Result #foreign libctru;

/**
* @brief Invalidates the cache
* @param address   Beginning of the memory range to invalidate, inside the Linear or DSP memory regions
* @param size      Size of the memory range to flush
*
* Invalidates the cache for the specified memory range
*/
DSP_InvalidateDataCache :: (address: *void, size: u32) -> Result #foreign libctru;

/**
* @brief Retrieves the handle of the DSP semaphore.
* @param semaphore Pointer to output the semaphore to.
*/
DSP_GetSemaphoreHandle :: (semaphore: *Handle) -> Result #foreign libctru;

/**
* @brief Sets the DSP hardware semaphore value.
* @param value Value to set.
*/
DSP_SetSemaphore :: (value: u16) -> Result #foreign libctru;

/**
* @brief Masks the DSP hardware semaphore value.
* @param mask Mask to apply.
*/
DSP_SetSemaphoreMask :: (mask: u16) -> Result #foreign libctru;

/**
* @brief Loads a DSP binary and starts the DSP
* @param component The program file address in memory
* @param size      The size of the program
* @param prog_mask DSP memory block related ? Default is 0xff.
* @param data_mask DSP memory block related ? Default is 0xff.
* @param is_loaded Indicates if the DSP was succesfully loaded.
*
* @note The binary must be signed (http://3dbrew.org/wiki/DSP_Binary)
* @note Seems to be called when the 3ds leaves the Sleep mode
*/
DSP_LoadComponent :: (component: *void, size: u32, prog_mask: u16, data_mask: u16, is_loaded: *bool) -> Result #foreign libctru;

///Stops the DSP by unloading the binary.
DSP_UnloadComponent :: () -> Result #foreign libctru;

/**
* @brief Registers an event handle with the DSP through IPC
* @param handle Event handle to register.
* @param interrupt The type of interrupt that will trigger the event. Usual value is DSP_INTERRUPT_PIPE.
* @param channel The pipe channel. Usual value is 2
*
* @note It is possible that interrupt are inverted
*/
DSP_RegisterInterruptEvents :: (handle: Handle, interrupt: u32, channel: u32) -> Result #foreign libctru;

/**
* @brief Reads a pipe if possible.
* @param channel     unknown. Usually 2
* @param peer        unknown. Usually 0
* @param buffer      The buffer that will store the values read from the pipe
* @param length      Length of the buffer
* @param length_read Number of bytes read by the command
*/
DSP_ReadPipeIfPossible :: (channel: u32, peer: u32, buffer: *void, length: u16, length_read: *u16) -> Result #foreign libctru;

/**
* @brief Writes to a pipe.
* @param channel unknown. Usually 2
* @param buffer  The message to send to the DSP process
* @param length  Length of the message
*/
DSP_WriteProcessPipe :: (channel: u32, buffer: *void, length: u32) -> Result #foreign libctru;

/**
* @brief Converts a DSP memory address to a virtual address usable by the process.
* @param dsp_address Address to convert.
* @param arm_address Pointer to output the converted address to.
*/
DSP_ConvertProcessAddressFromDspDram :: (dsp_address: u32, arm_address: *u32) -> Result #foreign libctru;

/**
* @brief Reads a DSP register
* @param regNo Offset of the hardware register, base address is 0x1EC40000
* @param value Pointer to read the register value to.
*/
DSP_RecvData :: (regNo: u16, value: *u16) -> Result #foreign libctru;

/**
* @brief Checks if you can read a DSP register
* @param regNo Offset of the hardware register, base address is 0x1EC40000
* @param is_ready Pointer to write the ready status to.
*
* @warning This call might hang if the data is not ready. See @ref DSP_SendDataIsEmpty.
*/
DSP_RecvDataIsReady :: (regNo: u16, is_ready: *bool) -> Result #foreign libctru;

/**
* @brief Writes to a DSP register
* @param regNo Offset of the hardware register, base address is 0x1EC40000
* @param value Value to write.
*
* @warning This call might hang if the SendData is not empty. See @ref DSP_SendDataIsEmpty.
*/
DSP_SendData :: (regNo: u16, value: u16) -> Result #foreign libctru;

/**
* @brief Checks if you can write to a DSP register ?
* @param regNo Offset of the hardware register, base address is 0x1EC40000
* @param is_empty Pointer to write the empty status to.
*/
DSP_SendDataIsEmpty :: (regNo: u16, is_empty: *bool) -> Result #foreign libctru;

FSPXI_Archive :: u64;
FSPXI_File :: u64;
FSPXI_Directory :: u64;

/**
* @brief Opens a file.
* @param out Pointer to output the file handle to.
* @param archive Archive containing the file.
* @param path Path of the file.
* @param flags Flags to open the file with.
* @param attributes Attributes of the file.
*/
FSPXI_OpenFile :: (serviceHandle: Handle, out: *FSPXI_File, archive: FSPXI_Archive, path: FS_Path, flags: u32, attributes: u32) -> Result #foreign libctru;

/**
* @brief Deletes a file.
* @param archive Archive containing the file.
* @param path Path of the file.
*/
FSPXI_DeleteFile :: (serviceHandle: Handle, archive: FSPXI_Archive, path: FS_Path) -> Result #foreign libctru;

/**
* @brief Renames a file.
* @param srcArchive Archive containing the source file.
* @param srcPath Path of the source file.
* @param dstArchive Archive containing the destination file.
* @param dstPath Path of the destination file.
*/
FSPXI_RenameFile :: (serviceHandle: Handle, srcArchive: FSPXI_Archive, srcPath: FS_Path, dstArchive: FSPXI_Archive, dstPath: FS_Path) -> Result #foreign libctru;

/**
* @brief Deletes a directory.
* @param archive Archive containing the directory.
* @param path Path of the directory.
*/
FSPXI_DeleteDirectory :: (serviceHandle: Handle, archive: FSPXI_Archive, path: FS_Path) -> Result #foreign libctru;

/**
* @brief Creates a file.
* @param archive Archive to create the file in.
* @param path Path of the file.
* @param attributes Attributes of the file.
* @param size Size of the file.
*/
FSPXI_CreateFile :: (serviceHandle: Handle, archive: FSPXI_Archive, path: FS_Path, attributes: u32, fileSize: u64) -> Result #foreign libctru;

/**
* @brief Creates a directory.
* @param archive Archive to create the directory in.
* @param path Path of the directory.
* @param attributes Attributes of the directory.
*/
FSPXI_CreateDirectory :: (serviceHandle: Handle, archive: FSPXI_Archive, path: FS_Path, attributes: u32) -> Result #foreign libctru;

/**
* @brief Renames a directory.
* @param srcArchive Archive containing the source directory.
* @param srcPath Path of the source directory.
* @param dstArchive Archive containing the destination directory.
* @param dstPath Path of the destination directory.
*/
FSPXI_RenameDirectory :: (serviceHandle: Handle, srcArchive: FSPXI_Archive, srcPath: FS_Path, dstArchive: FSPXI_Archive, dstPath: FS_Path) -> Result #foreign libctru;

/**
* @brief Opens a directory.
* @param out Pointer to output the directory handle to.
* @param archive Archive containing the directory.
* @param path Path of the directory.
*/
FSPXI_OpenDirectory :: (serviceHandle: Handle, out: *FSPXI_Directory, archive: FSPXI_Archive, path: FS_Path) -> Result #foreign libctru;

/**
* @brief Reads from a file.
* @param file File to read from.
* @param bytesRead Pointer to output the number of read bytes to.
* @param offset Offset to read from.
* @param buffer Buffer to read to.
* @param size Size of the buffer.
*/
FSPXI_ReadFile :: (serviceHandle: Handle, file: FSPXI_File, bytesRead: *u32, offset: u64, buffer: *void, size: u32) -> Result #foreign libctru;

/**
* @brief Calculate SHA256 of a file.
* @param file File to calculate the hash of.
* @param buffer Buffer to output the hash to.
* @param size Size of the buffer.
*/
FSPXI_CalculateFileHashSHA256 :: (serviceHandle: Handle, file: FSPXI_File, buffer: *void, size: u32) -> Result #foreign libctru;

/**
* @brief Writes to a file.
* @param file File to write to.
* @param bytesWritten Pointer to output the number of bytes written to.
* @param offset Offset to write to.
* @param buffer Buffer to write from.
* @param size Size of the buffer.
* @param flags Flags to use when writing.
*/
FSPXI_WriteFile :: (serviceHandle: Handle, file: FSPXI_File, bytesWritten: *u32, offset: u64, buffer: *void, size: u32, flags: u32) -> Result #foreign libctru;

/**
* @brief Calculates the MAC used in a DISA/DIFF header?
* @param file Unsure
* @param inBuffer 0x100-byte DISA/DIFF input buffer.
* @param inSize Size of inBuffer.
* @param outBuffer Buffer to write MAC to.
* @param outSize Size of outBuffer.
*/
FSPXI_CalcSavegameMAC :: (serviceHandle: Handle, file: FSPXI_File, inBuffer: *void, inSize: u32, outBuffer: *void, outSize: u32) -> Result #foreign libctru;

/**
* @brief Get size of a file
* @param file File to get the size of.
* @param size Pointer to output size to.
*/
FSPXI_GetFileSize :: (serviceHandle: Handle, file: FSPXI_File, size: *u64) -> Result #foreign libctru;

/**
* @brief Set size of a file
* @param file File to set the size of
* @param size Size to set the file to
*/
FSPXI_SetFileSize :: (serviceHandle: Handle, file: FSPXI_File, size: u64) -> Result #foreign libctru;

/**
* @brief Close a file
* @param file File to close
*/
FSPXI_CloseFile :: (serviceHandle: Handle, file: FSPXI_File) -> Result #foreign libctru;

/**
* @brief Reads one or more directory entries.
* @param directory Directory to read from.
* @param entriesRead Pointer to output the number of entries read to.
* @param entryCount Number of entries to read.
* @param entryOut Pointer to output directory entries to.
*/
FSPXI_ReadDirectory :: (serviceHandle: Handle, directory: FSPXI_Directory, entriesRead: *u32, entryCount: u32, entries: *FS_DirectoryEntry) -> Result #foreign libctru;

/**
* @brief Close a directory
* @param directory Directory to close.
*/
FSPXI_CloseDirectory :: (serviceHandle: Handle, directory: FSPXI_Directory) -> Result #foreign libctru;

/**
* @brief Opens an archive.
* @param archive Pointer to output the opened archive to.
* @param id ID of the archive.
* @param path Path of the archive.
*/
FSPXI_OpenArchive :: (serviceHandle: Handle, archive: *FSPXI_Archive, archiveID: FS_ArchiveID, path: FS_Path) -> Result #foreign libctru;

/**
* @brief Checks if the archive contains a file at path.
* @param archive Archive to check.
* @param out Pointer to output existence to.
* @param path Path to check for file
*/
FSPXI_HasFile :: (serviceHandle: Handle, archive: FSPXI_Archive, out: *bool, path: FS_Path) -> Result #foreign libctru;

/**
* @brief Checks if the archive contains a directory at path.
* @param archive Archive to check.
* @param out Pointer to output existence to.
* @param path Path to check for directory
*/
FSPXI_HasDirectory :: (serviceHandle: Handle, archive: FSPXI_Archive, out: *bool, path: FS_Path) -> Result #foreign libctru;

/**
* @brief Commits an archive's save data.
* @param archive Archive to commit.
* @param id Archive action sent by FSUSER_ControlArchive. Must not be 0 or 0x789D
* @remark Unsure why id is sent. This appears to be the default action for FSUSER_ControlArchive, with every action other than 0 and 0x789D being sent to this command.
*/
FSPXI_CommitSaveData :: (serviceHandle: Handle, archive: FSPXI_Archive, id: u32) -> Result #foreign libctru;

/**
* @brief Close an archive
* @param archive Archive to close.
*/
FSPXI_CloseArchive :: (serviceHandle: Handle, archive: FSPXI_Archive) -> Result #foreign libctru;

/**
* @brief Unknown 0x17. Appears to be an "is archive handle valid" command?
* @param archive Archive handle to check validity of.
* @param out Pointer to output validity to.
*/
FSPXI_Unknown0x17 :: (serviceHandle: Handle, archive: FSPXI_Archive, out: *bool) -> Result #foreign libctru;

/**
* @brief Gets the inserted card type.
* @param out Pointer to output the card type to.
*/
FSPXI_GetCardType :: (serviceHandle: Handle, out: *FS_CardType) -> Result #foreign libctru;

/**
* @brief Gets the SDMC archive resource information.
* @param out Pointer to output the archive resource information to.
*/
FSPXI_GetSdmcArchiveResource :: (serviceHandle: Handle, out: *FS_ArchiveResource) -> Result #foreign libctru;

/**
* @brief Gets the NAND archive resource information.
* @param out Pointer to output the archive resource information to.
*/
FSPXI_GetNandArchiveResource :: (serviceHandle: Handle, out: *FS_ArchiveResource) -> Result #foreign libctru;

/**
* @brief Gets the error code from the SDMC FatFS driver
* @param out Pointer to output the error code to
*/
FSPXI_GetSdmcFatFsError :: (serviceHandle: Handle, out: *u32) -> Result #foreign libctru;

/**
* @brief Gets whether PXIFS0 detects the SD
* @param out Pointer to output the detection status to
*/
FSPXI_IsSdmcDetected :: (serviceHandle: Handle, out: *bool) -> Result #foreign libctru;

/**
* @brief Gets whether PXIFS0 can write to the SD
* @param out Pointer to output the writable status to
*/
FSPXI_IsSdmcWritable :: (serviceHandle: Handle, out: *bool) -> Result #foreign libctru;

/**
* @brief Gets the SDMC CID
* @param out Buffer to output the CID to.
* @param size Size of buffer.
*/
FSPXI_GetSdmcCid :: (serviceHandle: Handle, out: *void, size: u32) -> Result #foreign libctru;

/**
* @brief Gets the NAND CID
* @param out Buffer to output the CID to.
* @param size Size of buffer.
*/
FSPXI_GetNandCid :: (serviceHandle: Handle, out: *void, size: u32) -> Result #foreign libctru;

/**
* @brief Gets the SDMC speed info
* @param out Buffer to output the speed info to.
*/
FSPXI_GetSdmcSpeedInfo :: (serviceHandle: Handle, out: *FS_SdMmcSpeedInfo) -> Result #foreign libctru;

/**
* @brief Gets the NAND speed info
* @param out Buffer to output the speed info to.
*/
FSPXI_GetNandSpeedInfo :: (serviceHandle: Handle, out: *FS_SdMmcSpeedInfo) -> Result #foreign libctru;

/**
* @brief Gets the SDMC log
* @param out Buffer to output the log to.
* @param size Size of buffer.
*/
FSPXI_GetSdmcLog :: (serviceHandle: Handle, out: *void, size: u32) -> Result #foreign libctru;

/**
* @brief Gets the NAND log
* @param out Buffer to output the log to.
* @param size Size of buffer.
*/
FSPXI_GetNandLog :: (serviceHandle: Handle, out: *void, size: u32) -> Result #foreign libctru;

/// Clears the SDMC log
FSPXI_ClearSdmcLog :: (serviceHandle: Handle) -> Result #foreign libctru;

/// Clears the NAND log
FSPXI_ClearNandLog :: (serviceHandle: Handle) -> Result #foreign libctru;

/**
* @brief Gets whether a card is inserted.
* @param inserted Pointer to output the insertion status to.
*/
FSPXI_CardSlotIsInserted :: (serviceHandle: Handle, inserted: *bool) -> Result #foreign libctru;

/**
* @brief Powers on the card slot.
* @param status Pointer to output the power status to.
*/
FSPXI_CardSlotPowerOn :: (serviceHandle: Handle, status: *bool) -> Result #foreign libctru;

/**
* @brief Powers off the card slot.
* @param status Pointer to output the power status to.
*/
FSPXI_CardSlotPowerOff :: (serviceHandle: Handle, status: *bool) -> Result #foreign libctru;

/**
* @brief Gets the card's power status.
* @param status Pointer to output the power status to.
*/
FSPXI_CardSlotGetCardIFPowerStatus :: (serviceHandle: Handle, status: *bool) -> Result #foreign libctru;

/**
* @brief Executes a CARDNOR direct command.
* @param commandId ID of the command.
*/
FSPXI_CardNorDirectCommand :: (serviceHandle: Handle, commandId: u8) -> Result #foreign libctru;

/**
* @brief Executes a CARDNOR direct command with an address.
* @param commandId ID of the command.
* @param address Address to provide.
*/
FSPXI_CardNorDirectCommandWithAddress :: (serviceHandle: Handle, commandId: u8, address: u32) -> Result #foreign libctru;

/**
* @brief Executes a CARDNOR direct read.
* @param commandId ID of the command.
* @param size Size of the output buffer.
* @param output Output buffer.
*/
FSPXI_CardNorDirectRead :: (serviceHandle: Handle, commandId: u8, size: u32, output: *void) -> Result #foreign libctru;

/**
* @brief Executes a CARDNOR direct read with an address.
* @param commandId ID of the command.
* @param address Address to provide.
* @param size Size of the output buffer.
* @param output Output buffer.
*/
FSPXI_CardNorDirectReadWithAddress :: (serviceHandle: Handle, commandId: u8, address: u32, size: u32, output: *void) -> Result #foreign libctru;

/**
* @brief Executes a CARDNOR direct write.
* @param commandId ID of the command.
* @param size Size of the input buffer.
* @param output Input buffer.
* @remark Stubbed in latest firmware, since ?.?.?
*/
FSPXI_CardNorDirectWrite :: (serviceHandle: Handle, commandId: u8, size: u32, input: *void) -> Result #foreign libctru;

/**
* @brief Executes a CARDNOR direct write with an address.
* @param commandId ID of the command.
* @param address Address to provide.
* @param size Size of the input buffer.
* @param input Input buffer.
*/
FSPXI_CardNorDirectWriteWithAddress :: (serviceHandle: Handle, commandId: u8, address: u32, size: u32, input: *void) -> Result #foreign libctru;

/**
* @brief Executes a CARDNOR 4xIO direct read.
* @param commandId ID of the command.
* @param address Address to provide.
* @param size Size of the output buffer.
* @param output Output buffer.
*/
FSPXI_CardNorDirectRead_4xIO :: (serviceHandle: Handle, commandId: u8, address: u32, size: u32, output: *void) -> Result #foreign libctru;

/**
* @brief Executes a CARDNOR direct CPU write without verify.
* @param address Address to provide.
* @param size Size of the input buffer.
* @param output Input buffer.
*/
FSPXI_CardNorDirectCpuWriteWithoutVerify :: (serviceHandle: Handle, address: u32, size: u32, input: *void) -> Result #foreign libctru;

/**
* @brief Executes a CARDNOR direct sector erase without verify.
* @param address Address to provide.
*/
FSPXI_CardNorDirectSectorEraseWithoutVerify :: (serviceHandle: Handle, address: u32) -> Result #foreign libctru;

/**
* @brief Gets an NCCH's product info
* @param info Pointer to output the product info to.
* @param archive Open NCCH content archive
*/
FSPXI_GetProductInfo :: (serviceHandle: Handle, info: *FS_ProductInfo, archive: FSPXI_Archive) -> Result #foreign libctru;

/**
* @brief Sets the CARDSPI baud rate.
* @param baudRate Baud rate to set.
*/
FSPXI_SetCardSpiBaudrate :: (serviceHandle: Handle, baudRate: FS_CardSpiBaudRate) -> Result #foreign libctru;

/**
* @brief Sets the CARDSPI bus mode.
* @param busMode Bus mode to set.
*/
FSPXI_SetCardSpiBusMode :: (serviceHandle: Handle, busMode: FS_CardSpiBusMode) -> Result #foreign libctru;

/**
* @brief Sends initialization info to ARM9
* @param unk FS sends *(0x1FF81086)
*/
FSPXI_SendInitializeInfoTo9 :: (serviceHandle: Handle, unk: u8) -> Result #foreign libctru;

/**
* @brief Creates ext save data.
* @param info Info of the save data.
*/
FSPXI_CreateExtSaveData :: (serviceHandle: Handle, info: FS_ExtSaveDataInfo) -> Result #foreign libctru;

/**
* @brief Deletes ext save data.
* @param info Info of the save data.
*/
FSPXI_DeleteExtSaveData :: (serviceHandle: Handle, info: FS_ExtSaveDataInfo) -> Result #foreign libctru;

/**
* @brief Enumerates ext save data.
* @param idsWritten Pointer to output the number of IDs written to.
* @param idsSize Size of the IDs buffer.
* @param mediaType Media type to enumerate over.
* @param idSize Size of each ID element.
* @param shared Whether to enumerate shared ext save data.
* @param ids Pointer to output IDs to.
*/
FSPXI_EnumerateExtSaveData :: (serviceHandle: Handle, idsWritten: *u32, idsSize: u32, mediaType: FS_MediaType, idSize: u32, shared: bool, ids: *u8) -> Result #foreign libctru;

/**
* @brief Gets a special content's index.
* @param index Pointer to output the index to.
* @param mediaType Media type of the special content.
* @param programId Program ID owning the special content.
* @param type Type of special content.
*/
FSPXI_GetSpecialContentIndex :: (serviceHandle: Handle, index: *u16, mediaType: FS_MediaType, programId: u64, type: FS_SpecialContentType) -> Result #foreign libctru;

/**
* @brief Gets the legacy ROM header of a program.
* @param mediaType Media type of the program.
* @param programId ID of the program.
* @param header Pointer to output the legacy ROM header to. (size = 0x3B4)
*/
FSPXI_GetLegacyRomHeader :: (serviceHandle: Handle, mediaType: FS_MediaType, programId: u64, header: *void) -> Result #foreign libctru;

/**
* @brief Gets the legacy banner data of a program.
* @param mediaType Media type of the program.
* @param programId ID of the program.
* @param banner Pointer to output the legacy banner data to. (size = 0x23C0)
* @param unk Unknown. Always 1?
*/
FSPXI_GetLegacyBannerData :: (serviceHandle: Handle, mediaType: FS_MediaType, programId: u64, banner: *void, unk: u8) -> Result #foreign libctru;

/**
* @brief Formats the CARDNOR device.
* @param unk Unknown. Transaction?
*/
FSPXI_FormatCardNorDevice :: (serviceHandle: Handle, unk: u32) -> Result #foreign libctru;

/// Deletes the 3DS SDMC root.
FSPXI_DeleteSdmcRoot :: (serviceHandle: Handle) -> Result #foreign libctru;

/// Deletes all ext save data on the NAND.
FSPXI_DeleteAllExtSaveDataOnNand :: (serviceHandle: Handle) -> Result #foreign libctru;

/// Initializes the CTR file system.
FSPXI_InitializeCtrFilesystem :: (serviceHandle: Handle) -> Result #foreign libctru;

/// Creates the FS seed.
FSPXI_CreateSeed :: (serviceHandle: Handle) -> Result #foreign libctru;

/**
* @brief Gets the CTR SDMC root path.
* @param out Pointer to output the root path to.
* @param length Length of the output buffer in bytes.
*/
FSPXI_GetSdmcCtrRootPath :: (serviceHandle: Handle, out: *u16, length: u32) -> Result #foreign libctru;

/**
* @brief Gets an archive's resource information.
* @param archiveResource Pointer to output the archive resource information to.
* @param mediaType System media type to check.
*/
FSPXI_GetArchiveResource :: (serviceHandle: Handle, archiveResource: *FS_ArchiveResource, mediaType: FS_SystemMediaType) -> Result #foreign libctru;

/**
* @brief Exports the integrity verification seed.
* @param seed Pointer to output the seed to.
*/
FSPXI_ExportIntegrityVerificationSeed :: (serviceHandle: Handle, seed: *FS_IntegrityVerificationSeed) -> Result #foreign libctru;

/**
* @brief Imports an integrity verification seed.
* @param seed Seed to import.
*/
FSPXI_ImportIntegrityVerificationSeed :: (serviceHandle: Handle, seed: *FS_IntegrityVerificationSeed) -> Result #foreign libctru;

/**
* @brief Gets the legacy sub banner data of a program.
* @param bannerSize Size of the banner.
* @param mediaType Media type of the program.
* @param programId ID of the program.
* @param header Pointer to output the legacy sub banner data to.
*/
FSPXI_GetLegacySubBannerData :: (serviceHandle: Handle, bannerSize: u32, mediaType: FS_MediaType, programId: u64, banner: *void) -> Result #foreign libctru;

/**
* @brief Generates random bytes. Uses same code as PSPXI_GenerateRandomBytes
* @param buf Buffer to output random bytes to.
* @param size Size of buffer.
*/
FSPXI_GenerateRandomBytes :: (serviceHandle: Handle, buffer: *void, size: u32) -> Result #foreign libctru;

/**
* @brief Gets the last modified time of a file in an archive.
* @param archive The archive that contains the file.
* @param out The pointer to write the timestamp to.
* @param path The UTF-16 path of the file.
* @param size The size of the path.
*/
FSPXI_GetFileLastModified :: (serviceHandle: Handle, archive: FSPXI_Archive, out: *u64, path: *u16, size: u32) -> Result #foreign libctru;

/**
* @brief Reads from a special file.
* @param bytesRead Pointer to output the number of bytes read to.
* @param fileOffset Offset of the file.
* @param size Size of the buffer.
* @param data Buffer to read to.
*/
FSPXI_ReadSpecialFile :: (serviceHandle: Handle, bytesRead: *u32, fileOffset: u64, size: u32, data: *void) -> Result #foreign libctru;

/**
* @brief Gets the size of a special file.
* @param fileSize Pointer to output the size to.
*/
FSPXI_GetSpecialFileSize :: (serviceHandle: Handle, fileSize: *u64) -> Result #foreign libctru;

/**
* @brief Initiates a device move as the source device.
* @param context Pointer to output the context to.
*/
FSPXI_StartDeviceMoveAsSource :: (serviceHandle: Handle, _context: *FS_DeviceMoveContext) -> Result #foreign libctru;

/**
* @brief Initiates a device move as the destination device.
* @param context Context to use.
* @param clear Whether to clear the device's data first.
*/
FSPXI_StartDeviceMoveAsDestination :: (serviceHandle: Handle, _context: FS_DeviceMoveContext, clear: bool) -> Result #foreign libctru;

/**
* @brief Reads data and stores SHA256 hashes of blocks
* @param file File to read from.
* @param bytesRead Pointer to output the number of read bytes to.
* @param offset Offset to read from.
* @param readBuffer Pointer to store read data in.
* @param readBufferSize Size of readBuffer.
* @param hashtable Pointer to store SHA256 hashes in.
* @param hashtableSize Size of hashtable.
* @param unk Unknown. Always 0x00001000? Possibly block size?
*/
FSPXI_ReadFileSHA256 :: (serviceHandle: Handle, file: FSPXI_File, bytesRead: *u32, offset: u64, readBuffer: *void, readBufferSize: u32, hashtable: *void, hashtableSize: u32, unk: u32) -> Result #foreign libctru;

/**
* @brief Assumedly writes data and stores SHA256 hashes of blocks
* @param file File to write to.
* @param bytesWritten Pointer to output the number of written bytes to.
* @param offset Offset to write to.
* @param writeBuffer Buffer to write from.
* @param writeBufferSize Size of writeBuffer.
* @param hashtable Pointer to store SHA256 hashes in.
* @param hashtableSize Size of hashtable
* @param unk1 Unknown. Might match with ReadFileSHA256's unknown?
* @param unk2 Unknown. Might match with ReadFileSHA256's unknown?
*/
FSPXI_WriteFileSHA256 :: (serviceHandle: Handle, file: FSPXI_File, bytesWritten: *u32, offset: u64, writeBuffer: *void, writeBufferSize: u32, hashtable: *void, hashtableSize: u32, unk1: u32, unk2: u32) -> Result #foreign libctru;

/**
* @brief Configures CTRCARD latency emulation.
* @param latency Latency to apply.
*/
FSPXI_SetCtrCardLatencyParameter :: (serviceHandle: Handle, latency: u64) -> Result #foreign libctru;

/**
* @brief Sets the file system priority.
* @param priority Priority to set.
*/
FSPXI_SetPriority :: (serviceHandle: Handle, priority: u32) -> Result #foreign libctru;

/**
* @brief Toggles cleaning up invalid save data.
* @param enable Whether to enable cleaning up invalid save data.
*/
FSPXI_SwitchCleanupInvalidSaveData :: (serviceHandle: Handle, enable: bool) -> Result #foreign libctru;

/**
* @brief Enumerates system save data.
* @param idsWritten Pointer to output the number of IDs written to.
* @param idsSize Size of the IDs buffer.
* @param ids Pointer to output IDs to.
*/
FSPXI_EnumerateSystemSaveData :: (serviceHandle: Handle, idsWritten: *u32, idsSize: u32, ids: *u32) -> Result #foreign libctru;

/**
* @brief Reads the NAND report.
* @param unk Unknown
* @param buffer Buffer to write the report to.
* @param size Size of buffer
*/
FSPXI_ReadNandReport :: (serviceHandle: Handle, buffer: *void, size: u32, unk: u32) -> Result #foreign libctru;

/**
* @brief Unknown command 0x56
* @remark Called by FSUSER_ControlArchive with ArchiveAction 0x789D
*/
FSPXI_Unknown0x56 :: (serviceHandle: Handle, out: *[4] u32, archive: FS_Archive, path: FS_Path) -> Result #foreign libctru;

/// Initializes fs:REG.
fsRegInit :: () -> Result #foreign libctru;

/// Exits fs:REG.
fsRegExit :: () -> void #foreign libctru;

/**
* @brief Gets the current fs:REG session handle.
* @return The current fs:REG session handle.
*/
fsRegGetSessionHandle :: () -> *Handle #foreign libctru;

/**
* @brief Registers a program's storage information.
* @param pid The Process ID of the program.
* @param programHandle The program handle.
* @param programInfo Information about the program.
* @param storageInfo Storage information to register.
*/
FSREG_Register :: (pid: u32, programHandle: u64, programInfo: *FS_ProgramInfo, storageInfo: *ExHeader_Arm11StorageInfo) -> Result #foreign libctru;

/**
* @brief Unregisters a program's storage information.
* @param pid The Process ID of the program.
*/
FSREG_Unregister :: (pid: u32) -> Result #foreign libctru;

/**
* @brief Retrives the exheader information set(s) (SCI+ACI) about a program.
* @param exheaderInfos[out] Pointer to the output exheader information set(s).
* @param maxNumEntries The maximum number of entries.
* @param programHandle The program handle.
*/
FSREG_GetProgramInfo :: (exheaderInfos: *ExHeader_Info, maxNumEntries: u32, programHandle: u64) -> Result #foreign libctru;

/**
* @brief Loads a program.
* @param programHandle[out] Pointer to the output the program handle to.
* @param programInfo Information about the program to load.
*/
FSREG_LoadProgram :: (programHandle: *u64, programInfo: *FS_ProgramInfo) -> Result #foreign libctru;

/**
* @brief Unloads a program.
* @param programHandle The program handle.
*/
FSREG_UnloadProgram :: (programHandle: u64) -> Result #foreign libctru;

/**
* @brief Checks if a program has been loaded by fs:REG.
* @param programHandle The program handle.
*/
FSREG_CheckHostLoadId :: (programHandle: u64) -> Result #foreign libctru;

/// Shared Mii struct
MiiData :: struct {
    magic:            u8; ///< Always 3?
    mii_options:      struct {
        allow_copying:   bool; ///< True if copying is allowed
        #place allow_copying; /*bitfield 1*/ is_private_name: bool; ///< Private name?
        region_lock:     u8; ///< Region lock (0=no lock, 1=JPN, 2=USA, 3=EUR)
        #place region_lock; /*bitfield 2*/ char_set:        u8; ///< Character set (0=JPN+USA+EUR, 1=CHN, 2=KOR, 3=TWN)
    };
    mii_pos:          struct {
        page_index: u8; ///< Page index of Mii
        #place page_index; /*bitfield 4*/ slot_index: u8; ///< Slot offset of Mii on its Page
    };
    console_identity: struct {
        unknown0:       u8; ///< Mabye padding (always seems to be 0)?
        #place unknown0; /*bitfield 4*/ origin_console: u8; ///< Console that the Mii was created on (1=WII, 2=DSI, 3=3DS)
    };
    system_id:        u64 #align 4; ///< Identifies the system that the Mii was created on (Determines pants)
    mii_id:           u32; ///< ID of Mii
    mac:              [6] u8; ///< Creator's system's full MAC address
    pad:              [2] u8; ///< Padding
    mii_details:      struct {
        sex:         bool; ///< Sex of Mii (False=Male, True=Female)
        bday_month:  u16; ///< Month of Mii's birthday
        #place bday_month; /*bitfield 4*/ bday_day:    u16; ///< Day of Mii's birthday
        #place bday_month; /*bitfield 9*/ shirt_color: u16; ///< Color of Mii's shirt
        favorite:    bool; ///< Whether the Mii is one of your 10 favorite Mii's
    };
    mii_name:         [10] u16; ///< Name of Mii (Encoded using UTF16)
    height:           u8; ///< How tall the Mii is
    width:            u8; ///< How wide the Mii is
    face_style:       struct {
        disable_sharing: bool; ///< Whether or not Sharing of the Mii is allowed
        shape:           u8; ///< Face shape
        #place shape; /*bitfield 4*/ skinColor:       u8; ///< Color of skin
    };
    face_details:     struct {
        wrinkles: u8;
        #place wrinkles; /*bitfield 4*/ makeup:   u8;
    };
    hair_style:       u8;
    hair_details:     struct {
        color: u8;
        flip:  bool;
    };
    eye_details:      struct {
        style:     u32;
        #place style; /*bitfield 6*/ color:     u32;
        #place style; /*bitfield 9*/ scale:     u32;
        #place style; /*bitfield 13*/ yscale:    u32;
        #place style; /*bitfield 16*/ rotation:  u32;
        #place style; /*bitfield 21*/ xspacing:  u32;
        #place style; /*bitfield 25*/ yposition: u32;
    };
    eyebrow_details:  struct {
        style:     u32;
        #place style; /*bitfield 5*/ color:     u32;
        #place style; /*bitfield 8*/ scale:     u32;
        #place style; /*bitfield 12*/ yscale:    u32;
        #place style; /*bitfield 15*/ pad:       u32;
        #place style; /*bitfield 16*/ rotation:  u32;
        #place style; /*bitfield 21*/ xspacing:  u32;
        #place style; /*bitfield 25*/ yposition: u32;
    };
    nose_details:     struct {
        style:     u16;
        #place style; /*bitfield 5*/ scale:     u16;
        #place style; /*bitfield 9*/ yposition: u16;
    };
    mouth_details:    struct {
        style:  u16;
        #place style; /*bitfield 6*/ color:  u16;
        #place style; /*bitfield 9*/ scale:  u16;
        #place style; /*bitfield 13*/ yscale: u16;
    };
    mustache_details: struct {
        mouth_yposition: u16;
        #place mouth_yposition; /*bitfield 5*/ mustach_style:   u16;
        #place mouth_yposition; /*bitfield 8*/ pad:             u16;
    };
    beard_details:    struct {
        style: u16;
        #place style; /*bitfield 3*/ color: u16;
        #place style; /*bitfield 6*/ scale: u16;
        #place style; /*bitfield 10*/ ypos:  u16;
    };
    glasses_details:  struct {
        style: u16;
        #place style; /*bitfield 4*/ color: u16;
        #place style; /*bitfield 7*/ scale: u16;
        #place style; /*bitfield 11*/ ypos:  u16;
    };
    mole_details:     struct {
        enable: bool;
        scale:  u16;
        #place scale; /*bitfield 5*/ xpos:   u16;
        #place scale; /*bitfield 10*/ ypos:   u16;
    };
    author_name:      [10] u16; ///< Name of Mii's author (Encoded using UTF16)
}

/// Friend key data
FriendKey :: struct {
    principalId:     u32;
    padding:         u32;
    localFriendCode: u64;
}

/// Friend Title data
TitleData :: struct {
    tid:     u64;
    version: u32;
    unk:     u32;
}

/// Friend profile data
FriendProfile :: struct {
    region:   u8; ///< The region code for the hardware.
    country:  u8; ///< Country code.
    area:     u8; ///< Area code.
    language: u8; ///< Language code.
    platform: u8; ///< Platform code.
    padding:  u32 #align 1;
}

/// Game Description structure
GameDescription :: struct {
    data: TitleData;
    desc: [128] u16;
}

/// Friend Notification Event structure
NotificationEvent :: struct {
    type:     u8;
    padding3: [3] u8;
    padding:  u32;
    key:      FriendKey;
}

/// Enum to use with FRD_GetNotificationEvent
NotificationTypes :: enum u8 {
    USER_WENT_ONLINE        :: 1;
    USER_WENT_OFFLINE       :: 2;
    FRIEND_WENT_ONLINE      :: 3;
    FRIEND_UPDATED_PRESENCE :: 4;
    FRIEND_UPDATED_MII      :: 5;
    FRIEND_UPDATED_PROFILE  :: 6;
    FRIEND_WENT_OFFLINE     :: 7;
    FRIEND_REGISTERED_USER  :: 8;
    FRIEND_SENT_INVITATION  :: 9;
}

/// Initializes FRD service.
frdInit :: () -> Result #foreign libctru;

/// Exists FRD.
frdExit :: () -> void #foreign libctru;

/// Get FRD handle.
frdGetSessionHandle :: () -> *Handle #foreign libctru;

/**
* @brief Gets the login status of the current user.
* @param state Pointer to write the current user's login status to.
*/
FRDU_HasLoggedIn :: (state: *bool) -> Result #foreign libctru;

/**
* @brief Gets the online status of the current user.
* @param state Pointer to write the current user's online status to.
*/
FRDU_IsOnline :: (state: *bool) -> Result #foreign libctru;

/// Logs out of Nintendo's friend server.
FRD_Logout :: () -> Result #foreign libctru;

/**
* @brief Log in to Nintendo's friend server.
* @param event Event to signal when Login is done.
*/
FRD_Login :: (event: Handle) -> Result #foreign libctru;

/**
* @brief Gets the current user's friend key.
* @param key Pointer to write the current user's friend key to.
*/
FRD_GetMyFriendKey :: (key: *FriendKey) -> Result #foreign libctru;

/**
* @brief Gets the current user's privacy information.
* @param isPublicMode Determines whether friends are notified of the current user's online status.
* @param isShowGameName Determines whether friends are notified of the application that the current user is running.
* @param isShowPlayedGame Determiens whether to display the current user's game history.
*/
FRD_GetMyPreference :: (isPublicMode: *bool, isShowGameName: *bool, isShowPlayedGame: *bool) -> Result #foreign libctru;

/**
* @brief Gets the current user's profile information.
* @param profile Pointer to write the current user's profile information to.
*/
FRD_GetMyProfile :: (profile: *FriendProfile) -> Result #foreign libctru;

/**
* @brief Gets the current user's screen name.
* @param name Pointer to write the current user's screen name to.
* @param max_size Max size of the screen name.
*/
FRD_GetMyScreenName :: (name: *u8, max_size: size_t) -> Result #foreign libctru;

/**
* @brief Gets the current user's Mii data.
* @param mii Pointer to write the current user's mii data to.
*/
FRD_GetMyMii :: (mii: *MiiData) -> Result #foreign libctru;

/**
* @brief Gets the current user's playing game.
* @param titleId Pointer to write the current user's playing game to.
*/
FRD_GetMyPlayingGame :: (titleId: *u64) -> Result #foreign libctru;

/**
* @brief Gets the current user's favourite game.
* @param titleId Pointer to write the title ID of current user's favourite game to.
*/
FRD_GetMyFavoriteGame :: (titleId: *u64) -> Result #foreign libctru;

/**
* @brief Gets the current user's comment on their friend profile.
* @param comment Pointer to write the current user's comment to.
* @param max_size Max size of the comment.
*/
FRD_GetMyComment :: (comment: *u8, max_size: size_t) -> Result #foreign libctru;

/**
* @brief Gets the current user's friend key list.
* @param friendKeyList Pointer to write the friend key list to.
* @param num Stores the number of friend keys obtained.
* @param offset The index of the friend key to start with.
* @param size Size of the friend key list. (FRIEND_LIST_SIZE)
*/
FRD_GetFriendKeyList :: (friendKeyList: *FriendKey, num: *u32, offset: u32, size: u32) -> Result #foreign libctru;

/**
* @brief Gets the current user's friends' Mii data.
* @param miiDataList Pointer to write Mii data to.
* @param friendKeyList Pointer to FriendKeys.
* @param size Number of Friendkeys.
*/
FRD_GetFriendMii :: (miiDataList: *MiiData, friendKeyList: *FriendKey, size: size_t) -> Result #foreign libctru;

/**
* @brief Get the current user's friends' profile data.
* @param profile Pointer to write profile data to.
* @param friendKeyList Pointer to FriendKeys.
* @param size Number of FriendKeys.
*/
FRD_GetFriendProfile :: (profile: *FriendProfile, friendKeyList: *FriendKey, size: size_t) -> Result #foreign libctru;

/**
* @brief Get the current user's friends' playing game.
* @param desc Pointer to write Game Description data to.
* @param friendKeyList Pointer to FriendKeys,
* @param size Number Of FriendKeys.
*/
FRD_GetFriendPlayingGame :: (desc: *GameDescription, friendKeyList: *FriendKey, size: size_t) -> Result #foreign libctru;

/**
* @brief Get the current user's friends' favourite game.
* @param desc Pointer to write Game Description data to.
* @param friendKeyList Pointer to FriendKeys,
* @param count Number Of FriendKeys.
*/
FRD_GetFriendFavouriteGame :: (desc: *GameDescription, friendKeyList: *FriendKey, count: u32) -> Result #foreign libctru;

/**
* @brief Gets whether a friend key is included in the current user's friend list.
* @param friendKeyList Pointer to a list of friend keys.
* @param isFromList Pointer to a write the friendship status to.
*/
FRD_IsInFriendList :: (friendKeyList: *FriendKey, isFromList: *bool) -> Result #foreign libctru;

/**
* @brief Updates the game mode description string.
* @param desc Pointer to write the game mode description to.
*/
FRD_UpdateGameModeDescription :: (desc: *u8) -> Result #foreign libctru;

/**
* @brief Event which is signaled when friend login states change.
* @param event event which will be signaled.
*/
FRD_AttachToEventNotification :: (event: Handle) -> Result #foreign libctru;

/**
* @brief Get Latest Event Notification
* @param event Pointer to write recieved notification event struct to.
* @param count Number of events
* @param recievedNotifCount Number of notification reccieved.
*/
FRD_GetEventNotification :: (event: *NotificationEvent, count: u32, recievedNotifCount: *u32) -> Result #foreign libctru;

/**
* @brief Returns the friend code using the given principal ID.
* @param principalId The principal ID being used.
* @param friendCode Pointer to write the friend code to.
*/
FRD_PrincipalIdToFriendCode :: (principalId: u32, friendCode: *u64) -> Result #foreign libctru;

/**
* @brief Returns the principal ID using the given friend code.
* @param friendCode The friend code being used.
* @param principalId Pointer to write the principal ID to.
*/
FRD_FriendCodeToPrincipalId :: (friendCode: u64, principalId: *u32) -> Result #foreign libctru;

/**
* @brief Checks if the friend code is valid.
* @param friendCode The friend code being used.
* @param isValid Pointer to write the validity of the friend code to.
*/
FRD_IsValidFriendCode :: (friendCode: u64, isValid: *bool) -> Result #foreign libctru;

/**
* @brief Sets the Friend API to use a specific SDK version.
* @param sdkVer The SDK version needed to be used.
*/
FRD_SetClientSdkVersion :: (sdkVer: u32) -> Result #foreign libctru;

/**
* @brief Add a Friend online.
* @param event Event signaled when friend is registered.
* @param principalId PrincipalId of the friend to add.
*/
FRD_AddFriendOnline :: (event: Handle, principalId: u32) -> Result #foreign libctru;

/**
* @brief Remove a Friend.
* @param principalId PrinipalId of the friend code to remove.
* @param localFriendCode LocalFriendCode of the friend code to remove.
*/
FRD_RemoveFriend :: (principalId: u32, localFriendCode: u64) -> Result #foreign libctru;

/// LCD screens.
GSPLCD_SCREEN :: enum u8 {
    TOP    :: 1;
    BOTTOM :: 2;
    BOTH   :: 3;
}

/// Initializes GSPLCD.
gspLcdInit :: () -> Result #foreign libctru;

/// Exits GSPLCD.
gspLcdExit :: () -> void #foreign libctru;

/**
* @brief Gets a pointer to the current gsp::Lcd session handle.
* @return A pointer to the current gsp::Lcd session handle.
*/
gspLcdGetSessionHandle :: () -> *Handle #foreign libctru;

/// Powers on both backlights.
GSPLCD_PowerOnAllBacklights :: () -> Result #foreign libctru;

/// Powers off both backlights.
GSPLCD_PowerOffAllBacklights :: () -> Result #foreign libctru;

/**
* @brief Powers on the backlight.
* @param screen Screen to power on.
*/
GSPLCD_PowerOnBacklight :: (screen: u32) -> Result #foreign libctru;

/**
* @brief Powers off the backlight.
* @param screen Screen to power off.
*/
GSPLCD_PowerOffBacklight :: (screen: u32) -> Result #foreign libctru;

/**
* @brief Sets 3D_LEDSTATE to the input state value.
* @param disable False = 3D LED enable, true = 3D LED disable.
*/
GSPLCD_SetLedForceOff :: (disable: bool) -> Result #foreign libctru;

/**
* @brief Gets the LCD screens' vendors. Stubbed on old 3ds.
* @param vendor Pointer to output the screen vendors to.
*/
GSPLCD_GetVendors :: (vendors: *u8) -> Result #foreign libctru;

/**
* @brief Gets the LCD screens' brightness. Stubbed on old 3ds.
* @param screen Screen to get the brightness value of.
* @param brightness Brightness value returned.
*/
GSPLCD_GetBrightness :: (screen: u32, brightness: *u32) -> Result #foreign libctru;

/**
* @brief Sets the LCD screens' brightness.
* @param screen Screen to set the brightness value of.
* @param brightness Brightness value set.
*/
GSPLCD_SetBrightness :: (screen: u32, brightness: u32) -> Result #foreign libctru;

/**
* @brief Sets the LCD screens' raw brightness.
* @param screen Screen to set the brightness value of.
* @param brightness Brightness value set.
*/
GSPLCD_SetBrightnessRaw :: (screen: u32, brightness: u32) -> Result #foreign libctru;

/// Key values.
KEY :: enum_flags u32 {
    A            :: 1;
    B            :: 2;
    SELECT       :: 4;
    START        :: 8;
    DRIGHT       :: 16;
    DLEFT        :: 32;
    DUP          :: 64;
    DDOWN        :: 128;
    R            :: 256;
    L            :: 512;
    X            :: 1024;
    Y            :: 2048;
    ZL           :: 16384;
    ZR           :: 32768;
    TOUCH        :: 1048576;
    CSTICK_RIGHT :: 16777216;
    CSTICK_LEFT  :: 33554432;
    CSTICK_UP    :: 67108864;
    CSTICK_DOWN  :: 134217728;
    CPAD_RIGHT   :: 268435456;
    CPAD_LEFT    :: 536870912;
    CPAD_UP      :: 1073741824;
    CPAD_DOWN    :: 2147483648;
    UP           :: 1073741888;
    DOWN         :: 2147483776;
    LEFT         :: 536870944;
    RIGHT        :: 268435472;
}

/// Touch position.
touchPosition :: struct {
    px: u16; ///< Touch X
    py: u16; ///< Touch Y
}

/// Circle Pad position.
circlePosition :: struct {
    dx: s16; ///< Pad X
    dy: s16; ///< Pad Y
}

/// Accelerometer vector.
accelVector :: struct {
    x: s16; ///< Accelerometer X
    y: s16; ///< Accelerometer Y
    z: s16; ///< Accelerometer Z
}

/// Gyroscope angular rate.
angularRate :: struct {
    x: s16; ///< Roll
    z: s16; ///< Yaw
    y: s16; ///< Pitch
}

/// HID events.
HID_Event :: enum u8 {
    PAD0     :: 0;
    PAD1     :: 1;
    Accel    :: 2;
    Gyro     :: 3;
    DebugPad :: 4;
    MAX      :: 5;
}

/// Initializes HID.
hidInit :: () -> Result #foreign libctru;

/// Exits HID.
hidExit :: () -> void #foreign libctru;

/**
* @brief Sets the key repeat parameters for @ref hidKeysRepeat.
* @param delay Initial delay.
* @param interval Repeat interval.
*/
hidSetRepeatParameters :: (delay: u32, interval: u32) -> void #foreign libctru;

/// Scans HID for input data.
hidScanInput :: () -> void #foreign libctru;

/**
* @brief Returns a bitmask of held buttons.
* Individual buttons can be extracted using binary AND.
* @return 32-bit bitmask of held buttons (1+ frames).
*/
hidKeysHeld :: () -> KEY #foreign libctru;

/**
* @brief Returns a bitmask of newly pressed buttons, this frame.
* Individual buttons can be extracted using binary AND.
* @return 32-bit bitmask of newly pressed buttons.
*/
hidKeysDown :: () -> KEY #foreign libctru;

/**
* @brief Returns a bitmask of newly pressed or repeated buttons, this frame.
* Individual buttons can be extracted using binary AND.
* @return 32-bit bitmask of newly pressed or repeated buttons.
*/
hidKeysDownRepeat :: () -> KEY #foreign libctru;

/**
* @brief Returns a bitmask of newly released buttons, this frame.
* Individual buttons can be extracted using binary AND.
* @return 32-bit bitmask of newly released buttons.
*/
hidKeysUp :: () -> KEY #foreign libctru;

/**
* @brief Reads the current touch position.
* @param pos Pointer to output the touch position to.
*/
hidTouchRead :: (pos: *touchPosition) -> void #foreign libctru;

/**
* @brief Reads the current circle pad position.
* @param pos Pointer to output the circle pad position to.
*/
hidCircleRead :: (pos: *circlePosition) -> void #foreign libctru;

/**
* @brief Reads the current accelerometer data.
* @param vector Pointer to output the accelerometer data to.
*/
hidAccelRead :: (vector: *accelVector) -> void #foreign libctru;

/**
* @brief Reads the current gyroscope data.
* @param rate Pointer to output the gyroscope data to.
*/
hidGyroRead :: (rate: *angularRate) -> void #foreign libctru;

/**
* @brief Waits for an HID event.
* @param id ID of the event.
* @param nextEvent Whether to discard the current event and wait for the next event.
*/
hidWaitForEvent :: (id: HID_Event, nextEvent: bool) -> void #foreign libctru;

/**
* @brief Waits for any HID or IRRST event.
* @param nextEvents Whether to discard the current events and wait for the next events.
* @param cancelEvent Optional additional handle to wait on, otherwise 0.
* @param timeout Timeout.
*/
hidWaitForAnyEvent :: (nextEvents: bool, cancelEvent: Handle, timeout: s64) -> Result #foreign libctru;

/**
* @brief Gets the handles for HID operation.
* @param outMemHandle Pointer to output the shared memory handle to.
* @param eventpad0 Pointer to output the pad 0 event handle to.
* @param eventpad1 Pointer to output the pad 1 event handle to.
* @param eventaccel Pointer to output the accelerometer event handle to.
* @param eventgyro Pointer to output the gyroscope event handle to.
* @param eventdebugpad Pointer to output the debug pad event handle to.
*/
HIDUSER_GetHandles :: (outMemHandle: *Handle, eventpad0: *Handle, eventpad1: *Handle, eventaccel: *Handle, eventgyro: *Handle, eventdebugpad: *Handle) -> Result #foreign libctru;

/// Enables the accelerometer.
HIDUSER_EnableAccelerometer :: () -> Result #foreign libctru;

/// Disables the accelerometer.
HIDUSER_DisableAccelerometer :: () -> Result #foreign libctru;

/// Enables the gyroscope.
HIDUSER_EnableGyroscope :: () -> Result #foreign libctru;

/// Disables the gyroscope.
HIDUSER_DisableGyroscope :: () -> Result #foreign libctru;

/**
* @brief Gets the gyroscope raw to dps coefficient.
* @param coeff Pointer to output the coefficient to.
*/
HIDUSER_GetGyroscopeRawToDpsCoefficient :: (coeff: *float) -> Result #foreign libctru;

/**
* @brief Gets the current volume slider value. (0-63)
* @param volume Pointer to write the volume slider value to.
*/
HIDUSER_GetSoundVolume :: (volume: *u8) -> Result #foreign libctru;

/// Initializes IRRST.
irrstInit :: () -> Result #foreign libctru;

/// Exits IRRST.
irrstExit :: () -> void #foreign libctru;

/// Scans IRRST for input.
irrstScanInput :: () -> void #foreign libctru;

/**
* @brief Gets IRRST's held keys.
* @return IRRST's held keys.
*/
irrstKeysHeld :: () -> u32 #foreign libctru;

/**
* @brief Reads the current c-stick position.
* @param pos Pointer to output the current c-stick position to.
*/
irrstCstickRead :: (pos: *circlePosition) -> void #foreign libctru;

/**
* @brief Waits for the IRRST input event to trigger.
* @param nextEvent Whether to discard the current event and wait until the next event.
*/
irrstWaitForEvent :: (nextEvent: bool) -> void #foreign libctru;

/**
* @brief Gets the shared memory and event handles for IRRST.
* @param outMemHandle Pointer to write the shared memory handle to.
* @param outEventHandle Pointer to write the event handle to.
*/
IRRST_GetHandles :: (outMemHandle: *Handle, outEventHandle: *Handle) -> Result #foreign libctru;

/**
* @brief Initializes IRRST.
* @param unk1 Unknown.
* @param unk2 Unknown.
*/
IRRST_Initialize :: (unk1: u32, unk2: u8) -> Result #foreign libctru;

/// Shuts down IRRST.
IRRST_Shutdown :: () -> Result #foreign libctru;

/// sslc context.
sslcContext :: struct {
    servhandle:       Handle; ///< Service handle.
    sslchandle:       u32; ///< SSLC handle.
    sharedmem_handle: Handle;
}

SSLC_DefaultRootCert :: enum u8 {
    Nintendo_CA           :: 1;
    Nintendo_CA_G2        :: 2;
    Nintendo_CA_G3        :: 3;
    Nintendo_Class2_CA    :: 4;
    Nintendo_Class2_CA_G2 :: 5;
    Nintendo_Class2_CA_G3 :: 6;
    CyberTrust            :: 7;
    AddTrust_External_CA  :: 8;
    COMODO                :: 9;
    USERTrust             :: 10;
    DigiCert_EV           :: 11;
}

SSLC_DefaultClientCert :: enum u8 {
    SSLC_DefaultClientCert_ClCertA :: 64;
}

/// sslc options. https://www.3dbrew.org/wiki/SSL_Services#SSLOpt
SSLCOPT :: enum u16 {
    Default       :: 0;
    DisableVerify :: 512;
    TLSv10        :: 2048;
}

/// Initializes SSLC. Normally session_handle should be 0. When non-zero this will use the specified handle for the main-service-session without using the Initialize command, instead of using srvGetServiceHandle.
sslcInit :: (session_handle: Handle) -> Result #foreign libctru;

/// Exits SSLC.
sslcExit :: () -> void #foreign libctru;

/**
* @brief Creates a RootCertChain.
* @param RootCertChain_contexthandle Output contexthandle.
*/
sslcCreateRootCertChain :: (RootCertChain_contexthandle: *u32) -> Result #foreign libctru;

/**
* @brief Destroys a RootCertChain.
* @param RootCertChain_contexthandle RootCertChain contexthandle.
*/
sslcDestroyRootCertChain :: (RootCertChain_contexthandle: u32) -> Result #foreign libctru;

/**
* @brief Adds a trusted RootCA cert to a RootCertChain.
* @param RootCertChain_contexthandle RootCertChain to use.
* @param cert Pointer to the DER cert.
* @param certsize Size of the DER cert.
*/
sslcAddTrustedRootCA :: (RootCertChain_contexthandle: u32, cert: *u8, certsize: u32, cert_contexthandle: *u32) -> Result #foreign libctru;

/**
* @brief Adds a default RootCA cert to a RootCertChain.
* @param RootCertChain_contexthandle RootCertChain to use.
* @param certID ID of the cert to add.
* @param cert_contexthandle Optional, the cert contexthandle can be written here.
*/
sslcRootCertChainAddDefaultCert :: (RootCertChain_contexthandle: u32, certID: SSLC_DefaultRootCert, cert_contexthandle: *u32) -> Result #foreign libctru;

/**
* @brief Removes the specified cert from the RootCertChain.
* @param RootCertChain_contexthandle RootCertChain to use.
* @param cert_contexthandle Cert contexthandle to remove from the RootCertChain.
*/
sslcRootCertChainRemoveCert :: (RootCertChain_contexthandle: u32, cert_contexthandle: u32) -> Result #foreign libctru;

/**
* @brief Creates an unknown CertChain.
* @param CertChain_contexthandle Output contexthandle.
*/
sslcCreate8CertChain :: (CertChain_contexthandle: *u32) -> Result #foreign libctru;

/**
* @brief Destroys a CertChain from sslcCreate8CertChain().
* @param CertChain_contexthandle CertChain contexthandle.
*/
sslcDestroy8CertChain :: (CertChain_contexthandle: u32) -> Result #foreign libctru;

/**
* @brief Adds a cert to a CertChain from sslcCreate8CertChain().
* @param CertChain_contexthandle CertChain to use.
* @param cert Pointer to the cert.
* @param certsize Size of the cert.
*/
sslc8CertChainAddCert :: (CertChain_contexthandle: u32, cert: *u8, certsize: u32, cert_contexthandle: *u32) -> Result #foreign libctru;

/**
* @brief Adds a default cert to a CertChain from sslcCreate8CertChain(). Not actually usable since no certIDs are implemented in SSL-module for this.
* @param CertChain_contexthandle CertChain to use.
* @param certID ID of the cert to add.
* @param cert_contexthandle Optional, the cert contexthandle can be written here.
*/
sslc8CertChainAddDefaultCert :: (CertChain_contexthandle: u32, certID: u8, cert_contexthandle: *u32) -> Result #foreign libctru;

/**
* @brief Removes the specified cert from the CertChain from sslcCreate8CertChain().
* @param CertChain_contexthandle CertChain to use.
* @param cert_contexthandle Cert contexthandle to remove from the CertChain.
*/
sslc8CertChainRemoveCert :: (CertChain_contexthandle: u32, cert_contexthandle: u32) -> Result #foreign libctru;

/**
* @brief Opens a new ClientCert-context.
* @param cert Pointer to the DER cert.
* @param certsize Size of the DER cert.
* @param key Pointer to the DER key.
* @param keysize Size of the DER key.
* @param ClientCert_contexthandle Output contexthandle.
*/
sslcOpenClientCertContext :: (cert: *u8, certsize: u32, key: *u8, keysize: u32, ClientCert_contexthandle: *u32) -> Result #foreign libctru;

/**
* @brief Opens a ClientCert-context with a default certID.
* @param certID ID of the ClientCert to use.
* @param ClientCert_contexthandle Output contexthandle.
*/
sslcOpenDefaultClientCertContext :: (certID: SSLC_DefaultClientCert, ClientCert_contexthandle: *u32) -> Result #foreign libctru;

/**
* @brief Closes the specified ClientCert-context.
* @param ClientCert_contexthandle ClientCert-context to use.
*/
sslcCloseClientCertContext :: (ClientCert_contexthandle: u32) -> Result #foreign libctru;

/**
* @brief This uses ps:ps SeedRNG internally.
*/
sslcSeedRNG :: () -> Result #foreign libctru;

/**
* @brief This uses ps:ps GenerateRandomData internally.
* @param buf Output buffer.
* @param size Output size.
*/
sslcGenerateRandomData :: (buf: *u8, size: u32) -> Result #foreign libctru;

/**
* @brief Creates a sslc context.
* @param context sslc context.
* @param sockfd Socket fd, this code automatically uses the required SOC command before using the actual sslc command.
* @param input_opt Input sslc options bitmask.
* @param hostname Server hostname.
*/
sslcCreateContext :: (_context: *sslcContext, sockfd: s32, input_opt: u32, hostname: *u8) -> Result #foreign libctru;

/*
* @brief Destroys a sslc context. The associated sockfd must be closed manually.
* @param context sslc context.
*/
sslcDestroyContext :: (_context: *sslcContext) -> Result #foreign libctru;

/*
* @brief Starts the TLS connection. If successful, this will not return until the connection is ready for data-transfer via sslcRead/sslcWrite.
* @param context sslc context.
* @param internal_retval Optional ptr where the internal_retval will be written. The value is only copied to here by this function when no error occurred.
* @param out Optional ptr where an output u32 will be written. The value is only copied to here by this function when no error occurred.
*/
sslcStartConnection :: (_context: *sslcContext, internal_retval: *s32, out: *u32) -> Result #foreign libctru;

/*
* @brief Receive data over the network connection.
* @param context sslc context.
* @param buf Output buffer.
* @param len Size to receive.
* @param peek When true, this is equivalent to setting the recv() MSG_PEEK flag.
* @return When this isn't an error-code, this is the total transferred data size.
*/
sslcRead :: (_context: *sslcContext, buf: *void, len: size_t, peek: bool) -> Result #foreign libctru;

/*
* @brief Send data over the network connection.
* @param context sslc context.
* @param buf Input buffer.
* @param len Size to send.
* @return When this isn't an error-code, this is the total transferred data size.
*/
sslcWrite :: (_context: *sslcContext, buf: *void, len: size_t) -> Result #foreign libctru;

/*
* @brief Set the RootCertChain for the specified sslc context.
* @param context sslc context.
* @param handle RootCertChain contexthandle.
*/
sslcContextSetRootCertChain :: (_context: *sslcContext, handle: u32) -> Result #foreign libctru;

/*
* @brief Set the ClientCert-context for the specified sslc context.
* @param context sslc context.
* @param handle ClientCert contexthandle.
*/
sslcContextSetClientCert :: (_context: *sslcContext, handle: u32) -> Result #foreign libctru;

/*
* @brief Set the context for a CertChain from sslcCreate8CertChain(), for the specified sslc context. This needs updated once it's known what this context is for.
* @param context sslc context.
* @param handle contexthandle.
*/
sslcContextSetHandle8 :: (_context: *sslcContext, handle: u32) -> Result #foreign libctru;

/*
* @brief Clears the options field bits for the context using the specified bitmask.
* @param context sslc context.
* @param bitmask opt bitmask.
*/
sslcContextClearOpt :: (_context: *sslcContext, bitmask: u32) -> Result #foreign libctru;

/*
* @brief This copies two strings from context state to the specified output buffers. Each string is only copied if it was successfully loaded. The maxsizes include the nul-terminator. This can only be used if sslcStartConnection() was already used successfully.
* @param context sslc context.
* @param outprotocols Output buffer for a string containing all protocol versions supported by SSL-module.
* @param outprotocols_maxsize Max size of the above output buffer.
* @param outcipher Output buffer for a string containing the cipher suite currently being used.
* @param outcipher_maxsize Max size of the above output buffer.
*/
sslcContextGetProtocolCipher :: (_context: *sslcContext, outprotocols: *u8, outprotocols_maxsize: u32, outcipher: *u8, outcipher_maxsize: u32) -> Result #foreign libctru;

/*
* @brief This loads an u32 from the specified context state. This needs updated once it's known what this field is for.
* @param context sslc context.
* @param out Output ptr to write the value to.
*/
sslcContextGetState :: (_context: *sslcContext, out: *u32) -> Result #foreign libctru;

/*
* @brief This initializes sharedmem for the specified context.
* @param context sslc context.
* @param buf Sharedmem buffer with address aligned to 0x1000-bytes.
* @param size Sharedmem size aligned to 0x1000-bytes.
*/
sslcContextInitSharedmem :: (_context: *sslcContext, buf: *u8, size: u32) -> Result #foreign libctru;

/*
* @brief This loads the specified cert. This needs updated once it's known what the cert format is and what the cert is used for later.
* @param buf Input cert.
* @param size Cert size.
*/
sslcAddCert :: (_context: *sslcContext, buf: *u8, size: u32) -> Result #foreign libctru;

/// HTTP context.
httpcContext :: struct {
    servhandle: Handle; ///< Service handle.
    httphandle: u32; ///< HTTP handle.
}

/// HTTP request method.
HTTPC_RequestMethod :: enum u8 {
    GET    :: 1;
    POST   :: 2;
    HEAD   :: 3;
    PUT    :: 4;
    DELETE :: 5;
}

/// HTTP request status.
HTTPC_RequestStatus :: enum u8 {
    REQUEST_IN_PROGRESS :: 5;
    DOWNLOAD_READY      :: 7;
}

/// HTTP KeepAlive option.
HTTPC_KeepAlive :: enum u8 {
    DISABLED :: 0;
    ENABLED  :: 1;
}

/// Initializes HTTPC. For HTTP GET the sharedmem_size can be zero. The sharedmem contains data which will be later uploaded for HTTP POST. sharedmem_size should be aligned to 0x1000-bytes.
httpcInit :: (sharedmem_size: u32) -> Result #foreign libctru;

/// Exits HTTPC.
httpcExit :: () -> void #foreign libctru;

/**
* @brief Opens a HTTP context.
* @param context Context to open.
* @param url URL to connect to.
* @param use_defaultproxy Whether the default proxy should be used (0 for default)
*/
httpcOpenContext :: (_context: *httpcContext, method: HTTPC_RequestMethod, url: *u8, use_defaultproxy: u32) -> Result #foreign libctru;

/**
* @brief Closes a HTTP context.
* @param context Context to close.
*/
httpcCloseContext :: (_context: *httpcContext) -> Result #foreign libctru;

/**
* @brief Cancels a HTTP connection.
* @param context Context to close.
*/
httpcCancelConnection :: (_context: *httpcContext) -> Result #foreign libctru;

/**
* @brief Adds a request header field to a HTTP context.
* @param context Context to use.
* @param name Name of the field.
* @param value Value of the field.
*/
httpcAddRequestHeaderField :: (_context: *httpcContext, name: *u8, value: *u8) -> Result #foreign libctru;

/**
* @brief Adds a POST form field to a HTTP context.
* @param context Context to use.
* @param name Name of the field.
* @param value Value of the field.
*/
httpcAddPostDataAscii :: (_context: *httpcContext, name: *u8, value: *u8) -> Result #foreign libctru;

/**
* @brief Adds a POST form field with binary data to a HTTP context.
* @param context Context to use.
* @param name Name of the field.
* @param value The binary data to pass as a value.
* @param len Length of the binary data which has been passed.
*/
httpcAddPostDataBinary :: (_context: *httpcContext, name: *u8, value: *u8, len: u32) -> Result #foreign libctru;

/**
* @brief Adds a POST body to a HTTP context.
* @param context Context to use.
* @param data The data to be passed as raw into the body of the post request.
* @param len Length of data passed by data param.
*/
httpcAddPostDataRaw :: (_context: *httpcContext, data: *u32, len: u32) -> Result #foreign libctru;

/**
* @brief Begins a HTTP request.
* @param context Context to use.
*/
httpcBeginRequest :: (_context: *httpcContext) -> Result #foreign libctru;

/**
* @brief Receives data from a HTTP context.
* @param context Context to use.
* @param buffer Buffer to receive data to.
* @param size Size of the buffer.
*/
httpcReceiveData :: (_context: *httpcContext, buffer: *u8, size: u32) -> Result #foreign libctru;

/**
* @brief Receives data from a HTTP context with a timeout value.
* @param context Context to use.
* @param buffer Buffer to receive data to.
* @param size Size of the buffer.
* @param timeout Maximum time in nanoseconds to wait for a reply.
*/
httpcReceiveDataTimeout :: (_context: *httpcContext, buffer: *u8, size: u32, timeout: u64) -> Result #foreign libctru;

/**
* @brief Gets the request state of a HTTP context.
* @param context Context to use.
* @param out Pointer to output the HTTP request state to.
*/
httpcGetRequestState :: (_context: *httpcContext, out: *HTTPC_RequestStatus) -> Result #foreign libctru;

/**
* @brief Gets the download size state of a HTTP context.
* @param context Context to use.
* @param downloadedsize Pointer to output the downloaded size to.
* @param contentsize Pointer to output the total content size to.
*/
httpcGetDownloadSizeState :: (_context: *httpcContext, downloadedsize: *u32, contentsize: *u32) -> Result #foreign libctru;

/**
* @brief Gets the response code of the HTTP context.
* @param context Context to get the response code of.
* @param out Pointer to write the response code to.
*/
httpcGetResponseStatusCode :: (_context: *httpcContext, out: *u32) -> Result #foreign libctru;

/**
* @brief Gets the response code of the HTTP context with a timeout value.
* @param context Context to get the response code of.
* @param out Pointer to write the response code to.
* @param timeout Maximum time in nanoseconds to wait for a reply.
*/
httpcGetResponseStatusCodeTimeout :: (_context: *httpcContext, out: *u32, timeout: u64) -> Result #foreign libctru;

/**
* @brief Gets a response header field from a HTTP context.
* @param context Context to use.
* @param name Name of the field.
* @param value Pointer to output the value of the field to.
* @param valuebuf_maxsize Maximum size of the value buffer.
*/
httpcGetResponseHeader :: (_context: *httpcContext, name: *u8, value: *u8, valuebuf_maxsize: u32) -> Result #foreign libctru;

/**
* @brief Adds a trusted RootCA cert to a HTTP context.
* @param context Context to use.
* @param cert Pointer to DER cert.
* @param certsize Size of the DER cert.
*/
httpcAddTrustedRootCA :: (_context: *httpcContext, cert: *u8, certsize: u32) -> Result #foreign libctru;

/**
* @brief Adds a default RootCA cert to a HTTP context.
* @param context Context to use.
* @param certID ID of the cert to add, see sslc.h.
*/
httpcAddDefaultCert :: (_context: *httpcContext, certID: SSLC_DefaultRootCert) -> Result #foreign libctru;

/**
* @brief Sets the RootCertChain for a HTTP context.
* @param context Context to use.
* @param RootCertChain_contexthandle Contexthandle for the RootCertChain.
*/
httpcSelectRootCertChain :: (_context: *httpcContext, RootCertChain_contexthandle: u32) -> Result #foreign libctru;

/**
* @brief Sets the ClientCert for a HTTP context.
* @param context Context to use.
* @param cert Pointer to DER cert.
* @param certsize Size of the DER cert.
* @param privk Pointer to the DER private key.
* @param privk_size Size of the privk.
*/
httpcSetClientCert :: (_context: *httpcContext, cert: *u8, certsize: u32, privk: *u8, privk_size: u32) -> Result #foreign libctru;

/**
* @brief Sets the default clientcert for a HTTP context.
* @param context Context to use.
* @param certID ID of the cert to add, see sslc.h.
*/
httpcSetClientCertDefault :: (_context: *httpcContext, certID: SSLC_DefaultClientCert) -> Result #foreign libctru;

/**
* @brief Sets the ClientCert contexthandle for a HTTP context.
* @param context Context to use.
* @param ClientCert_contexthandle Contexthandle for the ClientCert.
*/
httpcSetClientCertContext :: (_context: *httpcContext, ClientCert_contexthandle: u32) -> Result #foreign libctru;

/**
* @brief Sets SSL options for the context.
* The HTTPC SSL option bits are the same as those defined in sslc.h
* @param context Context to set flags on.
* @param options SSL option flags.
*/
httpcSetSSLOpt :: (_context: *httpcContext, options: u32) -> Result #foreign libctru;

/**
* @brief Sets the SSL options which will be cleared for the context.
* The HTTPC SSL option bits are the same as those defined in sslc.h
* @param context Context to clear flags on.
* @param options SSL option flags.
*/
httpcSetSSLClearOpt :: (_context: *httpcContext, options: u32) -> Result #foreign libctru;

/**
* @brief Creates a RootCertChain. Up to 2 RootCertChains can be created under this user-process.
* @param RootCertChain_contexthandle Output RootCertChain contexthandle.
*/
httpcCreateRootCertChain :: (RootCertChain_contexthandle: *u32) -> Result #foreign libctru;

/**
* @brief Destroy a RootCertChain.
* @param RootCertChain_contexthandle RootCertChain to use.
*/
httpcDestroyRootCertChain :: (RootCertChain_contexthandle: u32) -> Result #foreign libctru;

/**
* @brief Adds a RootCA cert to a RootCertChain.
* @param RootCertChain_contexthandle RootCertChain to use.
* @param cert Pointer to DER cert.
* @param certsize Size of the DER cert.
* @param cert_contexthandle Optional output ptr for the cert contexthandle(this can be NULL).
*/
httpcRootCertChainAddCert :: (RootCertChain_contexthandle: u32, cert: *u8, certsize: u32, cert_contexthandle: *u32) -> Result #foreign libctru;

/**
* @brief Adds a default RootCA cert to a RootCertChain.
* @param RootCertChain_contexthandle RootCertChain to use.
* @param certID ID of the cert to add, see sslc.h.
* @param cert_contexthandle Optional output ptr for the cert contexthandle(this can be NULL).
*/
httpcRootCertChainAddDefaultCert :: (RootCertChain_contexthandle: u32, certID: SSLC_DefaultRootCert, cert_contexthandle: *u32) -> Result #foreign libctru;

/**
* @brief Removes a cert from a RootCertChain.
* @param RootCertChain_contexthandle RootCertChain to use.
* @param cert_contexthandle Contexthandle of the cert to remove.
*/
httpcRootCertChainRemoveCert :: (RootCertChain_contexthandle: u32, cert_contexthandle: u32) -> Result #foreign libctru;

/**
* @brief Opens a ClientCert-context. Up to 2 ClientCert-contexts can be open under this user-process.
* @param cert Pointer to DER cert.
* @param certsize Size of the DER cert.
* @param privk Pointer to the DER private key.
* @param privk_size Size of the privk.
* @param ClientCert_contexthandle Output ClientCert context handle.
*/
httpcOpenClientCertContext :: (cert: *u8, certsize: u32, privk: *u8, privk_size: u32, ClientCert_contexthandle: *u32) -> Result #foreign libctru;

/**
* @brief Opens a ClientCert-context with a default clientclient. Up to 2 ClientCert-contexts can be open under this user-process.
* @param certID ID of the cert to add, see sslc.h.
* @param ClientCert_contexthandle Output ClientCert context handle.
*/
httpcOpenDefaultClientCertContext :: (certID: SSLC_DefaultClientCert, ClientCert_contexthandle: *u32) -> Result #foreign libctru;

/**
* @brief Closes a ClientCert context.
* @param ClientCert_contexthandle ClientCert context to use.
*/
httpcCloseClientCertContext :: (ClientCert_contexthandle: u32) -> Result #foreign libctru;

/**
* @brief Downloads data from the HTTP context into a buffer.
* The *entire* content must be downloaded before using httpcCloseContext(), otherwise httpcCloseContext() will hang.
* @param context Context to download data from.
* @param buffer Buffer to write data to.
* @param size Size of the buffer.
* @param downloadedsize Pointer to write the size of the downloaded data to.
*/
httpcDownloadData :: (_context: *httpcContext, buffer: *u8, size: u32, downloadedsize: *u32) -> Result #foreign libctru;

/**
* @brief Sets Keep-Alive for the context.
* @param context Context to set the KeepAlive flag on.
* @param option HTTPC_KeepAlive option.
*/
httpcSetKeepAlive :: (_context: *httpcContext, option: HTTPC_KeepAlive) -> Result #foreign libctru;

/// Node info struct.
udsNodeInfo :: struct {
    uds_friendcodeseed: u64; //UDS version of the FriendCodeSeed.
    union {
        usercfg: [24] u8; //This is the first 0x18-bytes from this config block: https://www.3dbrew.org/wiki/Config_Savegame#0x000A0000_Block
        struct {
            username: [10] u16;
            unk_x1c:  u16; //Unknown, normally zero. Set to 0x0 with the output from udsScanBeacons().
            flag:     u8; //"u8 flag, unknown. Originates from the u16 bitmask in the beacon node-list header. This flag is normally 0 since that bitmask is normally 0?"
            pad_x1f:  u8; //Unknown, normally zero.
        }
    }
    //The rest of this is initialized by NWM-module.
    NetworkNodeID:      u16;
    pad_x22:            u16; //Unknown, normally zero?
    word_x24:           u32; //Normally zero?
}

/// Connection status struct.
udsConnectionStatus :: struct {
    status:            u32;
    unk_x4:            u32;
    cur_NetworkNodeID: u16; //"u16 NetworkNodeID for this device."
    unk_xa:            u16;
    unk_xc:            [8] u32;
    total_nodes:       u8;
    max_nodes:         u8;
    node_bitmask:      u16; //"This is a bitmask of NetworkNodeIDs: bit0 for NetworkNodeID 0x1(host), bit1 for NetworkNodeID 0x2(first original client), and so on."
}

/// Network struct stored as big-endian.
udsNetworkStruct :: struct {
    host_macaddress:  [6] u8;
    channel:          u8; //Wifi channel for this network. If you want to create a network on a specific channel instead of the system selecting it, you can set this to a non-zero channel value.
    pad_x7:           u8;
    initialized_flag: u8; //Must be non-zero otherwise NWM-module will use zeros internally instead of the actual field data, for most/all(?) of the fields in this struct.
    unk_x9:           [3] u8;
    oui_value:        [3] u8; //"This is the OUI value for use with the beacon tags. Normally this is 001F32."
    oui_type:         u8; //"OUI type (21/0x15)"
    wlancommID:       u32; //Unique local-WLAN communications ID for each application.
    id8:              u8; //Additional ID that can be used by the application for different types of networks.
    unk_x15:          u8;
    attributes:       u16; //See the UDSNETATTR enum values below.
    networkID:        u32;
    total_nodes:      u8;
    max_nodes:        u8;
    unk_x1e:          u8;
    unk_x1f:          u8;
    unk_x20:          [31] u8;
    appdata_size:     u8;
    appdata:          [200] u8;
}

udsBindContext :: struct {
    BindNodeID: u32;
    event:      Handle;
    spectator:  bool;
}

/// General NWM input structure used for AP scanning.
nwmScanInputStruct :: struct {
    unk_x0:      u16;
    unk_x2:      u16;
    unk_x4:      u16;
    unk_x6:      u16;
    mac_address: [6] u8;
    unk_xe:      [38] u8; //Not initialized by dlp.
}

/// General NWM output structure from AP scanning.
nwmBeaconDataReplyHeader :: struct {
    maxsize:       u32; //"Max output size, from the command request."
    size:          u32; //"Total amount of output data written relative to struct+0. 0xC when there's no entries."
    total_entries: u32; //"Total entries, 0 for none. "
}

/// General NWM output structure from AP scanning, for each entry.
nwmBeaconDataReplyEntry :: struct {
    size:        u32; //"Size of this entire entry. The next entry starts at curentry_startoffset+curentry_size."
    unk_x4:      u8;
    channel:     u8; //Wifi channel for the AP.
    unk_x6:      u8;
    unk_x7:      u8;
    mac_address: [6] u8; //"AP MAC address."
    unk_xe:      [6] u8;
    unk_x14:     u32;
    val_x1c:     u32; //"Value 0x1C(size of this header and/or offset to the actual beacon data)."
}

/// Output structure generated from host scanning output.
udsNetworkScanInfo :: struct {
    datareply_entry: nwmBeaconDataReplyEntry;
    network:         udsNetworkStruct;
    nodes:           [16] udsNodeInfo;
}

UDSNETATTR :: enum u16 {
    DisableConnectSpectators :: 1;
    DisableConnectClients    :: 2;
    x4                       :: 4;
    Default                  :: 32768;
}

UDS_SENDFLAG :: enum u8 {
    Default   :: 1;
    Broadcast :: 2;
}

udsConnectionType :: enum u8 {
    Client    :: 1;
    Spectator :: 2;
}

/**
* @brief Initializes UDS.
* @param sharedmem_size This must be 0x1000-byte aligned.
* @param username Optional custom UTF-8 username(converted to UTF-16 internally) that other nodes on the UDS network can use. If not set the username from system-config is used. Max len is 10 characters without NUL-terminator.
*/
udsInit :: (sharedmem_size: size_t, username: *u8) -> Result #foreign libctru;

/// Exits UDS.
udsExit :: () -> void #foreign libctru;

/**
* @brief Generates a NodeInfo struct with data loaded from system-config.
* @param nodeinfo Output NodeInfo struct.
* @param username If set, this is the UTF-8 string to convert for use in the struct. Max len is 10 characters without NUL-terminator.
*/
udsGenerateNodeInfo :: (nodeinfo: *udsNodeInfo, username: *u8) -> Result #foreign libctru;

/**
* @brief Loads the UTF-16 username stored in the input NodeInfo struct, converted to UTF-8.
* @param nodeinfo Input NodeInfo struct.
* @param username This is the output UTF-8 string. Max len is 10 characters without NUL-terminator.
*/
udsGetNodeInfoUsername :: (nodeinfo: *udsNodeInfo, username: *u8) -> Result #foreign libctru;

/**
* @brief Checks whether a NodeInfo struct was initialized by NWM-module(not any output from udsGenerateNodeInfo()).
* @param nodeinfo Input NodeInfo struct.
*/
udsCheckNodeInfoInitialized :: (nodeinfo: *udsNodeInfo) -> bool #foreign libctru;

/**
* @brief Generates a default NetworkStruct for creating networks.
* @param network The output struct.
* @param wlancommID Unique local-WLAN communications ID for each application.
* @param id8 Additional ID that can be used by the application for different types of networks.
* @param max_nodes Maximum number of nodes(devices) that can be connected to the network, including the host.
*/
udsGenerateDefaultNetworkStruct :: (network: *udsNetworkStruct, wlancommID: u32, id8: u8, max_nodes: u8) -> void #foreign libctru;

/**
* @brief Scans for networks via beacon-scanning.
* @param outbuf Buffer which will be used by the beacon-scanning command and for the data parsing afterwards. Normally there's no need to use the contents of this buffer once this function returns.
* @param maxsize Max size of the buffer.
* @Param networks Ptr where the allocated udsNetworkScanInfo array buffer is written. The allocsize is sizeof(udsNetworkScanInfo)*total_networks.
* @Param total_networks Total number of networks stored under the networks buffer.
* @param wlancommID Unique local-WLAN communications ID for each application.
* @param id8 Additional ID that can be used by the application for different types of networks.
* @param host_macaddress When set, this code will only return network info from the specified host MAC address.
* @connected When not connected to a network this *must* be false. When connected to a network this *must* be true.
*/
udsScanBeacons :: (outbuf: *void, maxsize: size_t, networks: **udsNetworkScanInfo, total_networks: *size_t, wlancommID: u32, id8: u8, host_macaddress: *u8, connected: bool) -> Result #foreign libctru;

/**
* @brief This can be used by the host to set the appdata contained in the broadcasted beacons.
* @param buf Appdata buffer.
* @param size Size of the input appdata.
*/
udsSetApplicationData :: (buf: *void, size: size_t) -> Result #foreign libctru;

/**
* @brief This can be used while on a network(host/client) to get the appdata from the current beacon.
* @param buf Appdata buffer.
* @param size Max size of the output buffer.
* @param actual_size If set, the actual size of the appdata written into the buffer is stored here.
*/
udsGetApplicationData :: (buf: *void, size: size_t, actual_size: *size_t) -> Result #foreign libctru;

/**
* @brief This can be used with a NetworkStruct, from udsScanBeacons() mainly, for getting the appdata.
* @param buf Appdata buffer.
* @param size Max size of the output buffer.
* @param actual_size If set, the actual size of the appdata written into the buffer is stored here.
*/
udsGetNetworkStructApplicationData :: (network: *udsNetworkStruct, buf: *void, size: size_t, actual_size: *size_t) -> Result #foreign libctru;

/**
* @brief Create a bind.
* @param bindcontext The output bind context.
* @param NetworkNodeID This is the NetworkNodeID which this bind can receive data from.
* @param spectator False for a regular bind, true for a spectator.
* @param data_channel This is an arbitrary value to use for data-frame filtering. This bind will only receive data frames which contain a matching data_channel value, which was specified by udsSendTo(). The data_channel must be non-zero.
* @param recv_buffer_size Size of the buffer under sharedmem used for temporarily storing received data-frames which are then loaded by udsPullPacket(). The system requires this to be >=0x5F4. UDS_DEFAULT_RECVBUFSIZE can be used for this.
*/
udsBind :: (bindcontext: *udsBindContext, NetworkNodeID: u16, spectator: bool, data_channel: u8, recv_buffer_size: u32) -> Result #foreign libctru;

/**
* @brief Remove a bind.
* @param bindcontext The bind context.
*/
udsUnbind :: (bindcontext: *udsBindContext) -> Result #foreign libctru;

/**
* @brief Waits for the bind event to occur, or checks if the event was signaled. This event is signaled every time new data is available via udsPullPacket().
* @return Always true. However if wait=false, this will return false if the event wasn't signaled.
* @param bindcontext The bind context.
* @param nextEvent Whether to discard the current event and wait for the next event.
* @param wait When true this will not return until the event is signaled. When false this checks if the event was signaled without waiting for it.
*/
udsWaitDataAvailable :: (bindcontext: *udsBindContext, nextEvent: bool, wait: bool) -> bool #foreign libctru;

/**
* @brief Receives data over the network. This data is loaded from the recv_buffer setup by udsBind(). When a node disconnects, this will still return data from that node until there's no more frames from that node in the recv_buffer.
* @param bindcontext Bind context.
* @param buf Output receive buffer.
* @param size Size of the buffer.
* @param actual_size If set, the actual size written into the output buffer is stored here. This is zero when no data was received.
* @param src_NetworkNodeID If set, the source NetworkNodeID is written here. This is zero when no data was received.
*/
udsPullPacket :: (bindcontext: *udsBindContext, buf: *void, size: size_t, actual_size: *size_t, src_NetworkNodeID: *u16) -> Result #foreign libctru;

/**
* @brief Sends data over the network.
* @param dst_NetworkNodeID Destination NetworkNodeID.
* @param data_channel See udsBind().
* @param flags Send flags, see the UDS_SENDFLAG enum values.
* @param buf Input send buffer.
* @param size Size of the buffer.
*/
udsSendTo :: (dst_NetworkNodeID: u16, data_channel: u8, flags: u8, buf: *void, size: size_t) -> Result #foreign libctru;

/**
* @brief Gets the wifi channel currently being used.
* @param channel Output channel.
*/
udsGetChannel :: (channel: *u8) -> Result #foreign libctru;

/**
* @brief Starts hosting a new network.
* @param network The NetworkStruct, you can use udsGenerateDefaultNetworkStruct() for generating this.
* @param passphrase Raw input passphrase buffer.
* @param passphrase_size Size of the passphrase buffer.
* @param context Optional output bind context which will be created for this host, with NetworkNodeID=UDS_BROADCAST_NETWORKNODEID.
* @param data_channel This is the data_channel value which will be passed to udsBind() internally.
* @param recv_buffer_size This is the recv_buffer_size value which will be passed to udsBind() internally.
*/
udsCreateNetwork :: (network: *udsNetworkStruct, passphrase: *void, passphrase_size: size_t, _context: *udsBindContext, data_channel: u8, recv_buffer_size: u32) -> Result #foreign libctru;

/**
* @brief Connect to a network.
* @param network The NetworkStruct, you can use udsScanBeacons() for this.
* @param passphrase Raw input passphrase buffer.
* @param passphrase_size Size of the passphrase buffer.
* @param context Optional output bind context which will be created for this host.
* @param recv_NetworkNodeID This is the NetworkNodeID passed to udsBind() internally.
* @param connection_type Type of connection, see the udsConnectionType enum values.
* @param data_channel This is the data_channel value which will be passed to udsBind() internally.
* @param recv_buffer_size This is the recv_buffer_size value which will be passed to udsBind() internally.
*/
udsConnectNetwork :: (network: *udsNetworkStruct, passphrase: *void, passphrase_size: size_t, _context: *udsBindContext, recv_NetworkNodeID: u16, connection_type: udsConnectionType, data_channel: u8, recv_buffer_size: u32) -> Result #foreign libctru;

/**
* @brief Stop hosting the network.
*/
udsDestroyNetwork :: () -> Result #foreign libctru;

/**
* @brief Disconnect this client device from the network.
*/
udsDisconnectNetwork :: () -> Result #foreign libctru;

/**
* @brief This can be used by the host to force-disconnect client(s).
* @param NetworkNodeID Target NetworkNodeID. UDS_BROADCAST_NETWORKNODEID can be used to disconnect all clients.
*/
udsEjectClient :: (NetworkNodeID: u16) -> Result #foreign libctru;

/**
* @brief This can be used by the host to force-disconnect the spectators. Afterwards new spectators will not be allowed to connect until udsAllowSpectators() is used.
*/
udsEjectSpectator :: () -> Result #foreign libctru;

/**
* @brief This can be used by the host to update the network attributes. If bitmask 0x4 is clear in the input bitmask, this clears that bit in the value before actually writing the value into state. Normally you should use the below wrapper functions.
* @param bitmask Bitmask to clear/set in the attributes. See the UDSNETATTR enum values.
* @param flag When false, bit-clear, otherwise bit-set.
*/
udsUpdateNetworkAttribute :: (bitmask: u16, flag: bool) -> Result #foreign libctru;

/**
* @brief This uses udsUpdateNetworkAttribute() for (un)blocking new connections to this host.
* @param block When true, block the specified connection types(bitmask set). Otherwise allow them(bitmask clear).
* @param clients When true, (un)block regular clients.
* @param flag When true, update UDSNETATTR_x4. Normally this should be false.
*/
udsSetNewConnectionsBlocked :: (block: bool, clients: bool, flag: bool) -> Result #foreign libctru;

/**
* @brief This uses udsUpdateNetworkAttribute() for unblocking new spectator connections to this host. See udsEjectSpectator() for blocking new spectators.
*/
udsAllowSpectators :: () -> Result #foreign libctru;

/**
* @brief This loads the current ConnectionStatus struct.
* @param output Output ConnectionStatus struct.
*/
udsGetConnectionStatus :: (output: *udsConnectionStatus) -> Result #foreign libctru;

/**
* @brief Waits for the ConnectionStatus event to occur, or checks if the event was signaled. This event is signaled when the data from udsGetConnectionStatus() was updated internally.
* @return Always true. However if wait=false, this will return false if the event wasn't signaled.
* @param nextEvent Whether to discard the current event and wait for the next event.
* @param wait When true this will not return until the event is signaled. When false this checks if the event was signaled without waiting for it.
*/
udsWaitConnectionStatusEvent :: (nextEvent: bool, wait: bool) -> bool #foreign libctru;

/**
* @brief This loads a NodeInfo struct for the specified NetworkNodeID. The broadcast alias can't be used with this.
* @param NetworkNodeID Target NetworkNodeID.
* @param output Output NodeInfo struct.
*/
udsGetNodeInformation :: (NetworkNodeID: u16, output: *udsNodeInfo) -> Result #foreign libctru;

/// Exclusive states.
ndmExclusiveState :: enum u8 {
    NONE                 :: 0;
    INFRASTRUCTURE       :: 1;
    LOCAL_COMMUNICATIONS :: 2;
    STREETPASS           :: 3;
    STREETPASS_DATA      :: 4;
}

/// Current states.
ndmState :: enum u8 {
    INITIAL                            :: 0;
    SUSPENDED                          :: 1;
    INFRASTRUCTURE_CONNECTING          :: 2;
    INFRASTRUCTURE_CONNECTED           :: 3;
    INFRASTRUCTURE_WORKING             :: 4;
    INFRASTRUCTURE_SUSPENDING          :: 5;
    INFRASTRUCTURE_FORCE_SUSPENDING    :: 6;
    INFRASTRUCTURE_DISCONNECTING       :: 7;
    INFRASTRUCTURE_FORCE_DISCONNECTING :: 8;
    CEC_WORKING                        :: 9;
    CEC_FORCE_SUSPENDING               :: 10;
    CEC_SUSPENDING                     :: 11;
}

// Daemons.
ndmDaemon :: enum u8 {
    CEC     :: 0;
    BOSS    :: 1;
    NIM     :: 2;
    FRIENDS :: 3;
}

/// Used to specify multiple daemons.
ndmDaemonMask :: enum u8 {
    CEC         :: 1;
    BOSS        :: 2;
    NIM         :: 4;
    FRIENDS     :: 8;
    BACKGROUOND :: 7;
    ALL         :: 15;
    DEFAULT     :: 9;
}

// Daemon status.
ndmDaemonStatus :: enum u8 {
    BUSY       :: 0;
    IDLE       :: 1;
    SUSPENDING :: 2;
    SUSPENDED  :: 3;
}

/// Initializes ndmu.
ndmuInit :: () -> Result #foreign libctru;

/// Exits ndmu.
ndmuExit :: () -> void #foreign libctru;

/**
* @brief Sets the network daemon to an exclusive state.
* @param state State specified in the ndmExclusiveState enumerator.
*/
NDMU_EnterExclusiveState :: (state: ndmExclusiveState) -> Result #foreign libctru;

///  Cancels an exclusive state for the network daemon.
NDMU_LeaveExclusiveState :: () -> Result #foreign libctru;

/**
* @brief Returns the exclusive state for the network daemon.
* @param state Pointer to write the exclsuive state to.
*/
NDMU_GetExclusiveState :: (state: *ndmExclusiveState) -> Result #foreign libctru;

///  Locks the exclusive state.
NDMU_LockState :: () -> Result #foreign libctru;

///  Unlocks the exclusive state.
NDMU_UnlockState :: () -> Result #foreign libctru;

/**
* @brief Suspends network daemon.
* @param mask The specified daemon.
*/
NDMU_SuspendDaemons :: (mask: ndmDaemonMask) -> Result #foreign libctru;

/**
* @brief Resumes network daemon.
* @param mask The specified daemon.
*/
NDMU_ResumeDaemons :: (mask: ndmDaemonMask) -> Result #foreign libctru;

/**
* @brief Suspends scheduling for all network daemons.
* @param flag 0 = Wait for completion, 1 = Perform in background.
*/
NDMU_SuspendScheduler :: (flag: u32) -> Result #foreign libctru;

/// Resumes daemon scheduling.
NDMU_ResumeScheduler :: () -> Result #foreign libctru;

/**
* @brief Returns the current state for the network daemon.
* @param state Pointer to write the current state to.
*/
NDMU_GetCurrentState :: (state: *ndmState) -> Result #foreign libctru;

/**
* @brief Returns the daemon state.
* @param state Pointer to write the daemons state to.
*/
NDMU_QueryStatus :: (status: *ndmDaemonStatus) -> Result #foreign libctru;

/**
* @brief Sets the scan interval.
* @param interval Value to set the scan interval to.
*/
NDMU_SetScanInterval :: (interval: u32) -> Result #foreign libctru;

/**
* @brief Returns the scan interval.
* @param interval Pointer to write the interval value to.
*/
NDMU_GetScanInterval :: (interval: *u32) -> Result #foreign libctru;

/**
* @brief Returns the retry interval.
* @param interval Pointer to write the interval value to.
*/
NDMU_GetRetryInterval :: (interval: *u32) -> Result #foreign libctru;

/// Reverts network daemon to defaults.
NDMU_ResetDaemons :: () -> Result #foreign libctru;

/**
* @brief Gets the current default daemon bit mask.
* @param interval Pointer to write the default daemon mask value to. The default value is (DAEMONMASK_CEC | DAEMONMASK_FRIENDS)
*/
NDMU_GetDefaultDaemons :: (mask: *ndmDaemonMask) -> Result #foreign libctru;

///  Clears half awake mac filter.
NDMU_ClearMacFilter :: () -> Result #foreign libctru;

/// Mode that NIM downloads/installs a title with.
NIM_InstallationMode :: enum u8 {
    DEFAULT   :: 0;
    UNKNOWN1  :: 1;
    UNKNOWN2  :: 2;
    REINSTALL :: 3;
}

/// Current state of a NIM download/installation.
NIM_DownloadState :: enum u8 {
    NOT_INITIALIZED   :: 0;
    INITIALIZED       :: 1;
    DOWNLOAD_TMD      :: 2;
    PREPARE_SAVE_DATA :: 3;
    DOWNLOAD_CONTENTS :: 4;
    WAIT_COMMIT       :: 5;
    COMMITTING        :: 6;
    FINISHED          :: 7;
    VERSION_ERROR     :: 8;
    CREATE_CONTEXT    :: 9;
    CANNOT_RECOVER    :: 10;
    INVALID           :: 11;
}

/// Input configuration for NIM download/installation tasks.
NIM_TitleConfig :: struct {
    titleId:   u64; ///< Title ID
    version:   u32; ///< Title version
    unknown_0: u32; ///< Always 0
    ratingAge: u8; ///< Age for the HOME Menu parental controls
    mediaType: u8; ///< Media type, see @ref FS_MediaType enum
    padding:   [2] u8; ///< Padding
    unknown_1: u32; ///< Unknown input, seems to be always 0
}

/// Output struct for NIM downloads/installations in progress.
NIM_TitleProgress :: struct {
    state:          u32; ///< State, see NIM_DownloadState enum
    lastResult:     Result; ///< Last result code in NIM
    downloadedSize: u64; ///< Amount of bytes that have been downloaded
    totalSize:      u64; ///< Amount of bytes that need to be downloaded in total
}

/**
* @brief Initializes nim:s. This uses networking and is blocking.
* @param buffer A buffer for internal use. It must be at least 0x20000 bytes long.
* @param buffer_len Length of the passed buffer.
*/
nimsInit :: (buffer: *void, buffer_len: size_t) -> Result #foreign libctru;

/**
* @brief Initializes nim:s with the given TIN. This uses networking and is blocking.
* @param buffer A buffer for internal use. It must be at least 0x20000 bytes long.
* @param buffer_len Length of the passed buffer.
* @param TIN The TIN to initialize nim:s with. If you do not know what a TIN is or why you would want to change it, use @ref nimsInit instead.
*/
nimsInitWithTIN :: (buffer: *void, buffer_len: size_t, TIN: *u8) -> Result #foreign libctru;

/// Exits nim:s.
nimsExit :: () -> void #foreign libctru;

/// Gets the current nim:s session handle.
nimsGetSessionHandle :: () -> *Handle #foreign libctru;

/**
* @brief Sets an attribute.
* @param attr Name of the attribute.
* @param val Value of the attribute.
*/
NIMS_SetAttribute :: (attr: *u8, val: *u8) -> Result #foreign libctru;

/**
* @brief Checks if nim wants a system update.
* @param want_update Set to true if a system update is required. Can be NULL.
*/
NIMS_WantUpdate :: (want_update: *bool) -> Result #foreign libctru;

/**
* @brief Makes a TitleConfig struct for use with @ref NIMS_RegisterTask, @ref NIMS_StartDownload or @ref NIMS_StartDownloadSimple.
* @param cfg Struct to initialize.
* @param titleId Title ID to download and install.
* @param version Version of the title to download and install.
* @param ratingAge Age for which the title is aged; used by parental controls in HOME Menu.
* @param mediaType Media type of the title to download and install.
*/
NIMS_MakeTitleConfig :: (cfg: *NIM_TitleConfig, titleId: u64, version: u32, ratingAge: u8, mediaType: FS_MediaType) -> void #foreign libctru;

/**
* @brief Registers a background download task with NIM. These are processed in sleep mode only.
* @param cfg Title config to use. See @ref NIMS_MakeTitleConfig.
* @param name Name of the title in UTF-8. Will be displayed on the HOME Menu. Maximum 73 characters.
* @param maker Name of the maker/publisher in UTF-8. Will be displayed on the HOME Menu. Maximum 37 characters.
*/
NIMS_RegisterTask :: (cfg: *NIM_TitleConfig, name: *u8, maker: *u8) -> Result #foreign libctru;

/**
* @brief Checks whether a background download task for the given title is registered with NIM.
* @param titleId Title ID to check for.
* @param registered Whether there is a background download task registered.
*/
NIMS_IsTaskRegistered :: (titleId: u64, registered: *bool) -> Result #foreign libctru;

/**
* @brief Unregisters a background download task.
* @param titleId Title ID whose background download task to cancel.
*/
NIMS_UnregisterTask :: (titleId: u64) -> Result #foreign libctru;

/**
* @brief Starts an active download with NIM. Progress can be checked with @ref NIMS_GetProcess. Do not exit the process while a download is in progress without calling @ref NIMS_CancelDownload.
* @param cfg Title config to use. See @ref NIMS_MakeTitleConfig.
* @param mode The installation mode to use. See @ref NIM_InstallationMode.
*/
NIMS_StartDownload :: (cfg: *NIM_TitleConfig, mode: NIM_InstallationMode) -> Result #foreign libctru;

/**
* @brief Starts an active download with NIM with default installation mode; cannot reinstall titles. Progress can be checked with @ref NIMS_GetProcess. Do not exit the process while a download is in progress without calling @ref NIMS_CancelDownload.
* @param cfg Title config to use. See @ref NIMS_MakeTitleConfig.
*/
NIMS_StartDownloadSimple :: (cfg: *NIM_TitleConfig) -> Result #foreign libctru;

/**
* @brief Checks the status of the current active download.
* @param tp Title progress struct to write to. See @ref NIM_TitleProgress.
*/
NIMS_GetProgress :: (tp: *NIM_TitleProgress) -> Result #foreign libctru;

/**
* @brief Cancels the current active download with NIM.
*/
NIMS_CancelDownload :: () -> Result #foreign libctru;

// Initializes NWMEXT.
nwmExtInit :: () -> Result #foreign libctru;

// Exits NWMEXT.
nwmExtExit :: () -> void #foreign libctru;

/**
* @brief Turns wireless on or off.
* @param enableWifi True enables it, false disables it.
*/
NWMEXT_ControlWirelessEnabled :: (enableWifi: bool) -> Result #foreign libctru;

/**
* @brief Initializes IRU.
* The permissions for the specified memory is set to RO. This memory must be already mapped.
* @param sharedmem_addr Address of the shared memory block to use.
* @param sharedmem_size Size of the shared memory block.
*/
iruInit :: (sharedmem_addr: *u32, sharedmem_size: u32) -> Result #foreign libctru;

/// Shuts down IRU.
iruExit :: () -> void #foreign libctru;

/**
* @brief Gets the IRU service handle.
* @return The IRU service handle.
*/
iruGetServHandle :: () -> Handle #foreign libctru;

/**
* @brief Sends IR data.
* @param buf Buffer to send data from.
* @param size Size of the buffer.
* @param wait Whether to wait for the data to be sent.
*/
iruSendData :: (buf: *u8, size: u32, wait: bool) -> Result #foreign libctru;

/**
* @brief Receives IR data.
* @param buf Buffer to receive data to.
* @param size Size of the buffer.
* @param flag Flags to receive data with.
* @param transfercount Pointer to output the number of bytes read to.
* @param wait Whether to wait for the data to be received.
*/
iruRecvData :: (buf: *u8, size: u32, flag: u8, transfercount: *u32, wait: bool) -> Result #foreign libctru;

/// Initializes the IR session.
IRU_Initialize :: () -> Result #foreign libctru;

/// Shuts down the IR session.
IRU_Shutdown :: () -> Result #foreign libctru;

/**
* @brief Begins sending data.
* @param buf Buffer to send.
* @param size Size of the buffer.
*/
IRU_StartSendTransfer :: (buf: *u8, size: u32) -> Result #foreign libctru;

/// Waits for a send operation to complete.
IRU_WaitSendTransfer :: () -> Result #foreign libctru;

/**
* @brief Begins receiving data.
* @param size Size of the data to receive.
* @param flag Flags to use when receiving.
*/
IRU_StartRecvTransfer :: (size: u32, flag: u8) -> Result #foreign libctru;

/**
* @brief Waits for a receive operation to complete.
* @param transfercount Pointer to output the number of bytes read to.
*/
IRU_WaitRecvTransfer :: (transfercount: *u32) -> Result #foreign libctru;

/**
* @brief Sets the IR bit rate.
* @param value Bit rate to set.
*/
IRU_SetBitRate :: (value: u8) -> Result #foreign libctru;

/**
* @brief Gets the IR bit rate.
* @param out Pointer to write the bit rate to.
*/
IRU_GetBitRate :: (out: *u8) -> Result #foreign libctru;

/**
* @brief Sets the IR LED state.
* @param value IR LED state to set.
*/
IRU_SetIRLEDState :: (value: u32) -> Result #foreign libctru;

/**
* @brief Gets the IR LED state.
* @param out Pointer to write the IR LED state to.
*/
IRU_GetIRLEDRecvState :: (out: *u32) -> Result #foreign libctru;

/// Initializes NS.
nsInit :: () -> Result #foreign libctru;

/// Exits NS.
nsExit :: () -> void #foreign libctru;

/**
* @brief Launches a title and the required firmware (only if necessary).
* @param titleid ID of the title to launch, 0 for gamecard, JPN System Settings' titleID for System Settings.
*/
NS_LaunchFIRM :: (titleid: u64) -> Result #foreign libctru;

/**
* @brief Launches a title.
* @param titleid ID of the title to launch, or 0 for gamecard.
* @param launch_flags Flags used when launching the title.
* @param procid Pointer to write the process ID of the launched title to.
*/
NS_LaunchTitle :: (titleid: u64, launch_flags: u32, procid: *u32) -> Result #foreign libctru;

/// Terminates the application from which this function is called
NS_TerminateTitle :: () -> Result #foreign libctru;

/**
* @brief Launches a title and the required firmware.
* @param titleid ID of the title to launch, 0 for gamecard.
* @param flags Flags for firm-launch. bit0: require an application title-info structure in FIRM paramters to be specified via FIRM parameters. bit1: if clear, NS will check certain Configuration Memory fields.
*/
NS_LaunchApplicationFIRM :: (titleid: u64, flags: u32) -> Result #foreign libctru;

/**
* @brief Reboots to a title.
* @param mediatype Mediatype of the title.
* @param titleid ID of the title to launch.
*/
NS_RebootToTitle :: (mediatype: u8, titleid: u64) -> Result #foreign libctru;

/**
* @brief Terminates the process with the specified titleid.
* @param titleid ID of the title to terminate.
* @param timeout Timeout in nanoseconds. Pass 0 if not required.
*/
NS_TerminateProcessTID :: (titleid: u64, timeout: u64) -> Result #foreign libctru;

/// Reboots the system
NS_RebootSystem :: () -> Result #foreign libctru;

/// Launch flags for PM launch commands.
PMLAUNCHFLAG :: enum u32 {
    NORMAL_APPLICATION            :: 1;
    LOAD_DEPENDENCIES             :: 2;
    NOTIFY_TERMINATION            :: 4;
    QUEUE_DEBUG_APPLICATION       :: 8;
    TERMINATION_NOTIFICATION_MASK :: 240;
    FORCE_USE_O3DS_APP_MEM        :: 256;
    FORCE_USE_O3DS_MAX_APP_MEM    :: 512;
    USE_UPDATE_TITLE              :: 65536;
}

/// Initializes pm:app.
pmAppInit :: () -> Result #foreign libctru;

/// Exits pm:app.
pmAppExit :: () -> void #foreign libctru;

/**
* @brief Gets the current pm:app session handle.
* @return The current pm:app session handle.
*/
pmAppGetSessionHandle :: () -> *Handle #foreign libctru;

/**
* @brief Launches a title.
* @param programInfo Program information of the title.
* @param launchFlags Flags to launch the title with.
*/
PMAPP_LaunchTitle :: (programInfo: *FS_ProgramInfo, launchFlags: u32) -> Result #foreign libctru;

/**
* @brief Launches a title, applying patches.
* @param programInfo Program information of the title.
* @param programInfoUpdate Program information of the update title.
* @param launchFlags Flags to launch the title with.
*/
PMAPP_LaunchTitleUpdate :: (programInfo: *FS_ProgramInfo, programInfoUpdate: *FS_ProgramInfo, launchFlags: u32) -> Result #foreign libctru;

/**
* @brief Gets a title's ExHeader Arm11CoreInfo and SystemInfo flags.
* @param[out] outCoreInfo Pointer to write the ExHeader Arm11CoreInfo to.
* @param[out] outSiFlags Pointer to write the ExHeader SystemInfo flags to.
* @param programInfo Program information of the title.
*/
PMAPP_GetTitleExheaderFlags :: (outCoreInfo: *ExHeader_Arm11CoreInfo, outSiFlags: *ExHeader_SystemInfoFlags, programInfo: *FS_ProgramInfo) -> Result #foreign libctru;

/**
* @brief Sets the current FIRM launch parameters.
* @param size Size of the FIRM launch parameter buffer.
* @param in Buffer to retrieve the launch parameters from.
*/
PMAPP_SetFIRMLaunchParams :: (size: u32, in: *void) -> Result #foreign libctru;

/**
* @brief Gets the current FIRM launch parameters.
* @param size Size of the FIRM launch parameter buffer.
* @param[out] out Buffer to write the launch parameters to.
*/
PMAPP_GetFIRMLaunchParams :: (out: *void, size: u32) -> Result #foreign libctru;

/**
* @brief Sets the current FIRM launch parameters.
* @param firmTidLow Low Title ID of the FIRM title to launch.
* @param size Size of the FIRM launch parameter buffer.
* @param in Buffer to retrieve the launch parameters from.
*/
PMAPP_LaunchFIRMSetParams :: (firmTidLow: u32, size: u32, in: *void) -> Result #foreign libctru;

/**
* @brief Terminate most processes, to prepare for a reboot or a shutdown.
* @param timeout Time limit in ns for process termination, after which the remaining processes are killed.
*/
PMAPP_PrepareForReboot :: (timeout: s64) -> Result #foreign libctru;

/**
* @brief Terminates the current Application
* @param timeout Timeout in nanoseconds
*/
PMAPP_TerminateCurrentApplication :: (timeout: s64) -> Result #foreign libctru;

/**
* @brief Terminates the processes having the specified titleId.
* @param titleId Title ID of the processes to terminate
* @param timeout Timeout in nanoseconds
*/
PMAPP_TerminateTitle :: (titleId: u64, timeout: s64) -> Result #foreign libctru;

/**
* @brief Terminates the specified process
* @param pid Process-ID of the process to terminate
* @param timeout Timeout in nanoseconds
*/
PMAPP_TerminateProcess :: (pid: u32, timeout: s64) -> Result #foreign libctru;

/**
* @brief Unregisters a process
* @param tid TitleID of the process to unregister
*/
PMAPP_UnregisterProcess :: (tid: u64) -> Result #foreign libctru;

/**
* @brief Sets the APPLICATION cputime reslimit.
* @param cpuTime Reslimit value.
* @note cpuTime can be no higher than reslimitdesc[0] & 0x7F in exheader (or 80 if the latter is 0).
*/
PMAPP_SetAppResourceLimit :: (cpuTime: s64) -> Result #foreign libctru;

/**
* @brief Gets the APPLICATION cputime reslimit.
* @param[out] cpuTime Pointer to write the reslimit value to.
*/
PMAPP_GetAppResourceLimit :: (outCpuTime: *s64) -> Result #foreign libctru;

/// Initializes pm:dbg.
pmDbgInit :: () -> Result #foreign libctru;

/// Exits pm:dbg.
pmDbgExit :: () -> void #foreign libctru;

/**
* @brief Gets the current pm:dbg session handle.
* @return The current pm:dbg session handle.
*/
pmDbgGetSessionHandle :: () -> *Handle #foreign libctru;

/**
* @brief Enqueues an application for debug after setting cpuTime to 0, and returns a debug handle to it.
* If another process was enqueued, this just calls @ref RunQueuedProcess instead.
* @param[out] Pointer to output the debug handle to.
* @param programInfo Program information of the title.
* @param launchFlags Flags to launch the title with.
*/
PMDBG_LaunchAppDebug :: (outDebug: *Handle, programInfo: *FS_ProgramInfo, launchFlags: u32) -> Result #foreign libctru;

/**
* @brief Launches an application for debug after setting cpuTime to 0.
* @param programInfo Program information of the title.
* @param launchFlags Flags to launch the title with.
*/
PMDBG_LaunchApp :: (programInfo: *FS_ProgramInfo, launchFlags: u32) -> Result #foreign libctru;

/**
* @brief Runs the queued process and returns a debug handle to it.
* @param[out] Pointer to output the debug handle to.
*/
PMDBG_RunQueuedProcess :: (outDebug: *Handle) -> Result #foreign libctru;

/// PS AES algorithms.
PS_AESAlgorithm :: enum u8 {
    BC_ENC :: 0;
    BC_DEC :: 1;
    TR_ENC :: 2;
    TR_DEC :: 3;
    CM_ENC :: 4;
    CM_DEC :: 5;
}

/// PS key slots.
PS_AESKeyType :: enum u8 {
    _0D     :: 0;
    _2D     :: 1;
    _31     :: 2;
    _38     :: 3;
    _32     :: 4;
    _39_DLP :: 5;
    _2E     :: 6;
    INVALID :: 7;
    _36     :: 8;
    _39_NFC :: 9;
}

/// RSA context.
psRSAContext :: struct {
    modulo:      [256] u8;
    exponent:    [256] u8;
    rsa_bitsize: u32; //The signature byte size is rsa_bitsize>>3.
    unk:         u32; //Normally zero?
}

/// Initializes PS.
psInit :: () -> Result #foreign libctru;

/**
* @brief Initializes PS with the specified session handle.
* @param handle Session handle.
*/
psInitHandle :: (handle: Handle) -> Result #foreign libctru;

/// Exits PS.
psExit :: () -> void #foreign libctru;

/// Returns the PS session handle.
psGetSessionHandle :: () -> Handle #foreign libctru;

/**
* @brief Signs a RSA signature.
* @param hash SHA256 hash to sign.
* @param ctx RSA context.
* @param signature RSA signature.
*/
PS_SignRsaSha256 :: (hash: *u8, ctx: *psRSAContext, signature: *u8) -> Result #foreign libctru;

/**
* @brief Verifies a RSA signature.
* @param hash SHA256 hash to compare with.
* @param ctx RSA context.
* @param signature RSA signature.
*/
PS_VerifyRsaSha256 :: (hash: *u8, ctx: *psRSAContext, signature: *u8) -> Result #foreign libctru;

/**
* @brief Encrypts/Decrypts AES data. Does not support AES CCM.
* @param size Size of the data.
* @param in Input buffer.
* @param out Output buffer.
* @param aes_algo AES algorithm to use.
* @param key_type Key type to use.
* @param iv Pointer to the CTR/IV. The output CTR/IV is also written here.
*/
PS_EncryptDecryptAes :: (size: u32, in: *u8, out: *u8, aes_algo: PS_AESAlgorithm, key_type: PS_AESKeyType, iv: *u8) -> Result #foreign libctru;

/**
* @brief Encrypts/Decrypts signed AES CCM data.
* When decrypting, if the MAC is invalid, 0xC9010401 is returned. After encrypting the MAC is located at inputbufptr.
* @param in Input buffer.
* @param in_size Size of the input buffer. Must include MAC size when decrypting.
* @param out Output buffer.
* @param out_size Size of the output buffer. Must include MAC size when encrypting.
* @param data_len Length of the data to be encrypted/decrypted.
* @param mac_data_len Length of the MAC data.
* @param mac_len Length of the MAC.
* @param aes_algo AES algorithm to use.
* @param key_type Key type to use.
* @param nonce Pointer to the nonce.
*/
PS_EncryptSignDecryptVerifyAesCcm :: (in: *u8, in_size: u32, out: *u8, out_size: u32, data_len: u32, mac_data_len: u32, mac_len: u32, aes_algo: PS_AESAlgorithm, key_type: PS_AESKeyType, nonce: *u8) -> Result #foreign libctru;

/**
* @brief Gets the 64-bit console friend code seed.
* @param seed Pointer to write the friend code seed to.
*/
PS_GetLocalFriendCodeSeed :: (seed: *u64) -> Result #foreign libctru;

/**
* @brief Gets the 32-bit device ID.
* @param device_id Pointer to write the device ID to.
*/
PS_GetDeviceId :: (device_id: *u32) -> Result #foreign libctru;

/**
* @brief Generates cryptographically secure random bytes.
* @param out Pointer to the buffer to write the bytes to.
* @param len Number of bytes to write.
*/
PS_GenerateRandomBytes :: (out: *void, len: size_t) -> Result #foreign libctru;

/// Initializes PTMU.
ptmuInit :: () -> Result #foreign libctru;

/// Exits PTMU.
ptmuExit :: () -> void #foreign libctru;

/**
* @brief Gets a pointer to the current ptm:u session handle.
* @return A pointer to the current ptm:u session handle.
*/
ptmuGetSessionHandle :: () -> *Handle #foreign libctru;

/**
* @brief Gets the system's current shell state.
* @param out Pointer to write the current shell state to. (0 = closed, 1 = open)
*/
PTMU_GetShellState :: (out: *u8) -> Result #foreign libctru;

/**
* @brief Gets the system's current battery level.
* @param out Pointer to write the current battery level to. (0-5)
*/
PTMU_GetBatteryLevel :: (out: *u8) -> Result #foreign libctru;

/**
* @brief Gets the system's current battery charge state.
* @param out Pointer to write the current battery charge state to. (0 = not charging, 1 = charging)
*/
PTMU_GetBatteryChargeState :: (out: *u8) -> Result #foreign libctru;

/**
* @brief Gets the system's current pedometer state.
* @param out Pointer to write the current pedometer state to. (0 = not counting, 1 = counting)
*/
PTMU_GetPedometerState :: (out: *u8) -> Result #foreign libctru;

/**
* @brief Gets the pedometer's total step count.
* @param steps Pointer to write the total step count to.
*/
PTMU_GetTotalStepCount :: (steps: *u32) -> Result #foreign libctru;

/**
* @brief Gets whether the adapter is plugged in or not
* @param out Pointer to write the adapter state to.
*/
PTMU_GetAdapterState :: (out: *bool) -> Result #foreign libctru;

/// PDN wake events and MCU interrupts to select, combined with those of other processes
PtmWakeEvents :: struct {
    pdn_wake_events:   u32; ///< Written to PDN_WAKE_EVENTS. Don't select bit26 (MCU), PTM will do it automatically.
    mcu_interupt_mask: u32; ///< MCU interrupts to check when a MCU wake event happens.
}

PtmSleepConfig :: struct {
    exit_sleep_events:     PtmWakeEvents; ///< Wake events for which the system should fully wake up.
    continue_sleep_events: PtmWakeEvents; ///< Wake events for which the system should return to sleep.
}

PTMNOTIFID :: enum u16 {
    SLEEP_REQUESTED  :: 257;
    SLEEP_DENIED     :: 258;
    SLEEP_ALLOWED    :: 259;
    GOING_TO_SLEEP   :: 260;
    FULLY_WAKING_UP  :: 261;
    FULLY_AWAKE      :: 262;
    HALF_AWAKE       :: 263;
    SHUTDOWN         :: 264;
    BATTERY_VERY_LOW :: 529;
    BATTERY_LOW      :: 530;
}

/// Initializes ptm:sysm.
ptmSysmInit :: () -> Result #foreign libctru;

/// Exits ptm:sysm.
ptmSysmExit :: () -> void #foreign libctru;

/**
* @brief Gets a pointer to the current ptm:sysm session handle.
* @return A pointer to the current ptm:sysm session handle.
*/
ptmSysmGetSessionHandle :: () -> *Handle #foreign libctru;

/// Requests to enter sleep mode.
PTMSYSM_RequestSleep :: () -> Result #foreign libctru;

/**
* @brief Accepts or denies the incoming sleep mode request.
* @param deny Whether or not to deny the sleep request.
* @note If deny = false, this is equivalent to calling @ref PTMSYSM_NotifySleepPreparationComplete(3)
*/
PTMSYSM_ReplyToSleepQuery :: (deny: bool) -> Result #foreign libctru;

/**
* @brief Acknowledges the current sleep notification and advance the internal sleep mode FSM. All subscribers must reply.
* @param ackValue Use @ref ptmSysmGetNotificationAckValue
* @note @ref PTMNOTIFID_SLEEP_DENIED and @ref PTMNOTIFID_FULLY_AWAKE don't require this.
*/
PTMSYSM_NotifySleepPreparationComplete :: (ackValue: s32) -> Result #foreign libctru;

/**
* @brief Sets the wake events (two sets: when to fully wake up and when to return to sleep).
* @param sleepConfig Pointer to the two sets of wake events.
* @note Can only be called just before acknowledging @ref PTMNOTIFID_GOING_TO_SLEEP or @ref PTMNOTIFID_HALF_AWAKE.
*/
PTMSYSM_SetWakeEvents :: (sleepConfig: *PtmSleepConfig) -> Result #foreign libctru;

/**
* @brief Gets the wake reason (only the first applicable wake event is taken into account).
* @param sleepConfig Pointer to the two sets of wake events. Only the relevant set will be filled.
*/
PTMSYSM_GetWakeReason :: (outSleepConfig: *PtmSleepConfig) -> Result #foreign libctru;

/// Cancels the "half-awake" state and fully wakes up the 3DS after some delay.
PTMSYSM_Awaken :: () -> Result #foreign libctru;

/**
* @brief Sets the user time by updating the user time offset.
* @param msY2k The number of milliseconds since 01/01/2000.
*/
PTMSYSM_SetUserTime :: (msY2k: s64) -> Result #foreign libctru;

/// Invalidates the "system time" (cfg block 0x30002)
PTMSYSM_InvalidateSystemTime :: () -> Result #foreign libctru;

/**
* @brief Reads the time and date coming from the RTC and converts the result.
* @param[out] outMsY2k The pointer to write the number of milliseconds since 01/01/2000 to.
*/
PTMSYSM_GetRtcTime :: (outMsY2k: *s64) -> Result #foreign libctru;

/**
* @brief Writes the time and date coming to the RTC, after conversion.
* @param msY2k The number of milliseconds since 01/01/2000.
*/
PTMSYSM_SetRtcTime :: (msY2k: s64) -> Result #foreign libctru;

/**
* @brief Returns 1 if it's a New 3DS, otherwise 0.
*/
PTMSYSM_CheckNew3DS :: () -> Result #foreign libctru;

/**
* @brief Configures the New 3DS' CPU clock speed and L2 cache.
* @param value Bit0: enable higher clock, Bit1: enable L2 cache.
*/
PTMSYSM_ConfigureNew3DSCPU :: (value: u8) -> Result #foreign libctru;

/**
* @brief Trigger a hardware system shutdown via the MCU.
* @param timeout: timeout passed to PMApp:ShutdownAsync (PrepareForReboot).
*/
PTMSYSM_ShutdownAsync :: (timeout: u64) -> Result #foreign libctru;

/**
* @brief Trigger a hardware system reboot via the MCU.
* @param timeout: timeout passed to PMApp:ShutdownAsync (PrepareForReboot).
*/
PTMSYSM_RebootAsync :: (timeout: u64) -> Result #foreign libctru;

/// Initializes PTMGETS.
ptmGetsInit :: () -> Result #foreign libctru;

/// Exits PTMGETS.
ptmGetsExit :: () -> void #foreign libctru;

/**
* @brief Gets a pointer to the current ptm:gets session handle.
* @return A pointer to the current ptm:gets session handle.
*/
ptmGetsGetSessionHandle :: () -> *Handle #foreign libctru;

/**
* @brief Gets the system time.
* @param[out] outMsY2k The pointer to write the number of milliseconds since 01/01/2000 to.
*/
PTMGETS_GetSystemTime :: (outMsY2k: *s64) -> Result #foreign libctru;

/// Initializes PTMSETS.
ptmSetsInit :: () -> Result #foreign libctru;

/// Exits PTMSETS.
ptmSetsExit :: () -> void #foreign libctru;

/**
* @brief Gets a pointer to the current ptm:sets session handle.
* @return A pointer to the current ptm:sets session handle.
*/
ptmSetsGetSessionHandle :: () -> *Handle #foreign libctru;

/**
* @brief Sets the system time.
* @param msY2k The number of milliseconds since 01/01/2000.
*/
PTMSETS_SetSystemTime :: (msY2k: s64) -> Result #foreign libctru;

/// Card SPI wait operation type.
PXIDEV_WaitType :: enum u8 {
    NONE          :: 0;
    SLEEP         :: 1;
    IREQ_RETURN   :: 2;
    IREQ_CONTINUE :: 3;
}

/// Card SPI register deassertion type.
PXIDEV_DeassertType :: enum u8 {
    NONE        :: 0;
    BEFORE_WAIT :: 1;
    AFTER_WAIT  :: 2;
}

/// Card SPI transfer buffer.
PXIDEV_SPIBuffer :: struct {
    ptr:            *void; ///< Data pointer.
    size:           u32; ///< Data size.
    transferOption: u8; ///< Transfer options. See @ref pxiDevMakeTransferOption
    waitOperation:  u64; ///< Wait operation. See @ref pxiDevMakeWaitOperation
}

/// Initializes pxi:dev.
pxiDevInit :: () -> Result #foreign libctru;

/// Shuts down pxi:dev.
pxiDevExit :: () -> void #foreign libctru;

/**
* @brief Performs multiple card SPI writes and reads.
* @param header Header to lead the transfers with. Must be, at most, 8 bytes in size.
* @param writeBuffer1 Buffer to make first transfer from.
* @param readBuffer1 Buffer to receive first response to.
* @param writeBuffer2 Buffer to make second transfer from.
* @param readBuffer2 Buffer to receive second response to.
* @param footer Footer to follow the transfers with. Must be, at most, 8 bytes in size. Wait operation is unused.
*/
PXIDEV_SPIMultiWriteRead :: (header: *PXIDEV_SPIBuffer, writeBuffer1: *PXIDEV_SPIBuffer, readBuffer1: *PXIDEV_SPIBuffer, writeBuffer2: *PXIDEV_SPIBuffer, readBuffer2: *PXIDEV_SPIBuffer, footer: *PXIDEV_SPIBuffer) -> Result #foreign libctru;

/**
* @brief Performs a single card SPI write and read.
* @param bytesRead Pointer to output the number of bytes received to.
* @param initialWaitOperation Wait operation to perform before transferring data.
* @param writeBuffer Buffer to transfer data from.
* @param readBuffer Buffer to receive data to.
*/
PXIDEV_SPIWriteRead :: (bytesRead: *u32, initialWaitOperation: u64, writeBuffer: *PXIDEV_SPIBuffer, readBuffer: *PXIDEV_SPIBuffer) -> Result #foreign libctru;

/// Initializes PxiPM.
pxiPmInit :: () -> Result #foreign libctru;

/// Exits PxiPM.
pxiPmExit :: () -> void #foreign libctru;

/**
* @brief Gets the current PxiPM session handle.
* @return The current PxiPM session handle.
*/
pxiPmGetSessionHandle :: () -> *Handle #foreign libctru;

/**
* @brief Retrives the exheader information set(s) (SCI+ACI) about a program.
* @param exheaderInfos[out] Pointer to the output exheader information set.
* @param programHandle The program handle.
*/
PXIPM_GetProgramInfo :: (exheaderInfo: *ExHeader_Info, programHandle: u64) -> Result #foreign libctru;

/**
* @brief Loads a program and registers it to Process9.
* @param programHandle[out] Pointer to the output the program handle to.
* @param programInfo Information about the program to load.
* @param updateInfo Information about the program update to load.
*/
PXIPM_RegisterProgram :: (programHandle: *u64, programInfo: *FS_ProgramInfo, updateInfo: *FS_ProgramInfo) -> Result #foreign libctru;

/**
* @brief Unloads a program and unregisters it from Process9.
* @param programHandle The program handle.
*/
PXIPM_UnregisterProgram :: (programHandle: u64) -> Result #foreign libctru;

socklen_t :: u32;
sa_family_t :: u16;

sockaddr :: struct {
    sa_family: sa_family_t;
    sa_data:   *u8;
}

// biggest size on 3ds is 0x1C (sockaddr_in6)
sockaddr_storage :: struct {
    ss_family:    sa_family_t;
    __ss_padding: [26] u8;
}

linger :: struct {
    l_onoff:  s32;
    l_linger: s32;
}

accept :: (sockfd: s32, addr: *sockaddr, addrlen: *socklen_t) -> s32 #foreign libctru;
bind :: (sockfd: s32, addr: *sockaddr, addrlen: socklen_t) -> s32 #foreign libctru;
closesocket :: (sockfd: s32) -> s32 #foreign libctru;
connect :: (sockfd: s32, addr: *sockaddr, addrlen: socklen_t) -> s32 #foreign libctru;
getpeername :: (sockfd: s32, addr: *sockaddr, addrlen: *socklen_t) -> s32 #foreign libctru;
getsockname :: (sockfd: s32, addr: *sockaddr, addrlen: *socklen_t) -> s32 #foreign libctru;
getsockopt :: (sockfd: s32, level: s32, optname: s32, optval: *void, optlen: *socklen_t) -> s32 #foreign libctru;
listen :: (sockfd: s32, backlog: s32) -> s32 #foreign libctru;
recv :: (sockfd: s32, buf: *void, len: size_t, flags: s32) -> ssize_t #foreign libctru;
recvfrom :: (sockfd: s32, buf: *void, len: size_t, flags: s32, src_addr: *sockaddr, addrlen: *socklen_t) -> ssize_t #foreign libctru;
send :: (sockfd: s32, buf: *void, len: size_t, flags: s32) -> ssize_t #foreign libctru;
sendto :: (sockfd: s32, buf: *void, len: size_t, flags: s32, dest_addr: *sockaddr, addrlen: socklen_t) -> ssize_t #foreign libctru;
setsockopt :: (sockfd: s32, level: s32, optname: s32, optval: *void, optlen: socklen_t) -> s32 #foreign libctru;
shutdown :: (sockfd: s32, how: s32) -> s32 #foreign libctru;
socket :: (domain: s32, type: s32, protocol: s32) -> s32 #foreign libctru;
sockatmark :: (sockfd: s32) -> s32 #foreign libctru;

in_addr :: struct {
    s_addr: in_addr_t;
}

sockaddr_in :: struct {
    sin_family: sa_family_t;
    sin_port:   in_port_t;
    sin_addr:   in_addr;
    sin_zero:   [8] u8;
}

/* Request struct for multicast socket ops */
ip_mreq :: struct {
    imr_multiaddr: in_addr; /* IP multicast address of group */
    imr_interface: in_addr; /* local IP address of interface */
}

/// Options to be used with @ref SOCU_GetNetworkOpt
NetworkOpt :: enum u16 {
    MAC_ADDRESS     :: 4100;
    ARP_TABLE       :: 12290;
    IP_INFO         :: 16387;
    IP_MTU          :: 16388;
    ROUTING_TABLE   :: 16390;
    UDP_NUMBER      :: 32770;
    UDP_TABLE       :: 32771;
    TCP_NUMBER      :: 36866;
    TCP_TABLE       :: 36867;
    DNS_TABLE       :: 45059;
    DHCP_LEASE_TIME :: 49153;
}

/// One entry of the ARP table retrieved by using @ref SOCU_GetNetworkOpt and @ref NETOPT_ARP_TABLE
SOCU_ARPTableEntry :: struct {
    unk0:    u32; // often 2 ? state ?
    ip:      in_addr; ///< The IPv4 address associated to the entry
    mac:     [6] u8; ///< The MAC address of associated to the entry
    padding: [2] u8;
}

/// Structure returned by @ref SOCU_GetNetworkOpt when using @ref NETOPT_IP_INFO
SOCU_IPInfo :: struct {
    ip:        in_addr; ///< Current IPv4 address
    netmask:   in_addr; ///< Current network mask
    broadcast: in_addr; ///< Current network broadcast address
}

/// One entry of the routing table retrieved by using @ref SOCU_GetNetworkOpt and @ref NETOPT_ROUTING_TABLE
SOCU_RoutingTableEntry :: struct {
    dest_ip: in_addr; ///< Destination IP address of the route
    netmask: in_addr; ///< Mask used for this route
    gateway: in_addr; ///< Gateway address to reach the network
    flags:   u32; ///< Linux netstat flags @see ROUTING_FLAG_G
    time:    u64; ///< number of milliseconds since 1st Jan 1900 00:00.
}

/// One entry of the UDP sockets table retrieved by using @ref SOCU_GetNetworkOpt and @ref NETOPT_UDP_TABLE
SOCU_UDPTableEntry :: struct {
    local:  sockaddr_storage; ///< Local address information
    remote: sockaddr_storage; ///< Remote address information
}

/// One entry of the TCP sockets table retrieved by using @ref SOCU_GetNetworkOpt and @ref NETOPT_TCP_TABLE
SOCU_TCPTableEntry :: struct {
    state:  u32; ///< @see TCP states defines
    local:  sockaddr_storage; ///< Local address information
    remote: sockaddr_storage; ///< Remote address information
}

/// One entry of the DNS servers table retrieved by using @ref SOCU_GetNetworkOpt and @ref NETOPT_DNS_TABLE
SOCU_DNSTableEntry :: struct {
    family:  u32;
    /// Family of the address of the DNS server
    ip:      in_addr;
    padding: [12] u8; // matches the length required for IPv6 addresses
}

/**
* @brief Initializes the SOC service.
* @param context_addr Address of a page-aligned (0x1000) buffer to be used.
* @param context_size Size of the buffer, a multiple of 0x1000.
* @note The specified context buffer can no longer be accessed by the process which called this function, since the userland permissions for this block are set to no-access.
*/
socInit :: (context_addr: *u32, context_size: u32) -> Result #foreign libctru;

/**
* @brief Closes the soc service.
* @note You need to call this in order to be able to use the buffer again.
*/
socExit :: () -> Result #foreign libctru;

// this is supposed to be in unistd.h but newlib only puts it for cygwin, waiting for newlib patch from dkA
/**
* @brief Gets the system's host ID.
* @return The system's host ID.
*/
gethostid :: () -> s32 #foreign libctru;

// this is supposed to be in unistd.h but newlib only puts it for cygwin, waiting for newlib patch from dkA
gethostname :: (name: *u8, namelen: size_t) -> s32 #foreign libctru;

SOCU_ShutdownSockets :: () -> s32 #foreign libctru;

SOCU_CloseSockets :: () -> s32 #foreign libctru;

/**
* @brief Retrieves information from the network configuration. Similar to getsockopt().
* @param level   Only value allowed seems to be @ref SOL_CONFIG
* @param optname The option to be retrieved
* @param optval  Will contain the output of the command
* @param optlen  Size of the optval buffer, will be updated to hold the size of the output
* @return 0 if successful. -1 if failed, and errno will be set accordingly. Can also return a system error code.
*/
SOCU_GetNetworkOpt :: (level: s32, optname: NetworkOpt, optval: *void, optlen: *socklen_t) -> s32 #foreign libctru;

/**
* @brief Gets the system's IP address, netmask, and subnet broadcast
* @return error
*/
SOCU_GetIPInfo :: (ip: *in_addr, netmask: *in_addr, broadcast: *in_addr) -> s32 #foreign libctru;

/**
* @brief Adds a global socket.
* @param sockfd   The socket fd.
* @return error
*/
SOCU_AddGlobalSocket :: (sockfd: s32) -> s32 #foreign libctru;

/// Microphone audio encodings.
MICU_Encoding :: enum u8 {
    _8         :: 0;
    _16        :: 1;
    _8_SIGNED  :: 2;
    _16_SIGNED :: 3;
}

/// Microphone audio sampling rates.
MICU_SampleRate :: enum u8 {
    _32730 :: 0;
    _16360 :: 1;
    _10910 :: 2;
    _8180  :: 3;
}

/**
* @brief Initializes MIC.
* @param size Shared memory buffer to write audio data to. Must be aligned to 0x1000 bytes.
* @param handle Size of the shared memory buffer.
*/
micInit :: (buffer: *u8, bufferSize: u32) -> Result #foreign libctru;

/// Exits MIC.
micExit :: () -> void #foreign libctru;

/**
* @brief Gets the size of the sample data area within the shared memory buffer.
* @return The sample data's size.
*/
micGetSampleDataSize :: () -> u32 #foreign libctru;

/**
* @brief Gets the offset within the shared memory buffer of the last sample written.
* @return The last sample's offset.
*/
micGetLastSampleOffset :: () -> u32 #foreign libctru;

/**
* @brief Maps MIC shared memory.
* @param size Size of the shared memory.
* @param handle Handle of the shared memory.
*/
MICU_MapSharedMem :: (size: u32, handle: Handle) -> Result #foreign libctru;

/// Unmaps MIC shared memory.
MICU_UnmapSharedMem :: () -> Result #foreign libctru;

/**
* @brief Begins sampling microphone input.
* @param encoding Encoding of outputted audio.
* @param sampleRate Sample rate of outputted audio.
* @param sharedMemAudioOffset Offset to write audio data to in the shared memory buffer.
* @param sharedMemAudioSize Size of audio data to write to the shared memory buffer. This should be at most "bufferSize - 4".
* @param loop Whether to loop back to the beginning of the buffer when the end is reached.
*/
MICU_StartSampling :: (encoding: MICU_Encoding, sampleRate: MICU_SampleRate, offset: u32, size: u32, loop: bool) -> Result #foreign libctru;

/**
* @brief Adjusts the configuration of the current sampling session.
* @param sampleRate Sample rate of outputted audio.
*/
MICU_AdjustSampling :: (sampleRate: MICU_SampleRate) -> Result #foreign libctru;

/// Stops sampling microphone input.
MICU_StopSampling :: () -> Result #foreign libctru;

/**
* @brief Gets whether microphone input is currently being sampled.
* @param sampling Pointer to output the sampling state to.
*/
MICU_IsSampling :: (sampling: *bool) -> Result #foreign libctru;

/**
* @brief Gets an event handle triggered when the shared memory buffer is full.
* @param handle Pointer to output the event handle to.
*/
MICU_GetEventHandle :: (handle: *Handle) -> Result #foreign libctru;

/**
* @brief Sets the microphone's gain.
* @param gain Gain to set.
*/
MICU_SetGain :: (gain: u8) -> Result #foreign libctru;

/**
* @brief Gets the microphone's gain.
* @param gain Pointer to output the current gain to.
*/
MICU_GetGain :: (gain: *u8) -> Result #foreign libctru;

/**
* @brief Sets whether the microphone is powered on.
* @param power Whether the microphone is powered on.
*/
MICU_SetPower :: (power: bool) -> Result #foreign libctru;

/**
* @brief Gets whether the microphone is powered on.
* @param power Pointer to output the power state to.
*/
MICU_GetPower :: (power: *bool) -> Result #foreign libctru;

/**
* @brief Sets whether to clamp microphone input.
* @param clamp Whether to clamp microphone input.
*/
MICU_SetClamp :: (clamp: bool) -> Result #foreign libctru;

/**
* @brief Gets whether to clamp microphone input.
* @param clamp Pointer to output the clamp state to.
*/
MICU_GetClamp :: (clamp: *bool) -> Result #foreign libctru;

/**
* @brief Sets whether to allow sampling when the shell is closed.
* @param allowShellClosed Whether to allow sampling when the shell is closed.
*/
MICU_SetAllowShellClosed :: (allowShellClosed: bool) -> Result #foreign libctru;

/// Processing mode.
MVDSTD_Mode :: enum u8 {
    COLORFORMATCONV :: 0;
    VIDEOPROCESSING :: 1;
}

/// Input format.
MVDSTD_InputFormat :: enum u32 {
    YUYV422 :: 65537;
    H264    :: 131073;
}

/// Output format.
MVDSTD_OutputFormat :: enum u32 {
    YUYV422 :: 65537;
    BGR565  :: 262146;
    RGB565  :: 262148;
}

/// Processing configuration.
MVDSTD_Config :: struct {
    input_type:                MVDSTD_InputFormat; ///< Input type.
    unk_x04:                   u32; ///< Unknown.
    unk_x08:                   u32; ///< Unknown. Referred to as "H264 range" in SKATER.
    inwidth:                   u32; ///< Input width.
    inheight:                  u32; ///< Input height.
    physaddr_colorconv_indata: u32; ///< Physical address of color conversion input data.
    physaddr_colorconv_unk0:   u32; ///< Physical address used with color conversion.
    physaddr_colorconv_unk1:   u32; ///< Physical address used with color conversion.
    physaddr_colorconv_unk2:   u32; ///< Physical address used with color conversion.
    physaddr_colorconv_unk3:   u32; ///< Physical address used with color conversion.
    unk_x28:                   [6] u32; ///< Unknown.
    enable_cropping:           u32; ///< Enables cropping with the input image when non-zero via the following 4 words.
    input_crop_x_pos:          u32;
    input_crop_y_pos:          u32;
    input_crop_height:         u32;
    input_crop_width:          u32;
    unk_x54:                   u32; ///< Unknown.
    output_type:               MVDSTD_OutputFormat; ///< Output type.
    outwidth:                  u32; ///< Output width.
    outheight:                 u32; ///< Output height.
    physaddr_outdata0:         u32; ///< Physical address of output data.
    physaddr_outdata1:         u32; ///< Additional physical address for output data, only used when the output format type is value 0x00020001.
    unk_x6c:                   [38] u32; ///< Unknown.
    flag_x104:                 u32; ///< This enables using the following 4 words when non-zero.
    output_x_pos:              u32; ///< Output X position in the output buffer.
    output_y_pos:              u32; ///< Same as above except for the Y pos.
    output_width_override:     u32; ///< Used for aligning the output width when larger than the output width. Overrides the output width when smaller than the output width.
    output_height_override:    u32; ///< Same as output_width_override except for the output height.
    unk_x118:                  u32;
}

MVDSTD_ProcessNALUnitOut :: struct {
    end_vaddr:      u32; //"End-address of the processed NAL-unit(internal MVD heap vaddr)."
    end_physaddr:   u32; //"End-address of the processed NAL-unit(physaddr following the input physaddr)."
    remaining_size: u32; //"Total remaining unprocessed input data. Buffer_end_pos=bufsize-<this value>."
}

MVDSTD_OutputBuffersEntry :: struct {
    outdata0: *void; //Linearmem vaddr equivalent to config *_outdata0.
    outdata1: *void #align 4; //Linearmem vaddr equivalent to config *_outdata1.
}

MVDSTD_OutputBuffersEntryList :: struct {
    total_entries: u32; //Total actual used entries below.
    entries:       [17] MVDSTD_OutputBuffersEntry #align 4;
}

/// This can be used to override the default input values for MVDSTD commands during initialization with video-processing. The default for these fields are all-zero, except for cmd1b_inval which is 1. See also here: https://www.3dbrew.org/wiki/MVD_Services
MVDSTD_InitStruct :: struct {
    cmd5_inval0: s8;
    cmd5_inval1: s8;
    cmd5_inval2: s8;
    cmd5_inval3: u32;
    cmd1b_inval: u8;
}

/**
* @brief Initializes MVDSTD.
* @param mode Mode to initialize MVDSTD to.
* @param input_type Type of input to process.
* @param output_type Type of output to produce.
* @param size Size of the work buffer, MVD_DEFAULT_WORKBUF_SIZE can be used for this. Only used when type == MVDMODE_VIDEOPROCESSING.
* @param initstruct Optional MVDSTD_InitStruct, this should be NULL normally.
*/
mvdstdInit :: (mode: MVDSTD_Mode, input_type: MVDSTD_InputFormat, output_type: MVDSTD_OutputFormat, size: u32, initstruct: *MVDSTD_InitStruct) -> Result #foreign libctru;

/// Shuts down MVDSTD.
mvdstdExit :: () -> void #foreign libctru;

/**
* @brief Generates a default MVDSTD configuration.
* @param config Pointer to output the generated config to.
* @param input_width Input width.
* @param input_height Input height.
* @param output_width Output width.
* @param output_height Output height.
* @param vaddr_colorconv_indata Virtual address of the color conversion input data.
* @param vaddr_outdata0 Virtual address of the output data.
* @param vaddr_outdata1 Additional virtual address for output data, only used when the output format type is value 0x00020001.
*/
mvdstdGenerateDefaultConfig :: (config: *MVDSTD_Config, input_width: u32, input_height: u32, output_width: u32, output_height: u32, vaddr_colorconv_indata: *u32, vaddr_outdata0: *u32, vaddr_outdata1: *u32) -> void #foreign libctru;

/**
* @brief Run color-format-conversion.
* @param config Pointer to the configuration to use.
*/
mvdstdConvertImage :: (config: *MVDSTD_Config) -> Result #foreign libctru;

/**
* @brief Processes a video frame(specifically a NAL-unit).
* @param inbuf_vaddr Input NAL-unit starting with the 3-byte "00 00 01" prefix. Must be located in linearmem.
* @param size Size of the input buffer.
* @param flag See here regarding this input flag: https://www.3dbrew.org/wiki/MVDSTD:ProcessNALUnit
* @param out Optional output MVDSTD_ProcessNALUnitOut structure.
*/
mvdstdProcessVideoFrame :: (inbuf_vaddr: *void, size: size_t, flag: u32, out: *MVDSTD_ProcessNALUnitOut) -> Result #foreign libctru;

/**
* @brief Renders the video frame.
* @param config Optional pointer to the configuration to use. When NULL, MVDSTD_SetConfig() should have been used previously for this video.
* @param wait When true, wait for rendering to finish. When false, you can manually call this function repeatedly until it stops returning MVD_STATUS_BUSY.
*/
mvdstdRenderVideoFrame :: (config: *MVDSTD_Config, wait: bool) -> Result #foreign libctru;

/**
* @brief Sets the current configuration of MVDSTD.
* @param config Pointer to the configuration to set.
*/
MVDSTD_SetConfig :: (config: *MVDSTD_Config) -> Result #foreign libctru;

/**
* @brief New3DS Internet Browser doesn't use this. Once done, rendered frames will be written to the output buffers specified by the entrylist instead of the output specified by configuration. See here: https://www.3dbrew.org/wiki/MVDSTD:SetupOutputBuffers
* @param entrylist Input entrylist.
* @param bufsize Size of each buffer from the entrylist.
*/
mvdstdSetupOutputBuffers :: (entrylist: *MVDSTD_OutputBuffersEntryList, bufsize: u32) -> Result #foreign libctru;

/**
* @brief New3DS Internet Browser doesn't use this. This overrides the entry0 output buffers originally setup by mvdstdSetupOutputBuffers(). See also here: https://www.3dbrew.org/wiki/MVDSTD:OverrideOutputBuffers
* @param cur_outdata0 Linearmem vaddr. The current outdata0 for this entry must match this value.
* @param cur_outdata1 Linearmem vaddr. The current outdata1 for this entry must match this value.
* @param new_outdata0 Linearmem vaddr. This is the new address to use for outaddr0.
* @param new_outdata1 Linearmem vaddr. This is the new address to use for outaddr1.
*/
mvdstdOverrideOutputBuffers :: (cur_outdata0: *void, cur_outdata1: *void, new_outdata0: *void, new_outdata1: *void) -> Result #foreign libctru;

/// NFC operation type.
NFC_OpType :: enum u8 {
    _1     :: 1;
    NFCTag :: 2;
    RawNFC :: 3;
}

NFC_TagState :: enum u8 {
    Uninitialized   :: 0;
    ScanningStopped :: 1;
    Scanning        :: 2;
    InRange         :: 3;
    OutOfRange      :: 4;
    DataReady       :: 5;
}

/// Bit4-7 are always clear with nfcGetAmiiboSettings() due to "& 0xF".
NFC_amiiboFlag :: enum u8 {
    Setup        :: 16;
    AppDataSetup :: 32;
}

NFC_TagInfo :: struct {
    id_offset_size: u16;
    unk_x2:         u8; //"Unknown u8, normally 0x0."
    unk_x3:         u8; //"Unknown u8, normally 0x2."
    id:             [40] u8; //"ID data. When the above size field is 0x7, this is the 7-byte NFC tag UID, followed by all-zeros."
}

/// AmiiboSettings structure, see also here: https://3dbrew.org/wiki/NFC:GetAmiiboSettings
NFC_AmiiboSettings :: struct {
    mii:             [96] u8;
    /// "Owner Mii."
    nickname:        [11] u16;
    /// "UTF-16BE Amiibo nickname."
    flags:           u8;
    /// "This is plaintext_amiibosettingsdata[0] & 0xF." See also the NFC_amiiboFlag enums.
    countrycodeid:   u8;
    /// "This is plaintext_amiibosettingsdata[1]." "Country Code ID, from the system which setup this amiibo."
    setupdate_year:  u16;
    setupdate_month: u8;
    setupdate_day:   u8;
    unk_x7c:         [44] u8; //Normally all-zero?
}

/// AmiiboConfig structure, see also here: https://3dbrew.org/wiki/NFC:GetAmiiboConfig
NFC_AmiiboConfig :: struct {
    lastwritedate_year:  u16;
    lastwritedate_month: u8;
    lastwritedate_day:   u8;
    write_counter:       u16;
    characterID:         [3] u8;
    /// the first element is the collection ID, the second the character in this collection, the third the variant
    series:              u8;
    /// ID of the series
    amiiboID:            u16;
    /// ID shared by all exact same amiibo. Some amiibo are only distinguished by this one like regular SMB Series Mario and the gold one
    type:                u8;
    /// Type of amiibo 0 = figure, 1 = card, 2 = plush
    pagex4_byte3:        u8;
    appdata_size:        u16;
    /// "NFC module writes hard-coded u8 value 0xD8 here. This is the size of the Amiibo AppData, apps can use this with the AppData R/W commands. ..."
    zeros:               [48] u8;
}

/// Used by nfcInitializeWriteAppData() internally, see also here: https://3dbrew.org/wiki/NFC:GetAppDataInitStruct
NFC_AppDataInitStruct :: struct {
    data_x0: [12] u8;
    data_xc: [48] u8;
}

/// Used by nfcWriteAppData() internally, see also: https://3dbrew.org/wiki/NFC:WriteAppData
NFC_AppDataWriteStruct :: struct {
    id:        [10] u8; //7-byte UID normally.
    id_size:   u8;
    unused_xb: [21] u8;
}

/**
* @brief Initializes NFC.
* @param type See the NFC_OpType enum.
*/
nfcInit :: (type: NFC_OpType) -> Result #foreign libctru;

/**
* @brief Shuts down NFC.
*/
nfcExit :: () -> void #foreign libctru;

/**
* @brief Gets the NFC service handle.
* @return The NFC service handle.
*/
nfcGetSessionHandle :: () -> Handle #foreign libctru;

/**
* @brief Starts scanning for NFC tags.
* @param inval Unknown. See NFC_STARTSCAN_DEFAULTINPUT.
*/
nfcStartScanning :: (inval: u16) -> Result #foreign libctru;

/**
* @brief Stops scanning for NFC tags.
*/
nfcStopScanning :: () -> void #foreign libctru;

/**
* @brief Read amiibo NFC data and load in memory.
*/
nfcLoadAmiiboData :: () -> Result #foreign libctru;

/**
* @brief If the tagstate is valid(NFC_TagState_DataReady or 6), it then sets the current tagstate to NFC_TagState_InRange.
*/
nfcResetTagScanState :: () -> Result #foreign libctru;

/**
* @brief This writes the amiibo data stored in memory to the actual amiibo data storage(which is normally the NFC data pages). This can only be used if NFC_LoadAmiiboData() was used previously.
*/
nfcUpdateStoredAmiiboData :: () -> Result #foreign libctru;

/**
* @brief Returns the current NFC tag state.
* @param state Pointer to write NFC tag state.
*/
nfcGetTagState :: (state: *NFC_TagState) -> Result #foreign libctru;

/**
* @brief Returns the current TagInfo.
* @param out Pointer to write the output TagInfo.
*/
nfcGetTagInfo :: (out: *NFC_TagInfo) -> Result #foreign libctru;

/**
* @brief Opens the appdata, when the amiibo appdata was previously initialized. This must be used before reading/writing the appdata. See also: https://3dbrew.org/wiki/NFC:OpenAppData
* @param amiibo_appid Amiibo AppID. See here: https://www.3dbrew.org/wiki/Amiibo
*/
nfcOpenAppData :: (amiibo_appid: u32) -> Result #foreign libctru;

/**
* @brief This initializes the appdata using the specified input, when the appdata previously wasn't initialized. If the appdata is already initialized, you must first use the amiibo Settings applet menu option labeled "Delete amiibo Game Data". This automatically writes the amiibo data into the actual data storage(normally NFC data pages). See also nfcWriteAppData().
* @param amiibo_appid amiibo AppID. See also nfcOpenAppData().
* @param buf Input buffer.
* @param size Buffer size.
*/
nfcInitializeWriteAppData :: (amiibo_appid: u32, buf: *void, size: size_t) -> Result #foreign libctru;

/**
* @brief Reads the appdata. The size must be >=0xD8-bytes, but the actual used size is hard-coded to 0xD8. Note that areas of appdata which were never written to by applications are uninitialized in this output buffer.
* @param buf Output buffer.
* @param size Buffer size.
*/
nfcReadAppData :: (buf: *void, size: size_t) -> Result #foreign libctru;

/**
* @brief Writes the appdata, after nfcOpenAppData() was used successfully. The size should be <=0xD8-bytes. See also: https://3dbrew.org/wiki/NFC:WriteAppData
* @param buf Input buffer.
* @param size Buffer size.
* @param taginfo TagInfo from nfcGetTagInfo().
*/
nfcWriteAppData :: (buf: *void, size: size_t, taginfo: *NFC_TagInfo) -> Result #foreign libctru;

/**
* @brief Returns the current AmiiboSettings.
* @param out Pointer to write the output AmiiboSettings.
*/
nfcGetAmiiboSettings :: (out: *NFC_AmiiboSettings) -> Result #foreign libctru;

/**
* @brief Returns the current AmiiboConfig.
* @param out Pointer to write the output AmiiboConfig.
*/
nfcGetAmiiboConfig :: (out: *NFC_AmiiboConfig) -> Result #foreign libctru;

/**
* @brief Starts scanning for NFC tags when initialized with NFC_OpType_RawNFC. See also: https://www.3dbrew.org/wiki/NFC:StartOtherTagScanning
* @param unk0 Same as nfcStartScanning() input.
* @param unk1 Unknown.
*/
nfcStartOtherTagScanning :: (unk0: u16, unk1: u32) -> Result #foreign libctru;

/**
* @brief This sends a raw NFC command to the tag. This can only be used when initialized with NFC_OpType_RawNFC, and when the TagState is NFC_TagState_InRange. See also: https://www.3dbrew.org/wiki/NFC:SendTagCommand
* @param inbuf Input buffer.
* @param insize Size of the input buffer.
* @param outbuf Output buffer.
* @param outsize Size of the output buffer.
* @param actual_transfer_size Optional output ptr to write the actual output-size to, can be NULL.
* @param microseconds Timing-related field in microseconds.
*/
nfcSendTagCommand :: (inbuf: *void, insize: size_t, outbuf: *void, outsize: size_t, actual_transfer_size: *size_t, microseconds: u64) -> Result #foreign libctru;

/**
* @brief Unknown. This can only be used when initialized with NFC_OpType_RawNFC, and when the TagState is NFC_TagState_InRange.
*/
nfcCmd21 :: () -> Result #foreign libctru;

/**
* @brief Unknown. This can only be used when initialized with NFC_OpType_RawNFC, and when the TagState is NFC_TagState_InRange.
*/
nfcCmd22 :: () -> Result #foreign libctru;

/// Notification header data.
NotificationHeader :: struct {
    dataSet:    bool;
    unread:     bool;
    enableJPEG: bool;
    isSpotPass: bool;
    isOptedOut: bool;
    unkData:    [3] u8;
    processID:  u64;
    unkData2:   [8] u8;
    jumpParam:  u64;
    unkData3:   [8] u8;
    time:       u64;
    title:      [32] u16;
}

/// Initializes NEWS.
newsInit :: () -> Result #foreign libctru;

/// Exits NEWS.
newsExit :: () -> void #foreign libctru;

/**
* @brief Adds a notification to the home menu Notifications applet.
* @param title UTF-16 title of the notification.
* @param titleLength Number of characters in the title, not including the null-terminator.
* @param message UTF-16 message of the notification, or NULL for no message.
* @param messageLength Number of characters in the message, not including the null-terminator.
* @param image Data of the image to show in the notification, or NULL for no image.
* @param imageSize Size of the image data in bytes.
* @param jpeg Whether the image is a JPEG or not.
*/
NEWS_AddNotification :: (title: *u16, titleLength: u32, message: *u16, messageLength: u32, imageData: *void, imageSize: u32, jpeg: bool) -> Result #foreign libctru;

/**
* @brief Gets current total notifications number.
* @param num Pointer where total number will be saved.
*/
NEWS_GetTotalNotifications :: (num: *u32) -> Result #foreign libctru;

/**
* @brief Sets a custom header for a specific notification.
* @param news_id Identification number of the notification.
* @param header Pointer to notification header to set.
*/
NEWS_SetNotificationHeader :: (news_id: u32, header: *NotificationHeader) -> Result #foreign libctru;

/**
* @brief Gets the header of a specific notification.
* @param news_id Identification number of the notification.
* @param header Pointer where header of the notification will be saved.
*/
NEWS_GetNotificationHeader :: (news_id: u32, header: *NotificationHeader) -> Result #foreign libctru;

/**
* @brief Sets a custom message for a specific notification.
* @param news_id Identification number of the notification.
* @param message Pointer to UTF-16 message to set.
* @param size Size of message to set.
*/
NEWS_SetNotificationMessage :: (news_id: u32, message: *u16, size: u32) -> Result #foreign libctru;

/**
* @brief Gets the message of a specific notification.
* @param news_id Identification number of the notification.
* @param message Pointer where UTF-16 message of the notification will be saved.
* @param size Pointer where size of the message data will be saved in bytes.
*/
NEWS_GetNotificationMessage :: (news_id: u32, message: *u16, size: *u32) -> Result #foreign libctru;

/**
* @brief Sets a custom image for a specific notification.
* @param news_id Identification number of the notification.
* @param buffer Pointer to MPO image to set.
* @param size Size of the MPO image to set.
*/
NEWS_SetNotificationImage :: (news_id: u32, buffer: *void, size: u32) -> Result #foreign libctru;

/**
* @brief Gets the image of a specific notification.
* @param news_id Identification number of the notification.
* @param buffer Pointer where MPO image of the notification will be saved.
* @param size Pointer where size of the image data will be saved in bytes.
*/
NEWS_GetNotificationImage :: (news_id: u32, buffer: *void, size: *u32) -> Result #foreign libctru;

/// Head tracking coordinate pair.
QTM_HeadTrackingInfoCoord :: struct {
    x: float; ///< X coordinate.
    y: float; ///< Y coordinate.
}

/// Head tracking info.
QTM_HeadTrackingInfo :: struct {
    flags:         [5] u8; ///< Flags.
    padding:       [3] u8; ///< Padding.
    floatdata_x08: float; ///< Unknown. Not used by System_Settings.
    coords0:       [4] QTM_HeadTrackingInfoCoord; ///< Head coordinates.
    unk_x2c:       [5] u32; ///< Unknown. Not used by System_Settings.
}

/// Initializes QTM.
qtmInit :: () -> Result #foreign libctru;

/// Exits QTM.
qtmExit :: () -> void #foreign libctru;

/**
* @brief Checks whether QTM is initialized.
* @return Whether QTM is initialized.
*/
qtmCheckInitialized :: () -> bool #foreign libctru;

/**
* @brief Checks whether a head is fully detected.
* @param info Tracking info to check.
*/
qtmCheckHeadFullyDetected :: (info: *QTM_HeadTrackingInfo) -> bool #foreign libctru;

/**
* @brief Converts QTM coordinates to screen coordinates.
* @param coord Coordinates to convert.
* @param screen_width Width of the screen. Can be NULL to use the default value for the top screen.
* @param screen_height Height of the screen. Can be NULL to use the default value for the top screen.
* @param x Pointer to output the screen X coordinate to.
* @param y Pointer to output the screen Y coordinate to.
*/
qtmConvertCoordToScreen :: (coord: *QTM_HeadTrackingInfoCoord, screen_width: *float, screen_height: *float, x: *u32, y: *u32) -> Result #foreign libctru;

/**
* @brief Gets the current head tracking info.
* @param val Normally 0.
* @param out Pointer to write head tracking info to.
*/
QTM_GetHeadTrackingInfo :: (val: u64, out: *QTM_HeadTrackingInfo) -> Result #foreign libctru;

/// Initializes srv:pm and the service API.
srvPmInit :: () -> Result #foreign libctru;

/// Exits srv:pm and the service API.
srvPmExit :: () -> void #foreign libctru;

/**
* @brief Gets the current srv:pm session handle.
* @return The current srv:pm session handle.
*/
srvPmGetSessionHandle :: () -> *Handle #foreign libctru;

/**
* @brief Publishes a notification to a process.
* @param notificationId ID of the notification.
* @param process Process to publish to.
*/
SRVPM_PublishToProcess :: (notificationId: u32, process: Handle) -> Result #foreign libctru;

/**
* @brief Publishes a notification to all processes.
* @param notificationId ID of the notification.
*/
SRVPM_PublishToAll :: (notificationId: u32) -> Result #foreign libctru;

/**
* @brief Registers a process with SRV.
* @param pid ID of the process.
* @param count Number of services within the service access control data.
* @param serviceAccessControlList Service Access Control list.
*/
SRVPM_RegisterProcess :: (pid: u32, count: u32, serviceAccessControlList: *[8] u8) -> Result #foreign libctru;

/**
* @brief Unregisters a process with SRV.
* @param pid ID of the process.
*/
SRVPM_UnregisterProcess :: (pid: u32) -> Result #foreign libctru;

/// Initializes LOADER.
loaderInit :: () -> Result #foreign libctru;

/// Exits LOADER.
loaderExit :: () -> void #foreign libctru;

/**
* @brief Loads a program and returns a process handle to the newly created process.
* @param[out] process Pointer to output the process handle to.
* @param programHandle The handle of the program to load.
*/
LOADER_LoadProcess :: (process: *Handle, programHandle: u64) -> Result #foreign libctru;

/**
* @brief Registers a program (along with its update).
* @param[out] programHandle Pointer to output the program handle to.
* @param programInfo The program info.
* @param programInfo The program update info.
*/
LOADER_RegisterProgram :: (programHandle: *u64, programInfo: *FS_ProgramInfo, programInfoUpdate: *FS_ProgramInfo) -> Result #foreign libctru;

/**
* @brief Unregisters a program (along with its update).
* @param programHandle The handle of the program to unregister.
*/
LOADER_UnregisterProgram :: (programHandle: u64) -> Result #foreign libctru;

/**
* @brief Retrives a program's main NCCH extended header info (SCI + ACI, see @ref ExHeader_Info).
* @param[out] exheaderInfo Pointer to output the main NCCH extended header info.
* @param programHandle The handle of the program to unregister
*/
LOADER_GetProgramInfo :: (exheaderInfo: *ExHeader_Info, programHandle: u64) -> Result #foreign libctru;

powerLedState :: enum u8 {
    NORMAL     :: 1;
    SLEEP_MODE :: 2;
    OFF        :: 3;
    RED        :: 4;
    BLUE       :: 5;
    BLINK_RED  :: 6;
}

/// Initializes mcuHwc.
mcuHwcInit :: () -> Result #foreign libctru;

/// Exits mcuHwc.
mcuHwcExit :: () -> void #foreign libctru;

/**
* @brief Reads data from an i2c device3 register
* @param reg Register number. See https://www.3dbrew.org/wiki/I2C_Registers#Device_3 for more info
* @param data Pointer to write the data to.
* @param size Size of data to be read
*/
MCUHWC_ReadRegister :: (reg: u8, data: *void, size: u32) -> Result #foreign libctru;

/**
* @brief Writes data to a i2c device3 register
* @param reg Register number. See https://www.3dbrew.org/wiki/I2C_Registers#Device_3 for more info
* @param data Pointer to write the data to.
* @param size Size of data to be written
*/
MCUHWC_WriteRegister :: (reg: u8, data: *void, size: u32) -> Result #foreign libctru;

/**
* @brief Gets the battery voltage
* @param voltage Pointer to write the battery voltage to.
*/
MCUHWC_GetBatteryVoltage :: (voltage: *u8) -> Result #foreign libctru;

/**
* @brief Gets the battery level
* @param level Pointer to write the current battery level to.
*/
MCUHWC_GetBatteryLevel :: (level: *u8) -> Result #foreign libctru;

/**
* @brief Gets the sound slider level
* @param level Pointer to write the slider level to.
*/
MCUHWC_GetSoundSliderLevel :: (level: *u8) -> Result #foreign libctru;

/**
* @brief Sets Wifi LED state
* @param state State of Wifi LED. (True/False)
*/
MCUHWC_SetWifiLedState :: (state: bool) -> Result #foreign libctru;

/**
* @brief Sets Power LED state
* @param state powerLedState State of power LED.
*/
MCUHWC_SetPowerLedState :: (state: powerLedState) -> Result #foreign libctru;

/**
* @brief Gets 3d slider level
* @param level Pointer to write 3D slider level to.
*/
MCUHWC_Get3dSliderLevel :: (level: *u8) -> Result #foreign libctru;

/**
* @brief Gets the major MCU firmware version
* @param out Pointer to write the major firmware version to.
*/
MCUHWC_GetFwVerHigh :: (out: *u8) -> Result #foreign libctru;

/**
* @brief Gets the minor MCU firmware version
* @param out Pointer to write the minor firmware version to.
*/
MCUHWC_GetFwVerLow :: (out: *u8) -> Result #foreign libctru;

/**
* @brief Supported transfer pixel formats.
* @sa GSPGPU_FramebufferFormat
*/
GX_TRANSFER_FORMAT :: enum u8 {
    A8   :: 0;
    _8   :: 1;
    _565 :: 2;
    _5A1 :: 3;
    A4   :: 4;
}

/**
* @brief Anti-aliasing modes
*
* Please remember that the framebuffer is sideways.
* Hence if you activate 2x1 anti-aliasing the destination dimensions are w = 240*2 and h = 400
*/
GX_TRANSFER_SCALE :: enum u8 {
    NO :: 0;
    X  :: 1;
    XY :: 2;
}

/// GX transfer control flags
GX_FILL_CONTROL :: enum u16 {
    TRIGGER      :: 1;
    FINISHED     :: 2;
    _16BIT_DEPTH :: 0;
    _24BIT_DEPTH :: 256;
    _32BIT_DEPTH :: 512;
}

/// GX command entry
gxCmdEntry_s :: union {
    data: [8] u32; ///< Raw command data
    struct {
        type: u8; ///< Command type
        unk1: u8;
        unk2: u8;
        unk3: u8;
        args: [7] u32; ///< Command arguments
    }
}

/// GX command queue structure
tag_gxCmdQueue_s :: struct {
    entries:    *gxCmdEntry_s; ///< Pointer to array of GX command entries
    maxEntries: u16; ///< Capacity of the command array
    numEntries: u16; ///< Number of commands in the queue
    curEntry:   u16; ///< Index of the first pending command to be submitted to GX
    lastEntry:  u16; ///< Number of commands completed by GX
    CALLBACK_T :: #type (unknown0: *tag_gxCmdQueue_s) -> void #c_call;
    callback:   CALLBACK_T #align 4; ///< User callback
    user:       *void; ///< Data for user callback
}

/// GX command queue structure
gxCmdQueue_s :: tag_gxCmdQueue_s;

/**
* @brief Clears a GX command queue.
* @param queue The GX command queue.
*/
gxCmdQueueClear :: (queue: *gxCmdQueue_s) -> void #foreign libctru;

/**
* @brief Adds a command to a GX command queue.
* @param queue The GX command queue.
* @param entry The GX command to add.
*/
gxCmdQueueAdd :: (queue: *gxCmdQueue_s, entry: *gxCmdEntry_s) -> void #foreign libctru;

/**
* @brief Runs a GX command queue, causing it to begin processing incoming commands as they arrive.
* @param queue The GX command queue.
*/
gxCmdQueueRun :: (queue: *gxCmdQueue_s) -> void #foreign libctru;

/**
* @brief Stops a GX command queue from processing incoming commands.
* @param queue The GX command queue.
*/
gxCmdQueueStop :: (queue: *gxCmdQueue_s) -> void #foreign libctru;

/**
* @brief Waits for a GX command queue to finish executing pending commands.
* @param queue The GX command queue.
* @param timeout Optional timeout (in nanoseconds) to wait (specify -1 for no timeout).
* @return false if timeout expired, true otherwise.
*/
gxCmdQueueWait :: (queue: *gxCmdQueue_s, timeout: s64) -> bool #foreign libctru;

/**
* @brief Selects a command queue to which GX_* functions will add commands instead of immediately submitting them to GX.
* @param queue The GX command queue. (Pass NULL to remove the bound command queue)
*/
GX_BindQueue :: (queue: *gxCmdQueue_s) -> void #foreign libctru;

/**
* @brief Requests a DMA.
* @param src Source to DMA from.
* @param dst Destination to DMA to.
* @param length Length of data to transfer.
*/
GX_RequestDma :: (src: *u32, dst: *u32, length: u32) -> Result #foreign libctru;

/**
* @brief Processes a GPU command list.
* @param buf0a Command list address.
* @param buf0s Command list size.
* @param flags Flags to process with.
*/
GX_ProcessCommandList :: (buf0a: *u32, buf0s: u32, flags: u8) -> Result #foreign libctru;

/**
* @brief Fills the memory of two buffers with the given values.
* @param buf0a Start address of the first buffer.
* @param buf0v Dimensions of the first buffer.
* @param buf0e End address of the first buffer.
* @param control0 Value to fill the first buffer with.
* @param buf1a Start address of the second buffer.
* @param buf1v Dimensions of the second buffer.
* @param buf1e End address of the second buffer.
* @param control1 Value to fill the second buffer with.
*/
GX_MemoryFill :: (buf0a: *u32, buf0v: u32, buf0e: *u32, control0: u16, buf1a: *u32, buf1v: u32, buf1e: *u32, control1: u16) -> Result #foreign libctru;

/**
* @brief Initiates a display transfer.
* @note The PPF event will be signaled on completion.
* @param inadr Address of the input.
* @param indim Dimensions of the input.
* @param outadr Address of the output.
* @param outdim Dimensions of the output.
* @param flags Flags to transfer with.
*/
GX_DisplayTransfer :: (inadr: *u32, indim: u32, outadr: *u32, outdim: u32, flags: u32) -> Result #foreign libctru;

/**
* @brief Initiates a texture copy.
* @note The PPF event will be signaled on completion.
* @param inadr Address of the input.
* @param indim Dimensions of the input.
* @param outadr Address of the output.
* @param outdim Dimensions of the output.
* @param size Size of the data to transfer.
* @param flags Flags to transfer with.
*/
GX_TextureCopy :: (inadr: *u32, indim: u32, outadr: *u32, outdim: u32, size: u32, flags: u32) -> Result #foreign libctru;

/**
* @brief Flushes the cache regions of three buffers. (This command cannot be queued in a GX command queue)
* @param buf0a Address of the first buffer.
* @param buf0s Size of the first buffer.
* @param buf1a Address of the second buffer.
* @param buf1s Size of the second buffer.
* @param buf2a Address of the third buffer.
* @param buf2s Size of the third buffer.
*/
GX_FlushCacheRegions :: (buf0a: *u32, buf0s: u32, buf1a: *u32, buf1s: u32, buf2a: *u32, buf2s: u32) -> Result #foreign libctru;

/// Texture filters.
GPU_TEXTURE_FILTER_PARAM :: enum u8 {
    NEAREST :: 0;
    LINEAR  :: 1;
}

/// Texture wrap modes.
GPU_TEXTURE_WRAP_PARAM :: enum u8 {
    CLAMP_TO_EDGE   :: 0;
    CLAMP_TO_BORDER :: 1;
    REPEAT          :: 2;
    MIRRORED_REPEAT :: 3;
}

/// Texture modes.
GPU_TEXTURE_MODE_PARAM :: enum u8 {
    _2D         :: 0;
    CUBE_MAP    :: 1;
    SHADOW_2D   :: 2;
    PROJECTION  :: 3;
    SHADOW_CUBE :: 4;
    DISABLED    :: 5;
}

/// Supported texture units.
GPU_TEXUNIT :: enum u8 {
    TEXUNIT0 :: 1;
    TEXUNIT1 :: 2;
    TEXUNIT2 :: 4;
}

/// Supported texture formats.
GPU_TEXCOLOR :: enum u8 {
    RGBA8    :: 0;
    RGB8     :: 1;
    RGBA5551 :: 2;
    RGB565   :: 3;
    RGBA4    :: 4;
    LA8      :: 5;
    HILO8    :: 6;
    L8       :: 7;
    A8       :: 8;
    LA4      :: 9;
    L4       :: 10;
    A4       :: 11;
    ETC1     :: 12;
    ETC1A4   :: 13;
}

/// Texture faces.
GPU_TEXFACE :: enum u8 {
    TEXFACE_2D :: 0;
    POSITIVE_X :: 0;
    NEGATIVE_X :: 1;
    POSITIVE_Y :: 2;
    NEGATIVE_Y :: 3;
    POSITIVE_Z :: 4;
    NEGATIVE_Z :: 5;
}

/// Procedural texture clamp modes.
GPU_PROCTEX_CLAMP :: enum u8 {
    CLAMP_TO_ZERO   :: 0;
    CLAMP_TO_EDGE   :: 1;
    REPEAT          :: 2;
    MIRRORED_REPEAT :: 3;
    PULSE           :: 4;
}

/// Procedural texture mapping functions.
GPU_PROCTEX_MAPFUNC :: enum u8 {
    U     :: 0;
    U2    :: 1;
    V     :: 2;
    V2    :: 3;
    ADD   :: 4;
    ADD2  :: 5;
    SQRT2 :: 6;
    MIN   :: 7;
    MAX   :: 8;
    RMAX  :: 9;
}

/// Procedural texture shift values.
GPU_PROCTEX_SHIFT :: enum u8 {
    NONE :: 0;
    ODD  :: 1;
    EVEN :: 2;
}

/// Procedural texture filter values.
GPU_PROCTEX_FILTER :: enum u8 {
    NEAREST             :: 0;
    LINEAR              :: 1;
    NEAREST_MIP_NEAREST :: 2;
    LINEAR_MIP_NEAREST  :: 3;
    NEAREST_MIP_LINEAR  :: 4;
    LINEAR_MIP_LINEAR   :: 5;
}

/// Procedural texture LUT IDs.
GPU_PROCTEX_LUTID :: enum u8 {
    NOISE    :: 0;
    RGBMAP   :: 2;
    ALPHAMAP :: 3;
    COLOR    :: 4;
    COLORDIF :: 5;
}

/// Supported color buffer formats.
GPU_COLORBUF :: enum u8 {
    A8    :: 0;
    _8    :: 1;
    A5551 :: 2;
    _565  :: 3;
    A4    :: 4;
}

/// Supported depth buffer formats.
GPU_DEPTHBUF :: enum u8 {
    _16          :: 0;
    _24          :: 2;
    _24_STENCIL8 :: 3;
}

/// Test functions.
GPU_TESTFUNC :: enum u8 {
    NEVER    :: 0;
    ALWAYS   :: 1;
    EQUAL    :: 2;
    NOTEQUAL :: 3;
    LESS     :: 4;
    LEQUAL   :: 5;
    GREATER  :: 6;
    GEQUAL   :: 7;
}

/// Early depth test functions.
GPU_EARLYDEPTHFUNC :: enum u8 {
    GEQUAL  :: 0;
    GREATER :: 1;
    LEQUAL  :: 2;
    LESS    :: 3;
}

/// Gas depth functions.
GPU_GASDEPTHFUNC :: enum u8 {
    NEVER   :: 0;
    ALWAYS  :: 1;
    GREATER :: 2;
    LESS    :: 3;
}

/// Scissor test modes.
GPU_SCISSORMODE :: enum u8 {
    DISABLE :: 0;
    INVERT  :: 1;
    NORMAL  :: 3;
}

/// Stencil operations.
GPU_STENCILOP :: enum u8 {
    KEEP      :: 0;
    ZERO      :: 1;
    REPLACE   :: 2;
    INCR      :: 3;
    DECR      :: 4;
    INVERT    :: 5;
    INCR_WRAP :: 6;
    DECR_WRAP :: 7;
}

/// Pixel write mask.
GPU_WRITEMASK :: enum u8 {
    RED   :: 1;
    GREEN :: 2;
    BLUE  :: 4;
    ALPHA :: 8;
    DEPTH :: 16;
    COLOR :: 15;
    ALL   :: 31;
}

/// Blend modes.
GPU_BLENDEQUATION :: enum u8 {
    ADD              :: 0;
    SUBTRACT         :: 1;
    REVERSE_SUBTRACT :: 2;
    MIN              :: 3;
    MAX              :: 4;
}

/// Blend factors.
GPU_BLENDFACTOR :: enum u8 {
    ZERO                     :: 0;
    ONE                      :: 1;
    SRC_COLOR                :: 2;
    ONE_MINUS_SRC_COLOR      :: 3;
    DST_COLOR                :: 4;
    ONE_MINUS_DST_COLOR      :: 5;
    SRC_ALPHA                :: 6;
    ONE_MINUS_SRC_ALPHA      :: 7;
    DST_ALPHA                :: 8;
    ONE_MINUS_DST_ALPHA      :: 9;
    CONSTANT_COLOR           :: 10;
    ONE_MINUS_CONSTANT_COLOR :: 11;
    CONSTANT_ALPHA           :: 12;
    ONE_MINUS_CONSTANT_ALPHA :: 13;
    SRC_ALPHA_SATURATE       :: 14;
}

/// Logical operations.
GPU_LOGICOP :: enum u8 {
    CLEAR         :: 0;
    AND           :: 1;
    AND_REVERSE   :: 2;
    COPY          :: 3;
    SET           :: 4;
    COPY_INVERTED :: 5;
    NOOP          :: 6;
    INVERT        :: 7;
    NAND          :: 8;
    OR            :: 9;
    NOR           :: 10;
    XOR           :: 11;
    EQUIV         :: 12;
    AND_INVERTED  :: 13;
    OR_REVERSE    :: 14;
    OR_INVERTED   :: 15;
}

/// Fragment operation modes.
GPU_FRAGOPMODE :: enum u8 {
    GL      :: 0;
    GAS_ACC :: 1;
    SHADOW  :: 3;
}

/// Supported component formats.
GPU_FORMATS :: enum u8 {
    BYTE          :: 0;
    UNSIGNED_BYTE :: 1;
    SHORT         :: 2;
    FLOAT         :: 3;
}

/// Cull modes.
GPU_CULLMODE :: enum u8 {
    NONE      :: 0;
    FRONT_CCW :: 1;
    BACK_CCW  :: 2;
}

/// Texture combiner sources.
GPU_TEVSRC :: enum u8 {
    PRIMARY_COLOR            :: 0;
    FRAGMENT_PRIMARY_COLOR   :: 1;
    FRAGMENT_SECONDARY_COLOR :: 2;
    TEXTURE0                 :: 3;
    TEXTURE1                 :: 4;
    TEXTURE2                 :: 5;
    TEXTURE3                 :: 6;
    PREVIOUS_BUFFER          :: 13;
    CONSTANT                 :: 14;
    PREVIOUS                 :: 15;
}

/// Texture RGB combiner operands.
GPU_TEVOP_RGB :: enum u8 {
    SRC_COLOR           :: 0;
    ONE_MINUS_SRC_COLOR :: 1;
    SRC_ALPHA           :: 2;
    ONE_MINUS_SRC_ALPHA :: 3;
    SRC_R               :: 4;
    ONE_MINUS_SRC_R     :: 5;
    _0x06               :: 6;
    _0x07               :: 7;
    SRC_G               :: 8;
    ONE_MINUS_SRC_G     :: 9;
    _0x0A               :: 10;
    _0x0B               :: 11;
    SRC_B               :: 12;
    ONE_MINUS_SRC_B     :: 13;
    _0x0E               :: 14;
    _0x0F               :: 15;
}

/// Texture Alpha combiner operands.
GPU_TEVOP_A :: enum u8 {
    SRC_ALPHA           :: 0;
    ONE_MINUS_SRC_ALPHA :: 1;
    SRC_R               :: 2;
    ONE_MINUS_SRC_R     :: 3;
    SRC_G               :: 4;
    ONE_MINUS_SRC_G     :: 5;
    SRC_B               :: 6;
    ONE_MINUS_SRC_B     :: 7;
}

/// Texture combiner functions.
GPU_COMBINEFUNC :: enum u8 {
    REPLACE      :: 0;
    MODULATE     :: 1;
    ADD          :: 2;
    ADD_SIGNED   :: 3;
    INTERPOLATE  :: 4;
    SUBTRACT     :: 5;
    DOT3_RGB     :: 6;
    MULTIPLY_ADD :: 8;
    ADD_MULTIPLY :: 9;
}

/// Texture scale factors.
GPU_TEVSCALE :: enum u8 {
    _1 :: 0;
    _2 :: 1;
    _4 :: 2;
}

/// Fresnel options.
GPU_FRESNELSEL :: enum u8 {
    NO_FRESNEL            :: 0;
    PRI_ALPHA_FRESNEL     :: 1;
    SEC_ALPHA_FRESNEL     :: 2;
    PRI_SEC_ALPHA_FRESNEL :: 3;
}

/// Bump map modes.
GPU_BUMPMODE :: enum u8 {
    NOT_USED :: 0;
    AS_BUMP  :: 1;
    AS_TANG  :: 2;
}

/// LUT IDs.
GPU_LIGHTLUTID :: enum u8 {
    D0 :: 0;
    D1 :: 1;
    SP :: 2;
    FR :: 3;
    RB :: 4;
    RG :: 5;
    RR :: 6;
    DA :: 7;
}

/// LUT inputs.
GPU_LIGHTLUTINPUT :: enum u8 {
    NH :: 0;
    VH :: 1;
    NV :: 2;
    LN :: 3;
    SP :: 4;
    CP :: 5;
}

/// LUT scalers.
GPU_LIGHTLUTSCALER :: enum u8 {
    _1x    :: 0;
    _2x    :: 1;
    _4x    :: 2;
    _8x    :: 3;
    _0_25x :: 6;
    _0_5x  :: 7;
}

/// LUT selection.
GPU_LIGHTLUTSELECT :: enum u8 {
    COMMON :: 0;
    SP     :: 1;
    DA     :: 2;
}

/// Fog modes.
GPU_FOGMODE :: enum u8 {
    NO_FOG :: 0;
    FOG    :: 5;
    GAS    :: 7;
}

/// Gas shading density source values.
GPU_GASMODE :: enum u8 {
    PLAIN_DENSITY :: 0;
    DEPTH_DENSITY :: 1;
}

/// Gas color LUT inputs.
GPU_GASLUTINPUT :: enum u8 {
    DENSITY      :: 0;
    LIGHT_FACTOR :: 1;
}

/// Supported primitives.
GPU_Primitive_t :: enum u16 {
    TRIANGLES      :: 0;
    TRIANGLE_STRIP :: 256;
    TRIANGLE_FAN   :: 512;
    GEOMETRY_PRIM  :: 768;
}

/// Shader types.
GPU_SHADER_TYPE :: enum u8 {
    VERTEX_SHADER   :: 0;
    GEOMETRY_SHADER :: 1;
}

/**
* @brief Adds raw GPU commands to the current command buffer.
* @param cmd Buffer containing commands to add.
* @param size Size of the buffer.
*/
GPUCMD_AddRawCommands :: (cmd: *u32, size: u32) -> void #foreign libctru;

/**
* @brief Adds a GPU command to the current command buffer.
* @param header Header of the command.
* @param param Parameters of the command.
* @param paramlength Size of the parameter buffer.
*/
GPUCMD_Add :: (header: u32, param: *u32, paramlength: u32) -> void #foreign libctru;

/**
* @brief Splits the current GPU command buffer.
* @param addr Pointer to output the command buffer to.
* @param size Pointer to output the size (in words) of the command buffer to.
*/
GPUCMD_Split :: (addr: **u32, size: *u32) -> void #foreign libctru;

/**
* @brief Converts a 32-bit float to a 16-bit float.
* @param f Float to convert.
* @return The converted float.
*/
f32tof16 :: (f: float) -> u32 #foreign libctru;

/**
* @brief Converts a 32-bit float to a 20-bit float.
* @param f Float to convert.
* @return The converted float.
*/
f32tof20 :: (f: float) -> u32 #foreign libctru;

/**
* @brief Converts a 32-bit float to a 24-bit float.
* @param f Float to convert.
* @return The converted float.
*/
f32tof24 :: (f: float) -> u32 #foreign libctru;

/**
* @brief Converts a 32-bit float to a 31-bit float.
* @param f Float to convert.
* @return The converted float.
*/
f32tof31 :: (f: float) -> u32 #foreign libctru;

/// DVLE type.
DVLE_type :: enum u8 {
    VERTEX_SHDR   :: 0;
    GEOMETRY_SHDR :: 1;
}

/// Constant type.
DVLE_constantType :: enum u8 {
    BOOL    :: 0;
    u8      :: 1;
    FLOAT24 :: 2;
}

/// Output attribute.
DVLE_outputAttribute_t :: enum u8 {
    POSITION   :: 0;
    NORMALQUAT :: 1;
    COLOR      :: 2;
    TEXCOORD0  :: 3;
    TEXCOORD0W :: 4;
    TEXCOORD1  :: 5;
    TEXCOORD2  :: 6;
    VIEW       :: 8;
    DUMMY      :: 9;
}

/// Geometry shader operation modes.
DVLE_geoShaderMode :: enum u8 {
    POINT         :: 0;
    VARIABLE_PRIM :: 1;
    FIXED_PRIM    :: 2;
}

/// DVLP data.
DVLP_s :: struct {
    codeSize:    u32; ///< Code size.
    codeData:    *u32 #align 4; ///< Code data.
    opdescSize:  u32; ///< Operand description size.
    opcdescData: *u32 #align 4; ///< Operand description data.
}

/// DVLE constant entry data.
DVLE_constEntry_s :: struct {
    type: u16; ///< Constant type. See @ref DVLE_constantType
    id:   u16; ///< Constant ID.
    data: [4] u32; ///< Constant data.
}

/// DVLE output entry data.
DVLE_outEntry_s :: struct {
    type:  u16; ///< Output type. See @ref DVLE_outputAttribute_t
    regID: u16; ///< Output register ID.
    mask:  u8; ///< Output mask.
    unk:   [3] u8; ///< Unknown.
}

/// DVLE uniform entry data.
DVLE_uniformEntry_s :: struct {
    symbolOffset: u32; ///< Symbol offset.
    startReg:     u16; ///< Start register.
    endReg:       u16; ///< End register.
}

/// DVLE data.
DVLE_s :: struct {
    type:              DVLE_type; ///< DVLE type.
    mergeOutmaps:      bool; ///< true = merge vertex/geometry shader outmaps ('dummy' output attribute is present).
    gshMode:           DVLE_geoShaderMode; ///< Geometry shader operation mode.
    gshFixedVtxStart:  u8; ///< Starting float uniform register number for storing the fixed-size primitive vertex array.
    gshVariableVtxNum: u8; ///< Number of fully-defined vertices in the variable-size primitive vertex array.
    gshFixedVtxNum:    u8; ///< Number of vertices in the fixed-size primitive vertex array.
    dvlp:              *DVLP_s; ///< Contained DVLPs.
    mainOffset:        u32; ///< Offset of the start of the main function.
    endmainOffset:     u32; ///< Offset of the end of the main function.
    constTableSize:    u32; ///< Constant table size.
    constTableData:    *DVLE_constEntry_s; ///< Constant table data.
    outTableSize:      u32; ///< Output table size.
    outTableData:      *DVLE_outEntry_s; ///< Output table data.
    uniformTableSize:  u32; ///< Uniform table size.
    uniformTableData:  *DVLE_uniformEntry_s; ///< Uniform table data.
    symbolTableData:   *u8 #align 4; ///< Symbol table data.
    outmapMask:        u8; ///< Output map mask.
    outmapData:        [8] u32; ///< Output map data.
    outmapMode:        u32; ///< Output map mode.
    outmapClock:       u32; ///< Output map attribute clock.
}

/// DVLB data.
DVLB_s :: struct {
    numDVLE: u32; ///< DVLE count.
    DVLP:    DVLP_s #align 4; ///< Primary DVLP.
    DVLE:    *DVLE_s #align 4; ///< Contained DVLE.
}

/**
* @brief Parses a shader binary.
* @param shbinData Shader binary data.
* @param shbinSize Shader binary size.
* @return The parsed shader binary.
*/
DVLB_ParseFile :: (shbinData: *u32, shbinSize: u32) -> *DVLB_s #foreign libctru;

/**
* @brief Frees shader binary data.
* @param dvlb DVLB to free.
*/
DVLB_Free :: (dvlb: *DVLB_s) -> void #foreign libctru;

/**
* @brief Gets a uniform register index from a shader.
* @param dvle Shader to get the register from.
* @param name Name of the register.
* @return The uniform register index.
*/
DVLE_GetUniformRegister :: (dvle: *DVLE_s, name: *u8) -> s8 #foreign libctru;

/**
* @brief Generates a shader output map.
* @param dvle Shader to generate an output map for.
*/
DVLE_GenerateOutmap :: (dvle: *DVLE_s) -> void #foreign libctru;

/// 24-bit float uniforms.
float24Uniform_s :: struct {
    id:   u32; ///< Uniform ID.
    data: [3] u32; ///< Uniform data.
}

/// Describes an instance of either a vertex or geometry shader.
shaderInstance_s :: struct {
    dvle:               *DVLE_s; ///< Shader DVLE.
    boolUniforms:       u16; ///< Boolean uniforms.
    boolUniformMask:    u16; ///< Used boolean uniform mask.
    intUniforms:        [4] u32; ///< Integer uniforms.
    float24Uniforms:    *float24Uniform_s; ///< 24-bit float uniforms.
    intUniformMask:     u8; ///< Used integer uniform mask.
    numFloat24Uniforms: u8; ///< Float uniform count.
}

/// Describes an instance of a full shader program.
shaderProgram_s :: struct {
    vertexShader:              *shaderInstance_s; ///< Vertex shader.
    geometryShader:            *shaderInstance_s #align 4; ///< Geometry shader.
    geoShaderInputPermutation: [2] u32; ///< Geometry shader input permutation.
    geoShaderInputStride:      u8; ///< Geometry shader input stride.
}

/**
* @brief Initializes a shader instance.
* @param si Shader instance to initialize.
* @param dvle DVLE to initialize the shader instance with.
*/
shaderInstanceInit :: (si: *shaderInstance_s, dvle: *DVLE_s) -> Result #foreign libctru;

/**
* @brief Frees a shader instance.
* @param si Shader instance to free.
*/
shaderInstanceFree :: (si: *shaderInstance_s) -> Result #foreign libctru;

/**
* @brief Sets a bool uniform of a shader.
* @param si Shader instance to use.
* @param id ID of the bool uniform.
* @param value Value to set.
*/
shaderInstanceSetBool :: (si: *shaderInstance_s, id: s32, value: bool) -> Result #foreign libctru;

/**
* @brief Gets a bool uniform of a shader.
* @param si Shader instance to use.
* @param id ID of the bool uniform.
* @param value Pointer to output the value to.
*/
shaderInstanceGetBool :: (si: *shaderInstance_s, id: s32, value: *bool) -> Result #foreign libctru;

/**
* @brief Gets the location of a shader's uniform.
* @param si Shader instance to use.
* @param name Name of the uniform.
*/
shaderInstanceGetUniformLocation :: (si: *shaderInstance_s, name: *u8) -> s8 #foreign libctru;

/**
* @brief Initializes a shader program.
* @param sp Shader program to initialize.
*/
shaderProgramInit :: (sp: *shaderProgram_s) -> Result #foreign libctru;

/**
* @brief Frees a shader program.
* @param sp Shader program to free.
*/
shaderProgramFree :: (sp: *shaderProgram_s) -> Result #foreign libctru;

/**
* @brief Sets the vertex shader of a shader program.
* @param sp Shader program to use.
* @param dvle Vertex shader to set.
*/
shaderProgramSetVsh :: (sp: *shaderProgram_s, dvle: *DVLE_s) -> Result #foreign libctru;

/**
* @brief Sets the geometry shader of a shader program.
* @param sp Shader program to use.
* @param dvle Geometry shader to set.
* @param stride Input stride of the shader (pass 0 to match the number of outputs of the vertex shader).
*/
shaderProgramSetGsh :: (sp: *shaderProgram_s, dvle: *DVLE_s, stride: u8) -> Result #foreign libctru;

/**
* @brief Configures the permutation of the input attributes of the geometry shader of a shader program.
* @param sp Shader program to use.
* @param permutation Attribute permutation to use.
*/
shaderProgramSetGshInputPermutation :: (sp: *shaderProgram_s, permutation: u64) -> Result #foreign libctru;

/**
* @brief Configures the shader units to use the specified shader program.
* @param sp Shader program to use.
* @param sendVshCode When true, the vertex shader's code and operand descriptors are uploaded.
* @param sendGshCode When true, the geometry shader's code and operand descriptors are uploaded.
*/
shaderProgramConfigure :: (sp: *shaderProgram_s, sendVshCode: bool, sendGshCode: bool) -> Result #foreign libctru;

/**
* @brief Same as shaderProgramConfigure, but always loading code/operand descriptors and uploading DVLE constants afterwards.
* @param sp Shader program to use.
*/
shaderProgramUse :: (sp: *shaderProgram_s) -> Result #foreign libctru;

///@name Data types
///@{
/// Sound output modes.
ndspOutputMode :: enum u8 {
    MONO     :: 0;
    STEREO   :: 1;
    SURROUND :: 2;
}

// Clipping modes.
ndspClippingMode :: enum u8 {
    NORMAL :: 0;
    SOFT   :: 1;
}

// Surround speaker positions.
ndspSpeakerPos :: enum u8 {
    SQUARE :: 0;
    WIDE   :: 1;
    NUM    :: 2;
}

/// ADPCM data.
ndspAdpcmData :: struct {
    index:    u16; ///< Current predictor index
    history0: s16; ///< Last outputted PCM16 sample.
    history1: s16; ///< Second to last outputted PCM16 sample.
}

/// Wave buffer type.
ndspWaveBuf :: tag_ndspWaveBuf;

/// Wave buffer status.
NDSP_WBUF :: enum u8 {
    FREE    :: 0;
    QUEUED  :: 1;
    PLAYING :: 2;
    DONE    :: 3;
}

/// Wave buffer struct.
tag_ndspWaveBuf :: struct {
    union {
        data_pcm8:  *s8; ///< Pointer to PCM8 sample data.
        data_pcm16: *s16; ///< Pointer to PCM16 sample data.
        data_adpcm: *u8; ///< Pointer to DSPADPCM sample data.
        data_vaddr: *void; ///< Data virtual address.
    }
    nsamples:    u32; ///< Total number of samples (PCM8=bytes, PCM16=halfwords, DSPADPCM=nibbles without frame headers)
    adpcm_data:  *ndspAdpcmData; ///< ADPCM data.
    offset:      u32; ///< Buffer offset. Only used for capture.
    looping:     bool; ///< Whether to loop the buffer.
    status:      u8; ///< Queuing/playback status.
    sequence_id: u16; ///< Sequence ID. Assigned automatically by ndspChnWaveBufAdd.
    next:        *ndspWaveBuf #align 4; ///< Next buffer to play. Used internally, do not modify.
}

/// Sound frame callback function. (data = User provided data)
ndspCallback :: #type (data: *void) -> void #c_call;

/// Auxiliary output callback function. (data = User provided data, nsamples = Number of samples, samples = Sample data)
ndspAuxCallback :: #type (data: *void, nsamples: s32, samples: *[4] *void) -> void #c_call;

///@name Initialization and basic operations
///@{
/**
* @brief Sets up the DSP component.
* @param binary DSP binary to load.
* @param size Size of the DSP binary.
* @param progMask Program RAM block mask to load the binary to.
* @param dataMask Data RAM block mask to load the binary to.
*/
ndspUseComponent :: (binary: *void, size: u32, progMask: u16, dataMask: u16) -> void #foreign libctru;

/// Initializes NDSP.
ndspInit :: () -> Result #foreign libctru;

/// Exits NDSP.
ndspExit :: () -> void #foreign libctru;

/**
* @brief Gets the number of dropped sound frames.
* @return The number of dropped sound frames.
*/
ndspGetDroppedFrames :: () -> u32 #foreign libctru;

/**
* @brief Gets the total sound frame count.
* @return The total sound frame count.
*/
ndspGetFrameCount :: () -> u32 #foreign libctru;

///@name General parameters
///@{
/**
* @brief Sets the master volume.
* @param volume Volume to set. Defaults to 1.0f.
*/
ndspSetMasterVol :: (volume: float) -> void #foreign libctru;

/**
* @brief Sets the output mode.
* @param mode Output mode to set. Defaults to NDSP_OUTPUT_STEREO.
*/
ndspSetOutputMode :: (mode: ndspOutputMode) -> void #foreign libctru;

/**
* @brief Sets the clipping mode.
* @param mode Clipping mode to set. Defaults to NDSP_CLIP_SOFT.
*/
ndspSetClippingMode :: (mode: ndspClippingMode) -> void #foreign libctru;

/**
* @brief Sets the output count.
* @param count Output count to set. Defaults to 2.
*/
ndspSetOutputCount :: (count: s32) -> void #foreign libctru;

/**
* @brief Sets the wave buffer to capture audio to.
* @param capture Wave buffer to capture to.
*/
ndspSetCapture :: (capture: *ndspWaveBuf) -> void #foreign libctru;

/**
* @brief Sets the sound frame callback.
* @param callback Callback to set.
* @param data User-defined data to pass to the callback.
*/
ndspSetCallback :: (callback: ndspCallback, data: *void) -> void #foreign libctru;

///@name Surround
///@{
/**
* @brief Sets the surround sound depth.
* @param depth Depth to set. Defaults to 0x7FFF.
*/
ndspSurroundSetDepth :: (depth: u16) -> void #foreign libctru;

/**
* @brief Sets the surround sound position.
* @param pos Position to set. Defaults to NDSP_SPKPOS_SQUARE.
*/
ndspSurroundSetPos :: (pos: ndspSpeakerPos) -> void #foreign libctru;

/**
* @brief Sets the surround sound rear ratio.
* @param ratio Rear ratio to set. Defaults to 0x8000.
*/
ndspSurroundSetRearRatio :: (ratio: u16) -> void #foreign libctru;

///@name Auxiliary output
///@{
/**
* @brief Configures whether an auxiliary output is enabled.
* @param id ID of the auxiliary output.
* @param enable Whether to enable the auxiliary output.
*/
ndspAuxSetEnable :: (id: s32, enable: bool) -> void #foreign libctru;

/**
* @brief Configures whether an auxiliary output should use front bypass.
* @param id ID of the auxiliary output.
* @param bypass Whether to use front bypass.
*/
ndspAuxSetFrontBypass :: (id: s32, bypass: bool) -> void #foreign libctru;

/**
* @brief Sets the volume of an auxiliary output.
* @param id ID of the auxiliary output.
* @param volume Volume to set.
*/
ndspAuxSetVolume :: (id: s32, volume: float) -> void #foreign libctru;

/**
* @brief Sets the callback of an auxiliary output.
* @param id ID of the auxiliary output.
* @param callback Callback to set.
* @param data User-defined data to pass to the callback.
*/
ndspAuxSetCallback :: (id: s32, callback: ndspAuxCallback, data: *void) -> void #foreign libctru;

///@name Data types
///@{
/// Supported sample encodings.
NDSP_ENCODING :: enum u8 {
    PCM8  :: 0;
    PCM16 :: 1;
    ADPCM :: 2;
}

/// Channel format flags for use with ndspChnSetFormat.
NDSP :: enum u8 {
    FORMAT_MONO_PCM8          :: 1;
    FORMAT_MONO_PCM16         :: 5;
    FORMAT_MONO_ADPCM         :: 9;
    FORMAT_STEREO_PCM8        :: 2;
    FORMAT_STEREO_PCM16       :: 6;
    FORMAT_PCM8               :: 1;
    FORMAT_PCM16              :: 5;
    FORMAT_ADPCM              :: 9;
    FRONT_BYPASS              :: 16;
    _3D_SURROUND_PREPROCESSED :: 64;
}

/// Interpolation types.
ndspInterpType :: enum u8 {
    POLYPHASE :: 0;
    LINEAR    :: 1;
    NONE      :: 2;
}

///@name Basic channel operation
///@{
/**
* @brief Resets a channel.
* @param id ID of the channel (0..23).
*/
ndspChnReset :: (id: s32) -> void #foreign libctru;

/**
* @brief Initializes the parameters of a channel.
* @param id ID of the channel (0..23).
*/
ndspChnInitParams :: (id: s32) -> void #foreign libctru;

/**
* @brief Checks whether a channel is currently playing.
* @param id ID of the channel (0..23).
* @return Whether the channel is currently playing.
*/
ndspChnIsPlaying :: (id: s32) -> bool #foreign libctru;

/**
* @brief Gets the current sample position of a channel.
* @param id ID of the channel (0..23).
* @return The channel's sample position.
*/
ndspChnGetSamplePos :: (id: s32) -> u32 #foreign libctru;

/**
* @brief Gets the sequence ID of the wave buffer that is currently playing in a channel.
* @param id ID of the channel (0..23).
* @return The sequence ID of the wave buffer.
*/
ndspChnGetWaveBufSeq :: (id: s32) -> u16 #foreign libctru;

/**
* @brief Checks whether a channel is currently paused.
* @param id ID of the channel (0..23).
* @return Whether the channel is currently paused.
*/
ndspChnIsPaused :: (id: s32) -> bool #foreign libctru;

/**
* @brief Sets the pause status of a channel.
* @param id ID of the channel (0..23).
* @param paused Whether the channel is to be paused (true) or unpaused (false).
*/
ndspChnSetPaused :: (id: s32, paused: bool) -> void #foreign libctru;

///@name Configuration
///@{
/**
* @brief Sets the format of a channel.
* @param id ID of the channel (0..23).
* @param format Format to use.
*/
ndspChnSetFormat :: (id: s32, format: u16) -> void #foreign libctru;

/**
* @brief Sets the interpolation type of a channel.
* @param id ID of the channel (0..23).
* @param type Interpolation type to use.
*/
ndspChnSetInterp :: (id: s32, type: ndspInterpType) -> void #foreign libctru;

/**
* @brief Sets the sample rate of a channel.
* @param id ID of the channel (0..23).
* @param rate Sample rate to use.
*/
ndspChnSetRate :: (id: s32, rate: float) -> void #foreign libctru;

/**
* @brief Sets the mix parameters (volumes) of a channel.
* @param id ID of the channel (0..23).
* @param mix Mix parameters to use. Working hypothesis:
*   - 0: Front left volume.
*   - 1: Front right volume.
*   - 2: Back left volume:
*   - 3: Back right volume:
*   - 4..7: Same as 0..3, but for auxiliary output 0.
*   - 8..11: Same as 0..3, but for auxiliary output 1.
*/
ndspChnSetMix :: (id: s32, mix: *[12] float) -> void #foreign libctru;

/**
* @brief Sets the DSPADPCM coefficients of a channel.
* @param id ID of the channel (0..23).
* @param coefs DSPADPCM coefficients to use.
*/
ndspChnSetAdpcmCoefs :: (id: s32, coefs: *[16] u16) -> void #foreign libctru;

///@name Wave buffers
///@{
/**
* @brief Clears the wave buffer queue of a channel and stops playback.
* @param id ID of the channel (0..23).
*/
ndspChnWaveBufClear :: (id: s32) -> void #foreign libctru;

/**
* @brief Adds a wave buffer to the wave buffer queue of a channel.
* @remark If the channel's wave buffer queue was empty before the use of this function, playback is started.
* @param id ID of the channel (0..23).
* @param buf Wave buffer to add.
*/
ndspChnWaveBufAdd :: (id: s32, buf: *ndspWaveBuf) -> void #foreign libctru;

///@name IIR filters
///@{
/**
* @brief Configures whether the IIR monopole filter of a channel is enabled.
* @param id ID of the channel (0..23).
* @param enable Whether to enable the IIR monopole filter.
*/
ndspChnIirMonoSetEnable :: (id: s32, enable: bool) -> void #foreign libctru;

/**
* @brief Manually sets up the parameters on monopole filter
* @param id ID of the channel (0..23).
* @param enable Whether to enable the IIR monopole filter.
*/
ndspChnIirMonoSetParamsCustomFilter :: (id: s32, a0: float, a1: float, b0: float) -> bool #foreign libctru;

/**
* @brief Sets the monopole to be a low pass filter. (Note: This is a lower-quality filter than the biquad one.)
* @param id ID of the channel (0..23).
* @param f0 Low pass cut-off frequency.
*/
ndspChnIirMonoSetParamsLowPassFilter :: (id: s32, f0: float) -> bool #foreign libctru;

/**
* @brief Sets the monopole to be a high pass filter. (Note: This is a lower-quality filter than the biquad one.)
* @param id ID of the channel (0..23).
* @param f0 High pass cut-off frequency.
*/
ndspChnIirMonoSetParamsHighPassFilter :: (id: s32, f0: float) -> bool #foreign libctru;

/**
* @brief Configures whether the IIR biquad filter of a channel is enabled.
* @param id ID of the channel (0..23).
* @param enable Whether to enable the IIR biquad filter.
*/
ndspChnIirBiquadSetEnable :: (id: s32, enable: bool) -> void #foreign libctru;

/**
* @brief Manually sets up the parameters of the biquad filter
* @param id ID of the channel (0..23).
*/
ndspChnIirBiquadSetParamsCustomFilter :: (id: s32, a0: float, a1: float, a2: float, b0: float, b1: float, b2: float) -> bool #foreign libctru;

/**
* @brief Sets the biquad to be a low pass filter.
* @param id ID of the channel (0..23).
* @param f0 Low pass cut-off frequency.
* @param Q "Quality factor", typically should be sqrt(2)/2 (i.e. 0.7071).
*/
ndspChnIirBiquadSetParamsLowPassFilter :: (id: s32, f0: float, Q: float) -> bool #foreign libctru;

/**
* @brief Sets the biquad to be a high pass filter.
* @param id ID of the channel (0..23).
* @param f0 High pass cut-off frequency.
* @param Q "Quality factor", typically should be sqrt(2)/2 (i.e. 0.7071).
*/
ndspChnIirBiquadSetParamsHighPassFilter :: (id: s32, f0: float, Q: float) -> bool #foreign libctru;

/**
* @brief Sets the biquad to be a band pass filter.
* @param id ID of the channel (0..23).
* @param f0 Mid-frequency.
* @param Q "Quality factor", typically should be sqrt(2)/2 (i.e. 0.7071).
*/
ndspChnIirBiquadSetParamsBandPassFilter :: (id: s32, f0: float, Q: float) -> bool #foreign libctru;

/**
* @brief Sets the biquad to be a notch filter.
* @param id ID of the channel (0..23).
* @param f0 Notch frequency.
* @param Q "Quality factor", typically should be sqrt(2)/2 (i.e. 0.7071).
*/
ndspChnIirBiquadSetParamsNotchFilter :: (id: s32, f0: float, Q: float) -> bool #foreign libctru;

/**
* @brief Sets the biquad to be a peaking equalizer.
* @param id ID of the channel (0..23).
* @param f0 Central frequency.
* @param Q "Quality factor", typically should be sqrt(2)/2 (i.e. 0.7071).
* @param gain Amount of gain (raw value = 10 ^ dB/40)
*/
ndspChnIirBiquadSetParamsPeakingEqualizer :: (id: s32, f0: float, Q: float, gain: float) -> bool #foreign libctru;

/// Keyboard types.
SwkbdType :: enum u8 {
    NORMAL  :: 0;
    QWERTY  :: 1;
    NUMPAD  :: 2;
    WESTERN :: 3;
}

/// Accepted input types.
SwkbdValidInput :: enum u8 {
    ANYTHING          :: 0;
    NOTEMPTY          :: 1;
    NOTEMPTY_NOTBLANK :: 2;
    NOTBLANK_NOTEMPTY :: 2;
    NOTBLANK          :: 3;
    FIXEDLEN          :: 4;
}

/// Keyboard dialog buttons.
SwkbdButton :: enum u8 {
    LEFT    :: 0;
    MIDDLE  :: 1;
    RIGHT   :: 2;
    CONFIRM :: 2;
    NONE    :: 3;
}

/// Keyboard password modes.
SwkbdPasswordMode :: enum u8 {
    NONE       :: 0;
    HIDE       :: 1;
    HIDE_DELAY :: 2;
}

/// Keyboard input filtering flags.
SWKBD_FILTER :: enum u8 {
    DIGITS    :: 1;
    AT        :: 2;
    PERCENT   :: 4;
    BACKSLASH :: 8;
    PROFANITY :: 16;
    CALLBACK  :: 32;
}

/// Keyboard features.
SWKBD :: enum u16 {
    PARENTAL          :: 1;
    DARKEN_TOP_SCREEN :: 2;
    PREDICTIVE_INPUT  :: 4;
    MULTILINE         :: 8;
    FIXED_WIDTH       :: 16;
    ALLOW_HOME        :: 32;
    ALLOW_RESET       :: 64;
    ALLOW_POWER       :: 128;
    DEFAULT_QWERTY    :: 512;
}

/// Keyboard filter callback return values.
SwkbdCallbackResult :: enum u8 {
    OK       :: 0;
    CLOSE    :: 1;
    CONTINUE :: 2;
}

/// Keyboard return values.
SwkbdResult :: enum s8 {
    NONE          :: -1;
    INVALID_INPUT :: -2;
    OUTOFMEM      :: -3;
    D0_CLICK      :: 0;
    D1_CLICK0     :: 1;
    D1_CLICK1     :: 2;
    D2_CLICK0     :: 3;
    D2_CLICK1     :: 4;
    D2_CLICK2     :: 5;
    HOMEPRESSED   :: 10;
    RESETPRESSED  :: 11;
    POWERPRESSED  :: 12;
    PARENTAL_OK   :: 20;
    PARENTAL_FAIL :: 21;
    BANNED_INPUT  :: 30;
}

/// Keyboard dictionary word for predictive input.
SwkbdDictWord :: struct {
    reading:       [41] u16; ///< Reading of the word (that is, the string that needs to be typed).
    word:          [41] u16; ///< Spelling of the word.
    language:      u8; ///< Language the word applies to.
    all_languages: bool; ///< Specifies if the word applies to all languages.
}

/// Keyboard filter callback function.
SwkbdCallbackFn :: #type (user: *void, ppMessage: **u8, text: *u8, textlen: size_t) -> SwkbdCallbackResult #c_call;

/// Keyboard status data.
SwkbdStatusData :: struct {
    data: [17] u32;
}

/// Keyboard predictive input learning data.
SwkbdLearningData :: struct {
    data: [10523] u32;
}

/// Internal libctru book-keeping structure for software keyboards.
SwkbdExtra :: struct {
    initial_text:  *u8;
    dict:          *SwkbdDictWord #align 4;
    status_data:   *SwkbdStatusData;
    learning_data: *SwkbdLearningData #align 4;
    callback:      SwkbdCallbackFn;
    callback_user: *void #align 4;
}

/// Software keyboard parameter structure, it shouldn't be modified directly.
SwkbdState :: struct {
    type:                    s32;
    num_buttons_m1:          s32;
    valid_input:             s32;
    password_mode:           s32;
    is_parental_screen:      s32;
    darken_top_screen:       s32;
    filter_flags:            u32;
    save_state_flags:        u32;
    max_text_len:            u16;
    dict_word_count:         u16;
    max_digits:              u16;
    button_text:             [3] [17] u16;
    numpad_keys:             [2] u16;
    hint_text:               [65] u16;
    predictive_input:        bool;
    multiline:               bool;
    fixed_width:             bool;
    allow_home:              bool;
    allow_reset:             bool;
    allow_power:             bool;
    unknown:                 bool; // XX: what is this supposed to do? "communicateWithOtherRegions"
    default_qwerty:          bool;
    button_submits_text:     [4] bool;
    language:                u16; // XX: not working? supposedly 0 = use system language, CFG_Language+1 = pick language
    initial_text_offset:     s32;
    dict_offset:             s32;
    initial_status_offset:   s32;
    initial_learning_offset: s32;
    shared_memory_size:      size_t;
    version:                 u32;
    result:                  SwkbdResult;
    status_offset:           s32;
    learning_offset:         s32;
    text_offset:             s32;
    text_length:             u16;
    callback_result:         s32;
    callback_msg:            [257] u16;
    skip_at_check:           bool;
    union {
        reserved: [171] u8;
        extra:    SwkbdExtra;
    }
}

/**
* @brief Initializes software keyboard status.
* @param swkbd Pointer to swkbd state.
* @param type Keyboard type.
* @param numButtons Number of dialog buttons to display (1, 2 or 3).
* @param maxTextLength Maximum number of UTF-16 code units that input text can have (or -1 to let libctru use a big default).
*/
swkbdInit :: (swkbd: *SwkbdState, type: SwkbdType, numButtons: s32, maxTextLength: s32) -> void #foreign libctru;

/**
* @brief Specifies which special features are enabled in a software keyboard.
* @param swkbd Pointer to swkbd state.
* @param features Feature bitmask.
*/
swkbdSetFeatures :: (swkbd: *SwkbdState, features: u32) -> void #foreign libctru;

/**
* @brief Sets the hint text of a software keyboard (that is, the help text that is displayed when the textbox is empty).
* @param swkbd Pointer to swkbd state.
* @param text Hint text.
*/
swkbdSetHintText :: (swkbd: *SwkbdState, text: *u8) -> void #foreign libctru;

/**
* @brief Configures a dialog button in a software keyboard.
* @param swkbd Pointer to swkbd state.
* @param button Specifies which button to configure.
* @param text Button text.
* @param submit Specifies whether pushing the button will submit the text or discard it.
*/
swkbdSetButton :: (swkbd: *SwkbdState, button: SwkbdButton, text: *u8, submit: bool) -> void #foreign libctru;

/**
* @brief Sets the initial text that a software keyboard will display on launch.
* @param swkbd Pointer to swkbd state.
* @param text Initial text.
*/
swkbdSetInitialText :: (swkbd: *SwkbdState, text: *u8) -> void #foreign libctru;

/**
* @brief Configures a word in a predictive dictionary for use with a software keyboard.
* @param word Pointer to dictionary word structure.
* @param reading Reading of the word, that is, the sequence of characters that need to be typed to trigger the word in the predictive input system.
* @param text Spelling of the word, that is, the actual characters that will be produced when the user decides to select the word.
*/
swkbdSetDictWord :: (word: *SwkbdDictWord, reading: *u8, text: *u8) -> void #foreign libctru;

/**
* @brief Sets the custom word dictionary to be used with the predictive input system of a software keyboard.
* @param swkbd Pointer to swkbd state.
* @param dict Pointer to dictionary words.
* @param wordCount Number of words in the dictionary.
*/
swkbdSetDictionary :: (swkbd: *SwkbdState, dict: *SwkbdDictWord, wordCount: s32) -> void #foreign libctru;

/**
* @brief Configures software keyboard internal status management.
* @param swkbd Pointer to swkbd state.
* @param data Pointer to internal status structure (can be in, out or both depending on the other parameters).
* @param in Specifies whether the data should be read from the structure when the keyboard is launched.
* @param out Specifies whether the data should be written to the structure when the keyboard is closed.
*/
swkbdSetStatusData :: (swkbd: *SwkbdState, data: *SwkbdStatusData, in: bool, out: bool) -> void #foreign libctru;

/**
* @brief Configures software keyboard predictive input learning data management.
* @param swkbd Pointer to swkbd state.
* @param data Pointer to learning data structure (can be in, out or both depending on the other parameters).
* @param in Specifies whether the data should be read from the structure when the keyboard is launched.
* @param out Specifies whether the data should be written to the structure when the keyboard is closed.
*/
swkbdSetLearningData :: (swkbd: *SwkbdState, data: *SwkbdLearningData, in: bool, out: bool) -> void #foreign libctru;

/**
* @brief Configures a custom function to be used to check the validity of input when it is submitted in a software keyboard.
* @param swkbd Pointer to swkbd state.
* @param callback Filter callback function.
* @param user Custom data to be passed to the callback function.
*/
swkbdSetFilterCallback :: (swkbd: *SwkbdState, callback: SwkbdCallbackFn, user: *void) -> void #foreign libctru;

/**
* @brief Launches a software keyboard in order to input text.
* @param swkbd Pointer to swkbd state.
* @param buf Pointer to output buffer which will hold the inputted text.
* @param bufsize Maximum number of UTF-8 code units that the buffer can hold (including null terminator).
* @return The identifier of the dialog button that was pressed, or SWKBD_BUTTON_NONE if a different condition was triggered - in that case use swkbdGetResult to check the condition.
*/
swkbdInputText :: (swkbd: *SwkbdState, buf: *u8, bufsize: size_t) -> SwkbdButton #foreign libctru;

ERROR :: enum u16 {
    LANGUAGE_FLAG  :: 256;
    WORD_WRAP_FLAG :: 512;
}

errorType :: enum u16 {
    CODE                    :: 0;
    TEXT                    :: 1;
    EULA                    :: 2;
    TYPE_EULA_FIRST_BOOT    :: 3;
    TYPE_EULA_DRAW_ONLY     :: 4;
    TYPE_AGREE              :: 5;
    CODE_LANGUAGE           :: 256;
    TEXT_LANGUAGE           :: 257;
    EULA_LANGUAGE           :: 258;
    TEXT_WORD_WRAP          :: 513;
    TEXT_LANGUAGE_WORD_WRAP :: 769;
}

errorScreenFlag :: enum u8 {
    NORMAL :: 0;
    STEREO :: 1;
}

errorReturnCode :: enum s8 {
    UNKNOWN        :: -1;
    NONE           :: 0;
    SUCCESS        :: 1;
    NOT_SUPPORTED  :: 2;
    HOME_BUTTON    :: 10;
    SOFTWARE_RESET :: 11;
    POWER_BUTTON   :: 12;
}

errorConf :: struct {
    type:            errorType;
    errorCode:       s32;
    upperScreenFlag: errorScreenFlag;
    useLanguage:     u16;
    Text:            [1900] u16;
    homeButton:      bool;
    softwareReset:   bool;
    appJump:         bool;
    returnCode:      errorReturnCode;
    eulaVersion:     u16;
}

/**
* @brief Init the error applet.
* @param err Pointer to errorConf.
* @param type errorType Type of error.
* @param lang CFG_Language Lang of error. 
*/
errorInit :: (err: *errorConf, type: errorType, lang: CFG_Language) -> void #foreign libctru;

/**
* @brief Sets error code to display.
* @param err Pointer to errorConf.
* @param error Error-code to display.
*/
errorCode :: (err: *errorConf, error: s32) -> void #foreign libctru;

/**
* @brief Sets error text to display.
* @param err Pointer to errorConf.
* @param text Error-text to display.
*/
errorText :: (err: *errorConf, text: *u8) -> void #foreign libctru;

/**
* @brief Displays the error applet.
* @param err Pointer to errorConf.
*/
errorDisp :: (err: *errorConf) -> void #foreign libctru;

/// Parameter structure passed to AppletEd
MiiSelectorConf :: struct {
    enable_cancel_button:    u8; ///< Enables canceling of selection if nonzero.
    enable_selecting_guests: u8; ///< Makes Guets Miis selectable if nonzero.
    ///< Shows applet on top screen if nonzero,
    ///< otherwise show it on the bottom screen.
    show_on_top_screen:      u8;
    _unk0x3:                 [5] u8; ///< @private
    ///< UTF16-LE string displayed at the top of the applet. If
    ///< set to the empty string, a default title is displayed.
    title:                   [64] u16;
    _unk0x88:                [4] u8; ///< @private
    ///< If nonzero, the applet shows a page with Guest
    ///< Miis on launch.
    show_guest_page:         u8;
    _unk0x8D:                [3] u8; ///< @private
    ///< Index of the initially selected Mii. If
    ///< @ref MiiSelectorConf.show_guest_page is
    ///< set, this is the index of a Guest Mii,
    ///< otherwise that of a user Mii.
    initial_index:           u32;
    ///< Each byte set to a nonzero value
    ///< enables its corresponding Guest
    ///< Mii to be enabled for selection.
    mii_guest_whitelist:     [6] u8;
    ///< Each byte set to a nonzero value enables
    ///< its corresponding user Mii to be enabled
    ///< for selection.
    mii_whitelist:           [100] u8;
    _unk0xFE:                u16; ///< @private
    ///< Will be set to @ref MIISELECTOR_MAGIC before launching the
    ///< applet.
    magic:                   u32;
}

/// Structure written by AppletEd
MiiSelectorReturn :: struct {
    ///< 0 if a Mii was selected, 1 if the selection was
    ///< canceled.
    no_mii_selected:        u32;
    guest_mii_was_selected: u32; ///< 1 if a Guest Mii was selected, 0 otherwise.
    ///< Index of the selected Guest Mii,
    ///< 0xFFFFFFFF if no guest was selected.
    guest_mii_index:        u32;
    mii:                    MiiData #align 4; ///< Data of selected Mii.
    _pad0x68:               u16; ///< @private
    ///< Checksum of the returned Mii data.
    ///< Stored as a big-endian value; use
    ///< @ref miiSelectorChecksumIsValid to
    ///< verify.
    checksum:               u16;
    ///< Localized name of a Guest Mii,
    ///< if one was selected (UTF16-LE
    ///< string). Zeroed otherwise.
    guest_mii_name:         [12] u16;
}

/// AppletEd options
MIISELECTOR :: enum u8 {
    CANCEL     :: 1;
    GUESTS     :: 2;
    TOP        :: 4;
    GUESTSTART :: 8;
}

/**
* @brief Initialize Mii selector config
* @param conf Pointer to Miiselector config.
*/
miiSelectorInit :: (conf: *MiiSelectorConf) -> void #foreign libctru;

/**
* @brief Launch the Mii selector library applet
*
* @param conf Configuration determining how the applet should behave
*/
miiSelectorLaunch :: (conf: *MiiSelectorConf, returnbuf: *MiiSelectorReturn) -> void #foreign libctru;

/**
* @brief Sets title of the Mii selector library applet
*
* @param conf Pointer to miiSelector configuration
* @param text Title text of Mii selector
*/
miiSelectorSetTitle :: (conf: *MiiSelectorConf, text: *u8) -> void #foreign libctru;

/**
* @brief Specifies which special options are enabled in the Mii selector
*
* @param conf Pointer to miiSelector configuration
* @param options Options bitmask
*/
miiSelectorSetOptions :: (conf: *MiiSelectorConf, options: u32) -> void #foreign libctru;

/**
* @brief Specifies which guest Miis will be selectable
*
* @param conf Pointer to miiSelector configuration
* @param index Index of the guest Miis that will be whitelisted.
* @ref MIISELECTOR_GUESTMII_SLOTS can be used to whitelist all the guest Miis.
*/
miiSelectorWhitelistGuestMii :: (conf: *MiiSelectorConf, index: u32) -> void #foreign libctru;

/**
* @brief Specifies which guest Miis will be unselectable
*
* @param conf Pointer to miiSelector configuration
* @param index Index of the guest Miis that will be blacklisted.
* @ref MIISELECTOR_GUESTMII_SLOTS can be used to blacklist all the guest Miis.
*/
miiSelectorBlacklistGuestMii :: (conf: *MiiSelectorConf, index: u32) -> void #foreign libctru;

/**
* @brief Specifies which user Miis will be selectable
*
* @param conf Pointer to miiSelector configuration
* @param index Index of the user Miis that will be whitelisted.
* @ref MIISELECTOR_USERMII_SLOTS can be used to whitlist all the user Miis
*/
miiSelectorWhitelistUserMii :: (conf: *MiiSelectorConf, index: u32) -> void #foreign libctru;

/**
* @brief Specifies which user Miis will be selectable
*
* @param conf Pointer to miiSelector configuration
* @param index Index of the user Miis that will be blacklisted.
* @ref MIISELECTOR_USERMII_SLOTS can be used to blacklist all the user Miis
*/
miiSelectorBlacklistUserMii :: (conf: *MiiSelectorConf, index: u32) -> void #foreign libctru;

/**
* @brief Get Mii name
*
* @param returnbuf Pointer to miiSelector return
* @param out String containing a Mii's name
* @param max_size Size of string. Since UTF8 characters range in size from 1-3 bytes
* (assuming that no non-BMP characters are used), this value should be 36 (or 30 if you are not
* dealing with guest miis).
*/
miiSelectorReturnGetName :: (returnbuf: *MiiSelectorReturn, out: *u8, max_size: size_t) -> void #foreign libctru;

/**
* @brief Get Mii Author
*
* @param returnbuf Pointer to miiSelector return
* @param out String containing a Mii's author
* @param max_size Size of string. Since UTF8 characters range in size from 1-3 bytes
* (assuming that no non-BMP characters are used), this value should be 30.
*/
miiSelectorReturnGetAuthor :: (returnbuf: *MiiSelectorReturn, out: *u8, max_size: size_t) -> void #foreign libctru;

/**
* @brief Verifies that the Mii data returned from the applet matches its
* checksum
*
* @param returnbuf Buffer filled by Mii selector applet
* @return `true` if `returnbuf->checksum` is the same as the one computed from `returnbuf`
*/
miiSelectorChecksumIsValid :: (returnbuf: *MiiSelectorReturn) -> bool #foreign libctru;

/*! Open directory struct */
archive_dir_t :: struct {
    magic:      u32;
    /*! "arch" */
    fd:         Handle;
    /*! CTRU handle */
    index:      ssize_t;
    /*! Current entry index */
    size:       size_t;
    /*! Current batch size */
    entry_data: [32] FS_DirectoryEntry;
}

/// Mounts the SD
archiveMountSdmc :: () -> Result #foreign libctru;

/// Mounts and opens an archive as deviceName
/// Returns either an archive open error code, or -1 for generic failure
archiveMount :: (archiveID: FS_ArchiveID, archivePath: FS_Path, deviceName: *u8) -> Result #foreign libctru;

/// Uses FSUSER_ControlArchive with control action ARCHIVE_ACTION_COMMIT_SAVE_DATA on the opened archive. Not done automatically at unmount.
/// Returns -1 if the specified device is not found
archiveCommitSaveData :: (deviceName: *u8) -> Result #foreign libctru;

/// Unmounts the specified device, closing its archive in the process
/// Returns -1 if the specified device was not found
archiveUnmount :: (deviceName: *u8) -> Result #foreign libctru;

/// Unmounts all devices and cleans up any resources used by the driver
archiveUnmountAll :: () -> Result #foreign libctru;

/// Get a file's mtime
archive_getmtime :: (name: *u8, mtime: *u64) -> Result #foreign libctru;

/// RomFS header.
romfs_header :: struct {
    headerSize:        u32; ///< Size of the header.
    dirHashTableOff:   u32; ///< Offset of the directory hash table.
    dirHashTableSize:  u32; ///< Size of the directory hash table.
    dirTableOff:       u32; ///< Offset of the directory table.
    dirTableSize:      u32; ///< Size of the directory table.
    fileHashTableOff:  u32; ///< Offset of the file hash table.
    fileHashTableSize: u32; ///< Size of the file hash table.
    fileTableOff:      u32; ///< Offset of the file table.
    fileTableSize:     u32; ///< Size of the file table.
    fileDataOff:       u32; ///< Offset of the file data.
}

/// RomFS directory.
romfs_dir :: struct {
    parent:    u32; ///< Offset of the parent directory.
    sibling:   u32; ///< Offset of the next sibling directory.
    childDir:  u32; ///< Offset of the first child directory.
    childFile: u32; ///< Offset of the first file.
    nextHash:  u32; ///< Directory hash table pointer.
    nameLen:   u32; ///< Name length.
    name:      *u16; ///< Name. (UTF-16)
}

/// RomFS file.
romfs_file :: struct {
    parent:   u32; ///< Offset of the parent directory.
    sibling:  u32; ///< Offset of the next sibling file.
    dataOff:  u64; ///< Offset of the file's data.
    dataSize: u64; ///< Length of the file's data.
    nextHash: u32; ///< File hash table pointer.
    nameLen:  u32; ///< Name length.
    name:     *u16; ///< Name. (UTF-16)
}

/**
* @brief Mounts the Application's RomFS.
* @param name Device mount name.
* @remark This function is intended to be used to access one's own RomFS.
*         If the application is running as 3DSX, it mounts the embedded RomFS section inside the 3DSX.
*         If on the other hand it's an NCCH, it behaves identically to \ref romfsMountFromCurrentProcess.
*/
romfsMountSelf :: (name: *u8) -> Result #foreign libctru;

/**
* @brief Mounts RomFS from an open file.
* @param fd FSFILE handle of the RomFS image.
* @param offset Offset of the RomFS within the file.
* @param name Device mount name.
*/
romfsMountFromFile :: (fd: Handle, offset: u32, name: *u8) -> Result #foreign libctru;

/**
* @brief Mounts RomFS using the current process host program RomFS.
* @param name Device mount name.
*/
romfsMountFromCurrentProcess :: (name: *u8) -> Result #foreign libctru;

/**
* @brief Mounts RomFS from the specified title.
* @param tid Title ID
* @param mediatype Mediatype
* @param name Device mount name.
*/
romfsMountFromTitle :: (tid: u64, mediatype: FS_MediaType, name: *u8) -> Result #foreign libctru;

/// Unmounts the RomFS device.
romfsUnmount :: (name: *u8) -> Result #foreign libctru;

/// Character width information structure.
charWidthInfo_s :: struct {
    left:       s8; ///< Horizontal offset to draw the glyph with.
    glyphWidth: u8; ///< Width of the glyph.
    charWidth:  u8; ///< Width of the character, that is, horizontal distance to advance.
}

/// Font texture sheet information.
TGLP_s :: struct {
    cellWidth:    u8; ///< Width of a glyph cell.
    cellHeight:   u8; ///< Height of a glyph cell.
    baselinePos:  u8; ///< Vertical position of the baseline.
    maxCharWidth: u8; ///< Maximum character width.
    sheetSize:    u32; ///< Size in bytes of a texture sheet.
    nSheets:      u16; ///< Number of texture sheets.
    sheetFmt:     u16; ///< GPU texture format (GPU_TEXCOLOR).
    nRows:        u16; ///< Number of glyphs per row per sheet.
    nLines:       u16; ///< Number of glyph rows per sheet.
    sheetWidth:   u16; ///< Texture sheet width.
    sheetHeight:  u16; ///< Texture sheet height.
    sheetData:    *u8 #align 4; ///< Pointer to texture sheet data.
}

/// Font character width information block type.
CWDH_s :: tag_CWDH_s;

/// Font character width information block structure.
tag_CWDH_s :: struct {
    startIndex: u16; ///< First Unicode codepoint the block applies to.
    endIndex:   u16; ///< Last Unicode codepoint the block applies to.
    next:       *CWDH_s #align 4; ///< Pointer to the next block.
    widths:     [0] charWidthInfo_s; ///< Table of character width information structures.
}

/// Font character map methods.
CMAP_TYPE :: enum u8 {
    DIRECT :: 0;
    TABLE  :: 1;
    SCAN   :: 2;
}

/// Font character map type.
CMAP_s :: tag_CMAP_s;

/// Font character map structure.
tag_CMAP_s :: struct {
    codeBegin:     u16; ///< First Unicode codepoint the block applies to.
    codeEnd:       u16; ///< Last Unicode codepoint the block applies to.
    mappingMethod: u16; ///< Mapping method.
    reserved:      u16;
    next:          *CMAP_s; ///< Pointer to the next map.
    union {
        indexOffset: u16; ///< For CMAP_TYPE_DIRECT: index of the first glyph.
        indexTable:  [0] u16; ///< For CMAP_TYPE_TABLE: table of glyph indices.
        /// For CMAP_TYPE_SCAN: Mapping data.
        struct {
            nScanEntries: u16; ///< Number of pairs.
            scanEntries:  [0] struct {
                code:       u16; ///< Unicode codepoint.
                glyphIndex: u16; ///< Mapped glyph index.
            };
        }
    }
}

/// Font information structure.
FINF_s :: struct {
    signature:      u32; ///< Signature (FINF).
    sectionSize:    u32; ///< Section size.
    fontType:       u8; ///< Font type
    lineFeed:       u8; ///< Line feed vertical distance.
    alterCharIndex: u16; ///< Glyph index of the replacement character.
    defaultWidth:   charWidthInfo_s; ///< Default character width information.
    encoding:       u8; ///< Font encoding (?)
    tglp:           *TGLP_s; ///< Pointer to texture sheet information.
    cwdh:           *CWDH_s #align 4; ///< Pointer to the first character width information block.
    cmap:           *CMAP_s; ///< Pointer to the first character map.
    height:         u8; ///< Font height.
    width:          u8; ///< Font width.
    ascent:         u8; ///< Font ascent.
    padding:        u8;
}

/// Font structure.
CFNT_s :: struct {
    signature:  u32; ///< Signature (CFNU).
    endianness: u16; ///< Endianness constant (0xFEFF).
    headerSize: u16; ///< Header size.
    version:    u32; ///< Format version.
    fileSize:   u32; ///< File size.
    nBlocks:    u32; ///< Number of blocks.
    finf:       FINF_s #align 4; ///< Font information.
}

/// Font glyph position structure.
fontGlyphPos_s :: struct {
    sheetIndex: s32; ///< Texture sheet index to use to render the glyph.
    xOffset:    float; ///< Horizontal offset to draw the glyph width.
    xAdvance:   float; ///< Horizontal distance to advance after drawing the glyph.
    width:      float; ///< Glyph width.
    texcoord:   struct {
        left:   float;
        top:    float;
        right:  float;
        bottom: float;
    };
    vtxcoord:   struct {
        left:   float;
        top:    float;
        right:  float;
        bottom: float;
    };
}

/// Flags for use with fontCalcGlyphPos.
GLYPH_POS :: enum u8 {
    CALC_VTXCOORD :: 1;
    AT_BASELINE   :: 2;
    Y_POINTS_UP   :: 4;
}

/// Ensures the shared system font is mapped.
fontEnsureMapped :: () -> Result #foreign libctru;

/**
* @brief Fixes the pointers internal to a just-loaded font
* @param font Font to fix
* @remark Should never be run on the system font, and only once on any other font.
*/
fontFixPointers :: (font: *CFNT_s) -> void #foreign libctru;

/**
* @brief Retrieves the glyph index of the specified Unicode codepoint.
* @param font Pointer to font structure. If NULL, the shared system font is used.
* @param codePoint Unicode codepoint.
*/
fontGlyphIndexFromCodePoint :: (font: *CFNT_s, codePoint: u32) -> s32 #foreign libctru;

/**
* @brief Retrieves character width information of the specified glyph.
* @param font Pointer to font structure. If NULL, the shared system font is used.
* @param glyphIndex Index of the glyph.
*/
fontGetCharWidthInfo :: (font: *CFNT_s, glyphIndex: s32) -> *charWidthInfo_s #foreign libctru;

/**
* @brief Calculates position information for the specified glyph.
* @param out Output structure in which to write the information.
* @param font Pointer to font structure. If NULL, the shared system font is used.
* @param glyphIndex Index of the glyph.
* @param flags Calculation flags (see GLYPH_POS_* flags).
* @param scaleX Scale factor to apply horizontally.
* @param scaleY Scale factor to apply vertically.
*/
fontCalcGlyphPos :: (out: *fontGlyphPos_s, font: *CFNT_s, glyphIndex: s32, flags: u32, scaleX: float, scaleY: float) -> void #foreign libctru;

gdbHioDevInit :: () -> s32 #foreign libctru;

gdbHioDevExit :: () -> void #foreign libctru;

gdbHioDevGetStdin :: () -> s32 #foreign libctru;

gdbHioDevGetStdout :: () -> s32 #foreign libctru;

gdbHioDevGetStderr :: () -> s32 #foreign libctru;

gdbHioDevRedirectStdStreams :: (in: bool, out: bool, err: bool) -> s32 #foreign libctru;

gdbHioDevGettimeofday :: (tv: *timeval, tz: *void) -> s32 #foreign libctru;

gdbHioDevIsatty :: (fd: s32) -> s32 #foreign libctru;

gdbHioDevSystem :: (command: *u8) -> s32 #foreign libctru;

/**
* @brief Connects to the 3dslink host, setting up an output stream.
* @param[in] redirStdout Whether to redirect stdout to nxlink output.
* @param[in] redirStderr Whether to redirect stderr to nxlink output.
* @return Socket fd on success, negative number on failure.
* @note The socket should be closed with close() during application cleanup.
*/
link3dsConnectToHost :: (redirStdout: bool, redirStderr: bool) -> s32 #foreign libctru;

C3D_IVec :: u32;

/**
* @struct C3D_FVec
* @brief Float vector
*
* Matches PICA layout
*/
C3D_FVec :: union {
    /**
    * @brief Vector access
    */
    struct {
        w: float; ///< W-component
        z: float; ///< Z-component
        y: float; ///< Y-component
        x: float; ///< X-component
    }
    /**
    * @brief Quaternion access
    */
    struct {
        r: float; ///< Real component
        k: float; ///< K-component
        j: float; ///< J-component
        i: float; ///< I-component
    }
    /**
    * @brief Raw access
    */
    c: [4] float;
}

/**
* @struct C3D_FQuat
* @brief Float quaternion. See @ref C3D_FVec.
*/
C3D_FQuat :: C3D_FVec;

/**
* @struct C3D_Mtx
* @brief Row-major 4x4 matrix
*/
C3D_Mtx :: union {
    r: [4] C3D_FVec; ///< Rows are vectors
    m: [16] float; ///< Raw access
}

/**
*@brief Transposes the matrix. Row => Column, and vice versa.
*@param[in,out] out     Output matrix.
*/
Mtx_Transpose :: (out: *C3D_Mtx) -> void #foreign libcitro3d;

/**
* @brief Multiply two matrices
* @param[out] out Output matrix
* @param[in]  a   Multiplicand
* @param[in]  b   Multiplier
*/
Mtx_Multiply :: (out: *C3D_Mtx, a: *C3D_Mtx, b: *C3D_Mtx) -> void #foreign libcitro3d;

/**
* @brief Inverse a matrix
* @param[in,out] out Matrix to inverse
* @retval 0.0f Degenerate matrix (no inverse)
* @return determinant
*/
Mtx_Inverse :: (out: *C3D_Mtx) -> float #foreign libcitro3d;

/**
* @brief Multiply 3x3 matrix by a FVec3
* @param[in] mtx Matrix
* @param[in] v   Vector
* @return mtx*v (product)
*/
Mtx_MultiplyFVec3 :: (mtx: *C3D_Mtx, v: C3D_FVec) -> C3D_FVec #foreign libcitro3d;

/**
* @brief Multiply 4x4 matrix by a FVec4
* @param[in] mtx Matrix
* @param[in] v   Vector
* @return mtx*v (product)
*/
Mtx_MultiplyFVec4 :: (mtx: *C3D_Mtx, v: C3D_FVec) -> C3D_FVec #foreign libcitro3d;

/**
* @brief Get 4x4 matrix equivalent to Quaternion
* @param[out] m Output matrix
* @param[in]  q Input Quaternion
*/
Mtx_FromQuat :: (m: *C3D_Mtx, q: C3D_FQuat) -> void #foreign libcitro3d;

/**
* @brief 3D translation
* @param[in,out] mtx Matrix to translate
* @param[in]     x            X component to translate
* @param[in]     y            Y component to translate
* @param[in]     z            Z component to translate
* @param[in]     bRightSide   Whether to transform from the right side
*/
Mtx_Translate :: (mtx: *C3D_Mtx, x: float, y: float, z: float, bRightSide: bool) -> void #foreign libcitro3d;

/**
* @brief 3D Scale
* @param[in,out] mtx Matrix to scale
* @param[in]     x   X component to scale
* @param[in]     y   Y component to scale
* @param[in]     z   Z component to scale
*/
Mtx_Scale :: (mtx: *C3D_Mtx, x: float, y: float, z: float) -> void #foreign libcitro3d;

/**
* @brief 3D Rotation
* @param[in,out] mtx        Matrix to rotate
* @param[in]     axis       Axis about which to rotate
* @param[in]     angle      Radians to rotate
* @param[in]     bRightSide Whether to transform from the right side
*/
Mtx_Rotate :: (mtx: *C3D_Mtx, axis: C3D_FVec, angle: float, bRightSide: bool) -> void #foreign libcitro3d;

/**
* @brief 3D Rotation about the X axis
* @param[in,out] mtx        Matrix to rotate
* @param[in]     angle      Radians to rotate
* @param[in]     bRightSide Whether to transform from the right side
*/
Mtx_RotateX :: (mtx: *C3D_Mtx, angle: float, bRightSide: bool) -> void #foreign libcitro3d;

/**
* @brief 3D Rotation about the Y axis
* @param[in,out] mtx        Matrix to rotate
* @param[in]     angle      Radians to rotate
* @param[in]     bRightSide Whether to transform from the right side
*/
Mtx_RotateY :: (mtx: *C3D_Mtx, angle: float, bRightSide: bool) -> void #foreign libcitro3d;

/**
* @brief 3D Rotation about the Z axis
* @param[in,out] mtx        Matrix to rotate
* @param[in]     angle      Radians to rotate
* @param[in]     bRightSide Whether to transform from the right side
*/
Mtx_RotateZ :: (mtx: *C3D_Mtx, angle: float, bRightSide: bool) -> void #foreign libcitro3d;

/**
* @brief Orthogonal projection
* @param[out] mtx Output matrix
* @param[in]  left         Left clip plane (X=left)
* @param[in]  right        Right clip plane (X=right)
* @param[in]  bottom       Bottom clip plane (Y=bottom)
* @param[in]  top          Top clip plane (Y=top)
* @param[in]  near         Near clip plane (Z=near)
* @param[in]  far          Far clip plane (Z=far)
* @param[in]  isLeftHanded Whether to build a LH projection
* @sa Mtx_OrthoTilt
*/
Mtx_Ortho :: (mtx: *C3D_Mtx, left: float, right: float, bottom: float, top: float, near: float, far: float, isLeftHanded: bool) -> void #foreign libcitro3d;

/**
* @brief Perspective projection
* @param[out] mtx          Output matrix
* @param[in]  fovy         Vertical field of view in radians
* @param[in]  aspect       Aspect ration of projection plane (width/height)
* @param[in]  near         Near clip plane (Z=near)
* @param[in]  far          Far clip plane (Z=far)
* @param[in]  isLeftHanded Whether to build a LH projection
* @sa Mtx_PerspTilt
* @sa Mtx_PerspStereo
* @sa Mtx_PerspStereoTilt
*/
Mtx_Persp :: (mtx: *C3D_Mtx, fovy: float, aspect: float, near: float, far: float, isLeftHanded: bool) -> void #foreign libcitro3d;

/**
* @brief Stereo perspective projection
* @note Typically you will use iod to mean the distance between the eyes. Plug
*       in -iod for the left eye and iod for the right eye.
* @note The focal length is defined by screen. If objects are further than this,
*       they will appear to be inside the screen. If objects are closer than this,
*       they will appear to pop out of the screen. Objects at this distance appear
*       to be at the screen.
* @param[out] mtx          Output matrix
* @param[in]  fovy         Vertical field of view in radians
* @param[in]  aspect       Aspect ration of projection plane (width/height)
* @param[in]  near         Near clip plane (Z=near)
* @param[in]  far          Far clip plane (Z=far)
* @param[in]  iod          Interocular distance
* @param[in]  screen       Focal length
* @param[in]  isLeftHanded Whether to build a LH projection
* @sa Mtx_Persp
* @sa Mtx_PerspTilt
* @sa Mtx_PerspStereoTilt
*/
Mtx_PerspStereo :: (mtx: *C3D_Mtx, fovy: float, aspect: float, near: float, far: float, iod: float, screen: float, isLeftHanded: bool) -> void #foreign libcitro3d;

/**
* @brief Orthogonal projection, tilted to account for the 3DS screen rotation
* @param[out] mtx          Output matrix
* @param[in]  left         Left clip plane (X=left)
* @param[in]  right        Right clip plane (X=right)
* @param[in]  bottom       Bottom clip plane (Y=bottom)
* @param[in]  top          Top clip plane (Y=top)
* @param[in]  near         Near clip plane (Z=near)
* @param[in]  far          Far clip plane (Z=far)
* @param[in]  isLeftHanded Whether to build a LH projection
* @sa Mtx_Ortho
*/
Mtx_OrthoTilt :: (mtx: *C3D_Mtx, left: float, right: float, bottom: float, top: float, near: float, far: float, isLeftHanded: bool) -> void #foreign libcitro3d;

/**
* @brief Perspective projection, tilted to account for the 3DS screen rotation
* @param[out] mtx          Output matrix
* @param[in]  fovy         Vertical field of view in radians
* @param[in]  aspect       Aspect ration of projection plane (width/height)
* @param[in]  near         Near clip plane (Z=near)
* @param[in]  far          Far clip plane (Z=far)
* @param[in]  isLeftHanded Whether to build a LH projection
* @sa Mtx_Persp
* @sa Mtx_PerspStereo
* @sa Mtx_PerspStereoTilt
*/
Mtx_PerspTilt :: (mtx: *C3D_Mtx, fovy: float, aspect: float, near: float, far: float, isLeftHanded: bool) -> void #foreign libcitro3d;

/**
* @brief Stereo perspective projection, tilted to account for the 3DS screen rotation
* @note See the notes for @ref Mtx_PerspStereo
* @param[out] mtx          Output matrix
* @param[in]  fovy         Vertical field of view in radians
* @param[in]  aspect       Aspect ration of projection plane (width/height)
* @param[in]  near         Near clip plane (Z=near)
* @param[in]  far          Far clip plane (Z=far)
* @param[in]  iod          Interocular distance
* @param[in]  screen       Focal length
* @param[in]  isLeftHanded Whether to build a LH projection
* @sa Mtx_Persp
* @sa Mtx_PerspTilt
* @sa Mtx_PerspStereo
*/
Mtx_PerspStereoTilt :: (mtx: *C3D_Mtx, fovy: float, aspect: float, near: float, far: float, iod: float, screen: float, isLeftHanded: bool) -> void #foreign libcitro3d;

/**
* @brief Look-At matrix, based on DirectX implementation
* @note See https://msdn.microsoft.com/en-us/library/windows/desktop/bb205342
* @param[out] out            Output matrix.
* @param[in]  cameraPosition Position of the intended camera in 3D space.
* @param[in]  cameraTarget   Position of the intended target the camera is supposed to face in 3D space.
* @param[in]  cameraUpVector The vector that points straight up depending on the camera's "Up" direction.
* @param[in]  isLeftHanded   Whether to build a LH projection
*/
Mtx_LookAt :: (out: *C3D_Mtx, cameraPosition: C3D_FVec, cameraTarget: C3D_FVec, cameraUpVector: C3D_FVec, isLeftHanded: bool) -> void #foreign libcitro3d;

/**
* @brief Multiply two Quaternions
* @param[in] lhs Multiplicand
* @param[in] rhs Multiplier
* @return lhs*rhs
*/
Quat_Multiply :: (lhs: C3D_FQuat, rhs: C3D_FQuat) -> C3D_FQuat #foreign libcitro3d;

/**
* @brief Raise Quaternion to a power
* @note If p is 0, this returns the identity Quaternion.
*       If p is 1, this returns q.
* @param[in] q Base Quaternion
* @param[in] p Power
* @return q<sup>p</sup>
*/
Quat_Pow :: (q: C3D_FQuat, p: float) -> C3D_FQuat #foreign libcitro3d;

/**
* @brief Cross product of Quaternion and FVec3
* @param[in] q Base Quaternion
* @param[in] v Vector to cross
* @return q×v
*/
Quat_CrossFVec3 :: (q: C3D_FQuat, v: C3D_FVec) -> C3D_FVec #foreign libcitro3d;

/**
* @brief 3D Rotation
* @param[in] q          Quaternion to rotate
* @param[in] axis       Axis about which to rotate
* @param[in] r          Radians to rotate
* @param[in] bRightSide Whether to transform from the right side
* @return Rotated Quaternion
*/
Quat_Rotate :: (q: C3D_FQuat, axis: C3D_FVec, r: float, bRightSide: bool) -> C3D_FQuat #foreign libcitro3d;

/**
* @brief 3D Rotation about the X axis
* @param[in] q          Quaternion to rotate
* @param[in] r          Radians to rotate
* @param[in] bRightSide Whether to transform from the right side
* @return Rotated Quaternion
*/
Quat_RotateX :: (q: C3D_FQuat, r: float, bRightSide: bool) -> C3D_FQuat #foreign libcitro3d;

/**
* @brief 3D Rotation about the Y axis
* @param[in] q          Quaternion to rotate
* @param[in] r          Radians to rotate
* @param[in] bRightSide Whether to transform from the right side
* @return Rotated Quaternion
*/
Quat_RotateY :: (q: C3D_FQuat, r: float, bRightSide: bool) -> C3D_FQuat #foreign libcitro3d;

/**
* @brief 3D Rotation about the Z axis
* @param[in] q          Quaternion to rotate
* @param[in] r          Radians to rotate
* @param[in] bRightSide Whether to transform from the right side
* @return Rotated Quaternion
*/
Quat_RotateZ :: (q: C3D_FQuat, r: float, bRightSide: bool) -> C3D_FQuat #foreign libcitro3d;

/**
* @brief Get Quaternion equivalent to 4x4 matrix
* @note If the matrix is orthogonal or special orthogonal, where determinant(matrix) = +1.0f, then the matrix can be converted.
* @param[in]   m Input  Matrix
* @return      Generated Quaternion
*/
Quat_FromMtx :: (m: *C3D_Mtx) -> C3D_FQuat #foreign libcitro3d;

/**
* @brief Converting Pitch, Yaw, and Roll to Quaternion equivalent
* @param[in] pitch      The pitch angle in radians.
* @param[in] yaw        The yaw angle in radians.
* @param[in] roll       The roll angle in radians.
* @param[in] bRightSide Whether to transform from the right side
* @return    C3D_FQuat  The Quaternion equivalent with the pitch, yaw, and roll (in that order) orientations applied.
*/
Quat_FromPitchYawRoll :: (pitch: float, yaw: float, roll: float, bRightSide: bool) -> C3D_FQuat #foreign libcitro3d;

/**
* @brief Quaternion Look-At
* @param[in] source   C3D_FVec Starting position. Origin of rotation.
* @param[in] target   C3D_FVec Target position to orient towards.
* @param[in] forwardVector C3D_FVec The Up vector.
* @param[in] upVector C3D_FVec The Up vector.
* @return Quaternion rotation.
*/
Quat_LookAt :: (source: C3D_FVec, target: C3D_FVec, forwardVector: C3D_FVec, upVector: C3D_FVec) -> C3D_FQuat #foreign libcitro3d;

/**
* @brief Quaternion, created from a given axis and angle in radians.
* @param[in] axis  C3D_FVec The axis to rotate around at.
* @param[in] angle float The angle to rotate. Unit: Radians
* @return Quaternion rotation based on the axis and angle. Axis doesn't have to be orthogonal.
*/
Quat_FromAxisAngle :: (axis: C3D_FVec, angle: float) -> C3D_FQuat #foreign libcitro3d;

C3D_MtxStack :: struct {
    m:        [8] C3D_Mtx;
    pos:      s32;
    unifType: u8;
    unifPos:  u8;
    unifLen:  u8;
    isDirty:  bool;
}

MtxStack_Init :: (stk: *C3D_MtxStack) -> void #foreign libcitro3d;
MtxStack_Bind :: (stk: *C3D_MtxStack, unifType: GPU_SHADER_TYPE, unifPos: s32, unifLen: s32) -> void #foreign libcitro3d;
MtxStack_Push :: (stk: *C3D_MtxStack) -> *C3D_Mtx #foreign libcitro3d;
MtxStack_Pop :: (stk: *C3D_MtxStack) -> *C3D_Mtx #foreign libcitro3d;
MtxStack_Update :: (stk: *C3D_MtxStack) -> void #foreign libcitro3d;

C3D_UpdateUniforms :: (type: GPU_SHADER_TYPE) -> void #foreign libcitro3d;

C3D_AttrInfo :: struct {
    flags:       [2] u32;
    permutation: u64;
    attrCount:   s32;
}

AttrInfo_Init :: (info: *C3D_AttrInfo) -> void #foreign libcitro3d;
AttrInfo_AddLoader :: (info: *C3D_AttrInfo, regId: s32, format: GPU_FORMATS, count: s32) -> s32 #foreign libcitro3d;
AttrInfo_AddFixed :: (info: *C3D_AttrInfo, regId: s32) -> s32 #foreign libcitro3d;

C3D_GetAttrInfo :: () -> *C3D_AttrInfo #foreign libcitro3d;
C3D_SetAttrInfo :: (info: *C3D_AttrInfo) -> void #foreign libcitro3d;

C3D_BufCfg :: struct {
    offset: u32;
    flags:  [2] u32;
}

C3D_BufInfo :: struct {
    base_paddr: u32;
    bufCount:   s32;
    buffers:    [12] C3D_BufCfg;
}

BufInfo_Init :: (info: *C3D_BufInfo) -> void #foreign libcitro3d;
BufInfo_Add :: (info: *C3D_BufInfo, data: *void, stride: ptrdiff_t, attribCount: s32, permutation: u64) -> s32 #foreign libcitro3d;

C3D_GetBufInfo :: () -> *C3D_BufInfo #foreign libcitro3d;
C3D_SetBufInfo :: (info: *C3D_BufInfo) -> void #foreign libcitro3d;

C3D_UNSIGNED :: enum u8 {
    BYTE  :: 0;
    SHORT :: 1;
}

C3D_Init :: (cmdBufSize: size_t) -> bool #foreign libcitro3d;
C3D_Fini :: () -> void #foreign libcitro3d;

C3D_GetCmdBufUsage :: () -> float #foreign libcitro3d;

C3D_BindProgram :: (program: *shaderProgram_s) -> void #foreign libcitro3d;

C3D_SetViewport :: (x: u32, y: u32, w: u32, h: u32) -> void #foreign libcitro3d;
C3D_SetScissor :: (mode: GPU_SCISSORMODE, left: u32, top: u32, right: u32, bottom: u32) -> void #foreign libcitro3d;

C3D_DrawArrays :: (primitive: GPU_Primitive_t, first: s32, size: s32) -> void #foreign libcitro3d;
C3D_DrawElements :: (primitive: GPU_Primitive_t, count: s32, type: s32, indices: *void) -> void #foreign libcitro3d;

// Immediate-mode vertex submission
C3D_ImmDrawBegin :: (primitive: GPU_Primitive_t) -> void #foreign libcitro3d;
C3D_ImmSendAttrib :: (x: float, y: float, z: float, w: float) -> void #foreign libcitro3d;
C3D_ImmDrawEnd :: () -> void #foreign libcitro3d;

// Fixed vertex attributes
C3D_FixedAttribGetWritePtr :: (id: s32) -> *C3D_FVec #foreign libcitro3d;

C3D_TexEnv :: struct {
    srcRgb:     u16;
    srcAlpha:   u16;
    union {
        opAll: u32;
        struct {
            opRgb:   u32;
            #place opRgb; /*bitfield 12*/ opAlpha: u32;
        }
    }
    funcRgb:    u16;
    funcAlpha:  u16;
    color:      u32;
    scaleRgb:   u16;
    scaleAlpha: u16;
}

C3D_TexEnvMode :: enum u8 {
    RGB   :: 1;
    Alpha :: 2;
    Both  :: 3;
}

C3D_GetTexEnv :: (id: s32) -> *C3D_TexEnv #foreign libcitro3d;
C3D_SetTexEnv :: (id: s32, env: *C3D_TexEnv) -> void #foreign libcitro3d;
C3D_DirtyTexEnv :: (env: *C3D_TexEnv) -> void #foreign libcitro3d;

C3D_TexEnvBufUpdate :: (mode: s32, mask: s32) -> void #foreign libcitro3d;
C3D_TexEnvBufColor :: (color: u32) -> void #foreign libcitro3d;

C3D_DepthMap :: (bIsZBuffer: bool, zScale: float, zOffset: float) -> void #foreign libcitro3d;
C3D_CullFace :: (mode: GPU_CULLMODE) -> void #foreign libcitro3d;
C3D_StencilTest :: (enable: bool, function: GPU_TESTFUNC, ref: s32, inputMask: s32, writeMask: s32) -> void #foreign libcitro3d;
C3D_StencilOp :: (sfail: GPU_STENCILOP, dfail: GPU_STENCILOP, pass: GPU_STENCILOP) -> void #foreign libcitro3d;
C3D_BlendingColor :: (color: u32) -> void #foreign libcitro3d;
C3D_EarlyDepthTest :: (enable: bool, function: GPU_EARLYDEPTHFUNC, ref: u32) -> void #foreign libcitro3d;
C3D_DepthTest :: (enable: bool, function: GPU_TESTFUNC, writemask: GPU_WRITEMASK) -> void #foreign libcitro3d;
C3D_AlphaTest :: (enable: bool, function: GPU_TESTFUNC, ref: s32) -> void #foreign libcitro3d;
C3D_AlphaBlend :: (colorEq: GPU_BLENDEQUATION, alphaEq: GPU_BLENDEQUATION, srcClr: GPU_BLENDFACTOR, dstClr: GPU_BLENDFACTOR, srcAlpha: GPU_BLENDFACTOR, dstAlpha: GPU_BLENDFACTOR) -> void #foreign libcitro3d;
C3D_ColorLogicOp :: (op: GPU_LOGICOP) -> void #foreign libcitro3d;
C3D_FragOpMode :: (mode: GPU_FRAGOPMODE) -> void #foreign libcitro3d;
C3D_FragOpShadow :: (scale: float, bias: float) -> void #foreign libcitro3d;

C3D_TexCube :: struct {
    data: [6] *void;
}

C3D_Tex :: struct {
    union {
        data: *void;
        cube: *C3D_TexCube;
    }
    fmt:    GPU_TEXCOLOR;
    size:   size_t;
    union {
        dim: u32;
        struct {
            height: u16;
            width:  u16;
        }
    }
    param:  u32;
    border: u32;
    union {
        lodParam: u32;
        struct {
            lodBias:  u16;
            maxLevel: u8;
            minLevel: u8;
        }
    }
}

C3D_TexInitParams :: struct {
    width:    u16;
    height:   u16;
    maxLevel: u8;
    format:   GPU_TEXCOLOR;
    type:     GPU_TEXTURE_MODE_PARAM;
    onVram:   bool;
}

C3D_TexInitWithParams :: (tex: *C3D_Tex, cube: *C3D_TexCube, p: C3D_TexInitParams) -> bool #foreign libcitro3d;
C3D_TexLoadImage :: (tex: *C3D_Tex, data: *void, face: GPU_TEXFACE, level: s32) -> void #foreign libcitro3d;
C3D_TexGenerateMipmap :: (tex: *C3D_Tex, face: GPU_TEXFACE) -> void #foreign libcitro3d;
C3D_TexBind :: (unitId: s32, tex: *C3D_Tex) -> void #foreign libcitro3d;
C3D_TexFlush :: (tex: *C3D_Tex) -> void #foreign libcitro3d;
C3D_TexDelete :: (tex: *C3D_Tex) -> void #foreign libcitro3d;

C3D_TexShadowParams :: (perspective: bool, bias: float) -> void #foreign libcitro3d;

C3D_ProcTexColorLut :: struct {
    color: [256] u32;
    diff:  [256] u32;
}

C3D_ProcTex :: struct {
    union {
        proctex0: u32;
        struct {
            uClamp:        u32;
            #place uClamp; /*bitfield 3*/ vClamp:        u32;
            #place uClamp; /*bitfield 6*/ rgbFunc:       u32;
            #place uClamp; /*bitfield 10*/ alphaFunc:     u32;
            alphaSeparate: bool;
            #place alphaSeparate; /*bitfield 1*/ enableNoise:   bool;
            uShift:        u32;
            #place uShift; /*bitfield 2*/ vShift:        u32;
            #place uShift; /*bitfield 4*/ lodBiasLow:    u32;
        }
    }
    union {
        proctex1: u32;
        struct {
            uNoiseAmpl:  u16;
            uNoisePhase: u16;
        }
    }
    union {
        proctex2: u32;
        struct {
            vNoiseAmpl:  u16;
            vNoisePhase: u16;
        }
    }
    union {
        proctex3: u32;
        struct {
            uNoiseFreq: u16;
            vNoiseFreq: u16;
        }
    }
    union {
        proctex4: u32;
        struct {
            minFilter:   u32;
            #place minFilter; /*bitfield 3*/ unknown1:    u32;
            #place minFilter; /*bitfield 11*/ width:       u32;
            #place minFilter; /*bitfield 19*/ lodBiasHigh: u32;
        }
    }
    union {
        proctex5: u32;
        struct {
            offset:   u32;
            #place offset; /*bitfield 8*/ unknown2: u32;
        }
    }
}

C3D_ProcTex_1 :: enum u8 {
    U  :: 1;
    V  :: 2;
    UV :: 3;
}

C3D_ProcTexInit :: (pt: *C3D_ProcTex, offset: s32, length: s32) -> void #foreign libcitro3d;
C3D_ProcTexNoiseCoefs :: (pt: *C3D_ProcTex, mode: s32, amplitude: float, frequency: float, phase: float) -> void #foreign libcitro3d;
C3D_ProcTexLodBias :: (pt: *C3D_ProcTex, bias: float) -> void #foreign libcitro3d;
C3D_ProcTexBind :: (texCoordId: s32, pt: *C3D_ProcTex) -> void #foreign libcitro3d;

// GPU_LUT_NOISE, GPU_LUT_RGBMAP, GPU_LUT_ALPHAMAP
C3D_ProcTexLut :: [128] u32;
C3D_ProcTexLutBind :: (id: GPU_PROCTEX_LUTID, lut: *C3D_ProcTexLut) -> void #foreign libcitro3d;
ProcTexLut_FromArray :: (lut: *C3D_ProcTexLut, in: *[129] float) -> void #foreign libcitro3d;

C3D_ProcTexColorLutBind :: (lut: *C3D_ProcTexColorLut) -> void #foreign libcitro3d;
ProcTexColorLut_Write :: (out: *C3D_ProcTexColorLut, in: *u32, offset: s32, length: s32) -> void #foreign libcitro3d;

C3D_LightLut :: struct {
    data: [256] u32;
}

C3D_LightLutDA :: struct {
    lut:   C3D_LightLut;
    bias:  float;
    scale: float;
}

C3D_LightLutFunc :: #type (x: float, param: float) -> float #c_call;
C3D_LightLutFuncDA :: #type (dist: float, arg0: float, arg1: float) -> float #c_call;

LightLut_FromArray :: (lut: *C3D_LightLut, data: *float) -> void #foreign libcitro3d;
LightLut_FromFunc :: (lut: *C3D_LightLut, func: C3D_LightLutFunc, param: float, negative: bool) -> void #foreign libcitro3d;
LightLutDA_Create :: (lut: *C3D_LightLutDA, func: C3D_LightLutFuncDA, from: float, to: float, arg0: float, arg1: float) -> void #foreign libcitro3d;

//-----------------------------------------------------------------------------
// Material
//-----------------------------------------------------------------------------
C3D_Material :: struct {
    ambient:   [3] float;
    diffuse:   [3] float;
    specular0: [3] float;
    specular1: [3] float;
    emission:  [3] float;
}

// Forward declarations
C3D_Light :: C3D_Light_t;
C3D_LightEnv :: C3D_LightEnv_t;

C3D_LightLutInputConf :: struct {
    abs:    u32;
    select: u32;
    scale:  u32;
}

C3D_LightEnvConf :: struct {
    ambient:     u32;
    numLights:   u32;
    config:      [2] u32;
    lutInput:    C3D_LightLutInputConf;
    permutation: u32;
}

C3DF_LightEnv :: enum u8 {
    Dirty    :: 1;
    MtlDirty :: 2;
    LCDirty  :: 4;
}

C3D_LightEnv_t :: struct {
    flags:    u32;
    luts:     [6] *C3D_LightLut #align 4;
    ambient:  [3] float;
    lights:   [8] *C3D_Light;
    conf:     C3D_LightEnvConf;
    material: C3D_Material;
}

C3D_LightEnvInit :: (env: *C3D_LightEnv) -> void #foreign libcitro3d;
C3D_LightEnvBind :: (env: *C3D_LightEnv) -> void #foreign libcitro3d;

C3D_LightEnvMaterial :: (env: *C3D_LightEnv, mtl: *C3D_Material) -> void #foreign libcitro3d;
C3D_LightEnvAmbient :: (env: *C3D_LightEnv, r: float, g: float, b: float) -> void #foreign libcitro3d;
C3D_LightEnvLut :: (env: *C3D_LightEnv, lutId: GPU_LIGHTLUTID, input: GPU_LIGHTLUTINPUT, negative: bool, lut: *C3D_LightLut) -> void #foreign libcitro3d;

GPU :: enum u32 {
    SHADOW_PRIMARY   :: 65536;
    SHADOW_SECONDARY :: 131072;
    INVERT_SHADOW    :: 262144;
    SHADOW_ALPHA     :: 524288;
}

C3D_LightEnvFresnel :: (env: *C3D_LightEnv, selector: GPU_FRESNELSEL) -> void #foreign libcitro3d;
C3D_LightEnvBumpMode :: (env: *C3D_LightEnv, mode: GPU_BUMPMODE) -> void #foreign libcitro3d;
C3D_LightEnvBumpSel :: (env: *C3D_LightEnv, texUnit: s32) -> void #foreign libcitro3d;
C3D_LightEnvShadowMode :: (env: *C3D_LightEnv, mode: u32) -> void #foreign libcitro3d;
C3D_LightEnvShadowSel :: (env: *C3D_LightEnv, texUnit: s32) -> void #foreign libcitro3d;
C3D_LightEnvClampHighlights :: (env: *C3D_LightEnv, clamp: bool) -> void #foreign libcitro3d;

//-----------------------------------------------------------------------------
// Light
//-----------------------------------------------------------------------------
C3D_LightMatConf :: struct {
    specular0: u32;
    specular1: u32;
    diffuse:   u32;
    ambient:   u32;
}

C3D_LightConf :: struct {
    material:      C3D_LightMatConf;
    position:      [3] u16;
    padding0:      u16;
    spotDir:       [3] u16;
    padding1:      u16;
    padding2:      u32;
    config:        u32;
    distAttnBias:  u32;
    distAttnScale: u32;
}

C3DF_Light :: enum u16 {
    Enabled  :: 1;
    Dirty    :: 2;
    MatDirty :: 4;
    SPDirty  :: 16384;
    DADirty  :: 32768;
}

C3D_Light_t :: struct {
    flags:     u16;
    id:        u16;
    parent:    *C3D_LightEnv #align 4;
    lut_SP:    *C3D_LightLut;
    lut_DA:    *C3D_LightLut #align 4;
    ambient:   [3] float;
    diffuse:   [3] float;
    specular0: [3] float;
    specular1: [3] float;
    conf:      C3D_LightConf;
}

C3D_LightInit :: (light: *C3D_Light, env: *C3D_LightEnv) -> s32 #foreign libcitro3d;
C3D_LightEnable :: (light: *C3D_Light, enable: bool) -> void #foreign libcitro3d;
C3D_LightTwoSideDiffuse :: (light: *C3D_Light, enable: bool) -> void #foreign libcitro3d;
C3D_LightGeoFactor :: (light: *C3D_Light, id: s32, enable: bool) -> void #foreign libcitro3d;
C3D_LightAmbient :: (light: *C3D_Light, r: float, g: float, b: float) -> void #foreign libcitro3d;
C3D_LightDiffuse :: (light: *C3D_Light, r: float, g: float, b: float) -> void #foreign libcitro3d;
C3D_LightSpecular0 :: (light: *C3D_Light, r: float, g: float, b: float) -> void #foreign libcitro3d;
C3D_LightSpecular1 :: (light: *C3D_Light, r: float, g: float, b: float) -> void #foreign libcitro3d;
C3D_LightPosition :: (light: *C3D_Light, pos: *C3D_FVec) -> void #foreign libcitro3d;
C3D_LightShadowEnable :: (light: *C3D_Light, enable: bool) -> void #foreign libcitro3d;
C3D_LightSpotEnable :: (light: *C3D_Light, enable: bool) -> void #foreign libcitro3d;
C3D_LightSpotDir :: (light: *C3D_Light, x: float, y: float, z: float) -> void #foreign libcitro3d;
C3D_LightSpotLut :: (light: *C3D_Light, lut: *C3D_LightLut) -> void #foreign libcitro3d;
C3D_LightDistAttnEnable :: (light: *C3D_Light, enable: bool) -> void #foreign libcitro3d;
C3D_LightDistAttn :: (light: *C3D_Light, lut: *C3D_LightLutDA) -> void #foreign libcitro3d;

C3D_FogLut :: struct {
    data: [128] u32;
}

C3D_GasLut :: struct {
    diff:  [8] u32;
    color: [8] u32;
}

FogLut_FromArray :: (lut: *C3D_FogLut, data: *[256] float) -> void #foreign libcitro3d;
FogLut_Exp :: (lut: *C3D_FogLut, density: float, gradient: float, near: float, far: float) -> void #foreign libcitro3d;

C3D_FogGasMode :: (fogMode: GPU_FOGMODE, gasMode: GPU_GASMODE, zFlip: bool) -> void #foreign libcitro3d;
C3D_FogColor :: (color: u32) -> void #foreign libcitro3d;
C3D_FogLutBind :: (lut: *C3D_FogLut) -> void #foreign libcitro3d;

GasLut_FromArray :: (lut: *C3D_GasLut, data: *[9] u32) -> void #foreign libcitro3d;

C3D_GasBeginAcc :: () -> void #foreign libcitro3d;
C3D_GasDeltaZ :: (value: float) -> void #foreign libcitro3d;

C3D_GasAccMax :: (value: float) -> void #foreign libcitro3d;
C3D_GasAttn :: (value: float) -> void #foreign libcitro3d;
C3D_GasLightPlanar :: (min: float, max: float, attn: float) -> void #foreign libcitro3d;
C3D_GasLightView :: (min: float, max: float, attn: float) -> void #foreign libcitro3d;
C3D_GasLightDirection :: (dotp: float) -> void #foreign libcitro3d;
C3D_GasLutInput :: (input: GPU_GASLUTINPUT) -> void #foreign libcitro3d;
C3D_GasLutBind :: (lut: *C3D_GasLut) -> void #foreign libcitro3d;

C3D_FrameBuf :: struct {
    colorBuf:  *void;
    depthBuf:  *void #align 4;
    width:     u16;
    height:    u16;
    colorFmt:  GPU_COLORBUF;
    depthFmt:  GPU_DEPTHBUF;
    block32:   bool;
    colorMask: u8;
    #place colorMask; /*bitfield 4*/ depthMask: u8;
}

// Flags for C3D_FrameBufClear
C3D_ClearBits :: enum u8 {
    COLOR :: 1;
    DEPTH :: 2;
    ALL   :: 3;
}

C3D_CalcColorBufSize :: (width: u32, height: u32, fmt: GPU_COLORBUF) -> u32 #foreign libcitro3d;
C3D_CalcDepthBufSize :: (width: u32, height: u32, fmt: GPU_DEPTHBUF) -> u32 #foreign libcitro3d;

C3D_GetFrameBuf :: () -> *C3D_FrameBuf #foreign libcitro3d;
C3D_SetFrameBuf :: (fb: *C3D_FrameBuf) -> void #foreign libcitro3d;
C3D_FrameBufTex :: (fb: *C3D_FrameBuf, tex: *C3D_Tex, face: GPU_TEXFACE, level: s32) -> void #foreign libcitro3d;
C3D_FrameBufClear :: (fb: *C3D_FrameBuf, clearBits: C3D_ClearBits, clearColor: u32, clearDepth: u32) -> void #foreign libcitro3d;
C3D_FrameBufTransfer :: (fb: *C3D_FrameBuf, screen: gfxScreen_t, side: gfx3dSide_t, transferFlags: u32) -> void #foreign libcitro3d;

C3D_RenderTarget :: C3D_RenderTarget_tag;

C3D_RenderTarget_tag :: struct {
    next:          *C3D_RenderTarget;
    prev:          *C3D_RenderTarget #align 4;
    frameBuf:      C3D_FrameBuf;
    used:          bool;
    ownsColor:     bool;
    ownsDepth:     bool;
    linked:        bool;
    screen:        gfxScreen_t;
    side:          gfx3dSide_t;
    transferFlags: u32;
}

// Flags for C3D_FrameBegin
C3D_FRAME :: enum u8 {
    SYNCDRAW :: 1;
    NONBLOCK :: 2;
}

C3D_FrameRate :: (fps: float) -> float #foreign libcitro3d;
C3D_FrameSync :: () -> void #foreign libcitro3d;
C3D_FrameCounter :: (id: s32) -> u32 #foreign libcitro3d;

C3D_FrameBegin :: (flags: u8) -> bool #foreign libcitro3d;
C3D_FrameDrawOn :: (target: *C3D_RenderTarget) -> bool #foreign libcitro3d;
C3D_FrameSplit :: (flags: u8) -> void #foreign libcitro3d;
C3D_FrameEnd :: (flags: u8) -> void #foreign libcitro3d;

C3D_FrameEndHook :: (hook: #type (unknown0: *void) -> void #c_call, param: *void) -> void #foreign libcitro3d;

C3D_GetDrawingTime :: () -> float #foreign libcitro3d;
C3D_GetProcessingTime :: () -> float #foreign libcitro3d;

C3D_DEPTHTYPE :: union {
    __i: s32;
    __e: GPU_DEPTHBUF;
}

C3D_RenderTargetCreate :: (width: s32, height: s32, colorFmt: GPU_COLORBUF, depthFmt: C3D_DEPTHTYPE) -> *C3D_RenderTarget #foreign libcitro3d;
C3D_RenderTargetCreateFromTex :: (tex: *C3D_Tex, face: GPU_TEXFACE, level: s32, depthFmt: C3D_DEPTHTYPE) -> *C3D_RenderTarget #foreign libcitro3d;
C3D_RenderTargetDelete :: (target: *C3D_RenderTarget) -> void #foreign libcitro3d;
C3D_RenderTargetSetOutput :: (target: *C3D_RenderTarget, screen: gfxScreen_t, side: gfx3dSide_t, transferFlags: u32) -> void #foreign libcitro3d;

C3D_SyncDisplayTransfer :: (inadr: *u32, indim: u32, outadr: *u32, outdim: u32, flags: u32) -> void #foreign libcitro3d;
C3D_SyncTextureCopy :: (inadr: *u32, indim: u32, outadr: *u32, outdim: u32, size: u32, flags: u32) -> void #foreign libcitro3d;
C3D_SyncMemoryFill :: (buf0a: *u32, buf0v: u32, buf0e: *u32, control0: u16, buf1a: *u32, buf1v: u32, buf1e: *u32, control1: u16) -> void #foreign libcitro3d;

/** @brief Subtexture
*  @note If top > bottom, the subtexture is rotated 1/4 revolution counter-clockwise
*/
Tex3DS_SubTexture :: struct {
    width:  u16; ///< Sub-texture width (pixels)
    height: u16; ///< Sub-texture height (pixels)
    left:   float; ///< Left u-coordinate
    top:    float; ///< Top v-coordinate
    right:  float; ///< Right u-coordinate
    bottom: float; ///< Bottom v-coordinate
}

Tex3DS_Texture_s :: struct {}
/** @brief Texture */
Tex3DS_Texture :: *Tex3DS_Texture_s;

/** @brief Import Tex3DS texture
*  @param[in]  input   Input data
*  @param[in]  insize  Size of the input data
*  @param[out] tex     citro3d texture
*  @param[out] texcube citro3d texcube
*  @param[in]  vram    Whether to store textures in VRAM
*  @returns Tex3DS texture
*/
Tex3DS_TextureImport :: (input: *void, insize: size_t, tex: *C3D_Tex, texcube: *C3D_TexCube, vram: bool) -> Tex3DS_Texture #foreign libcitro3d;

/** @brief Import Tex3DS texture
*
*  @description
*  For example, use this if you want to import from a large file without
*  pulling the entire file into memory.
*
*  @param[out] tex      citro3d texture
*  @param[out] texcube  citro3d texcube
*  @param[in]  vram     Whether to store textures in VRAM
*  @param[in]  callback Data callback
*  @param[in]  userdata User data passed to callback
*  @returns Tex3DS texture
*/
Tex3DS_TextureImportCallback :: (tex: *C3D_Tex, texcube: *C3D_TexCube, vram: bool, callback: decompressCallback, userdata: *void) -> Tex3DS_Texture #foreign libcitro3d;

/** @brief Import Tex3DS texture
*
*  Starts reading at the current file descriptor's offset. The file
*  descriptor's position is left at the end of the decoded data. On error, the
*  file descriptor's position is indeterminate.
*
*  @param[in]  fd       Open file descriptor
*  @param[out] tex      citro3d texture
*  @param[out] texcube  citro3d texcube
*  @param[in]  vram     Whether to store textures in VRAM
*  @returns Tex3DS texture
*/
Tex3DS_TextureImportFD :: (fd: s32, tex: *C3D_Tex, texcube: *C3D_TexCube, vram: bool) -> Tex3DS_Texture #foreign libcitro3d;

/** @brief Import Tex3DS texture
*
*  Starts reading at the current file stream's offset. The file stream's
*  position is left at the end of the decoded data. On error, the file
*  stream's position is indeterminate.
*
*  @param[in]  fp       Open file stream
*  @param[out] tex      citro3d texture
*  @param[out] texcube  citro3d texcube
*  @param[in]  vram     Whether to store textures in VRAM
*  @returns Tex3DS texture
*/
Tex3DS_TextureImportStdio :: (fp: *FILE, tex: *C3D_Tex, texcube: *C3D_TexCube, vram: bool) -> Tex3DS_Texture #foreign libcitro3d;

/** @brief Get number of subtextures
*  @param[in] texture Tex3DS texture
*  @returns Number of subtextures
*/
Tex3DS_GetNumSubTextures :: (texture: Tex3DS_Texture) -> size_t #foreign libcitro3d;

/** @brief Get subtexture
*  @param[in] texture Tex3DS texture
*  @param[in] index   Subtexture index
*  @returns Subtexture info
*/
Tex3DS_GetSubTexture :: (texture: Tex3DS_Texture, index: size_t) -> *Tex3DS_SubTexture #foreign libcitro3d;

/** @brief Free Tex3DS texture
*  @param[in] texture Tex3DS texture to free
*/
Tex3DS_TextureFree :: (texture: Tex3DS_Texture) -> void #foreign libcitro3d;

C2D_DrawParams :: struct {
    pos:    struct {
        x: float;
        y: float;
        w: float;
        h: float;
    };
    center: struct {
        x: float;
        y: float;
    };
    depth:  float;
    angle:  float;
}

C2D_TintMode :: enum u8 {
    Solid :: 0;
    Mult  :: 1;
    Luma  :: 2;
}

C2D_Tint :: struct {
    color: u32; ///< RGB tint color and Alpha transparency
    blend: float; ///< Blending strength of the tint color (0.0~1.0)
}

C2D_Corner :: enum u8 {
    TopLeft  :: 0;
    TopRight :: 1;
    BotLeft  :: 2;
    BotRight :: 3;
}

C2D_Image :: struct {
    tex:    *C3D_Tex;
    subtex: *Tex3DS_SubTexture #align 4;
}

C2D_ImageTint :: struct {
    corners: [4] C2D_Tint;
}

/** @brief Initialize citro2d
*  @param[in] maxObjects Maximum number of 2D objects that can be drawn per frame.
*  @remarks Pass C2D_DEFAULT_MAX_OBJECTS as a starting point.
*  @returns true on success, false on failure
*/
C2D_Init :: (maxObjects: size_t) -> bool #foreign libcitro2d;

/** @brief Deinitialize citro2d */
C2D_Fini :: () -> void #foreign libcitro2d;

/** @brief Prepares the GPU for rendering 2D content
*  @remarks This needs to be done only once in the program if citro2d is the sole user of the GPU.
*/
C2D_Prepare :: () -> void #foreign libcitro2d;

/** @brief Ensures all 2D objects so far have been drawn */
C2D_Flush :: () -> void #foreign libcitro2d;

/** @brief Configures the size of the 2D scene.
*  @param[in] width The width of the scene, in pixels.
*  @param[in] height The height of the scene, in pixels.
*  @param[in] tilt Whether the scene is tilted like the 3DS's sideways screens.
*/
C2D_SceneSize :: (width: u32, height: u32, tilt: bool) -> void #foreign libcitro2d;

/** @brief Resets the model transformation matrix. */
C2D_ViewReset :: () -> void #foreign libcitro2d;

/** @brief Saves the current model transformation matrix.
* @param[out] matrix Pointer to save the current matrix to
*/
C2D_ViewSave :: (matrix: *C3D_Mtx) -> void #foreign libcitro2d;

/** @brief Restores a previously saved model transformation matrix.
* @param[in] matrix Pointer to matrix to restor
*/
C2D_ViewRestore :: (matrix: *C3D_Mtx) -> void #foreign libcitro2d;

/** @brief Translates everything drawn via the model matrix.
* @param[in] x Translation in the x direction
* @param[in] y Translation in the y direction
*/
C2D_ViewTranslate :: (x: float, y: float) -> void #foreign libcitro2d;

/** @brief Rotates everything drawn via the model matrix.
* @param[in] rotation Rotation in the counterclockwise direction in radians
*/
C2D_ViewRotate :: (rotation: float) -> void #foreign libcitro2d;

/** @brief Shears everything drawn via the model matrix.
* @param[in] x Shear factor in the x direction
* @param[in] y Shear factor in the y direction
*/
C2D_ViewShear :: (x: float, y: float) -> void #foreign libcitro2d;

/** @brief Scales everything drawn via the model matrix.
* @param[in] x Scale factor in the x direction
* @param[in] y Scale factor in the y direction
*/
C2D_ViewScale :: (x: float, y: float) -> void #foreign libcitro2d;

/** @brief Helper function to create a render target for a screen
*  @param[in] screen Screen (GFX_TOP or GFX_BOTTOM)
*  @param[in] side Side (GFX_LEFT or GFX_RIGHT)
*  @returns citro3d render target object
*/
C2D_CreateScreenTarget :: (screen: gfxScreen_t, side: gfx3dSide_t) -> *C3D_RenderTarget #foreign libcitro2d;

/** @brief Helper function to clear a rendertarget using the specified color
*  @param[in] target Render target to clear
*  @param[in] color 32-bit RGBA color value to fill the target with
*/
C2D_TargetClear :: (target: *C3D_RenderTarget, color: u32) -> void #foreign libcitro2d;

/** @brief Configures the fading color
*  @param[in] color 32-bit RGBA color value to be used as the fading color (0 by default)
*  @remark The alpha component of the color is used as the strength of the fading color.
*          If alpha is zero, the fading color has no effect. If it is the highest value,
*          the rendered pixels will all have the fading color. Everything inbetween is
*          rendered as a blend of the original pixel color and the fading color.
*/
C2D_Fade :: (color: u32) -> void #foreign libcitro2d;

/** @brief Configures the formula used to calculate the tinted texture color
*  @param[in] mode Tinting mode
*  @remark Texture tinting works by linearly interpolating between the regular texture color
*          and the tinted texture color according to the blending strength parameter.
*          This function can be used to change how the tinted texture color is precisely
*          calculated, refer to \ref C2D_TintMode for a list of available tinting modes.
*/
C2D_SetTintMode :: (mode: C2D_TintMode) -> void #foreign libcitro2d;

/** @brief Draws an image using the GPU (variant accepting C2D_DrawParams)
*  @param[in] img Handle of the image to draw
*  @param[in] params Parameters with which to draw the image
*  @param[in] tint Tint parameters to apply to the image (optional, can be null)
*  @returns true on success, false on failure
*/
C2D_DrawImage :: (img: C2D_Image, params: *C2D_DrawParams, tint: *C2D_ImageTint) -> bool #foreign libcitro2d;

/** @brief Draws a plain triangle using the GPU
*  @param[in] x0 X coordinate of the first vertex of the triangle
*  @param[in] y0 Y coordinate of the first vertex of the triangle
*  @param[in] clr0 32-bit RGBA color of the first vertex of the triangle
*  @param[in] x1 X coordinate of the second vertex of the triangle
*  @param[in] y1 Y coordinate of the second vertex of the triangle
*  @param[in] clr1 32-bit RGBA color of the second vertex of the triangle
*  @param[in] x2 X coordinate of the third vertex of the triangle
*  @param[in] y2 Y coordinate of the third vertex of the triangle
*  @param[in] clr2 32-bit RGBA color of the third vertex of the triangle
*  @param[in] depth Depth value to draw the triangle with
*/
C2D_DrawTriangle :: (x0: float, y0: float, clr0: u32, x1: float, y1: float, clr1: u32, x2: float, y2: float, clr2: u32, depth: float) -> bool #foreign libcitro2d;

/** @brief Draws a plain line using the GPU
*  @param[in] x0 X coordinate of the first vertex of the line
*  @param[in] y0 Y coordinate of the first vertex of the line
*  @param[in] clr0 32-bit RGBA color of the first vertex of the line
*  @param[in] x1 X coordinate of the second vertex of the line
*  @param[in] y1 Y coordinate of the second vertex of the line
*  @param[in] clr1 32-bit RGBA color of the second vertex of the line
*  @param[in] thickness Thickness, in pixels, of the line
*  @param[in] depth Depth value to draw the line with
*/
C2D_DrawLine :: (x0: float, y0: float, clr0: u32, x1: float, y1: float, clr1: u32, thickness: float, depth: float) -> bool #foreign libcitro2d;

/** @brief Draws a plain rectangle using the GPU
*  @param[in] x X coordinate of the top-left vertex of the rectangle
*  @param[in] y Y coordinate of the top-left vertex of the rectangle
*  @param[in] z Z coordinate (depth value) to draw the rectangle with
*  @param[in] w Width of the rectangle
*  @param[in] h Height of the rectangle
*  @param[in] clr0 32-bit RGBA color of the top-left corner of the rectangle
*  @param[in] clr1 32-bit RGBA color of the top-right corner of the rectangle
*  @param[in] clr2 32-bit RGBA color of the bottom-left corner of the rectangle
*  @param[in] clr3 32-bit RGBA color of the bottom-right corner of the rectangle
*/
C2D_DrawRectangle :: (x: float, y: float, z: float, w: float, h: float, clr0: u32, clr1: u32, clr2: u32, clr3: u32) -> bool #foreign libcitro2d;

/** @brief Draws an ellipse using the GPU
*  @param[in] x X coordinate of the top-left vertex of the ellipse
*  @param[in] y Y coordinate of the top-left vertex of the ellipse
*  @param[in] z Z coordinate (depth value) to draw the ellipse with
*  @param[in] w Width of the ellipse
*  @param[in] h Height of the ellipse
*  @param[in] clr0 32-bit RGBA color of the top-left corner of the ellipse
*  @param[in] clr1 32-bit RGBA color of the top-right corner of the ellipse
*  @param[in] clr2 32-bit RGBA color of the bottom-left corner of the ellipse
*  @param[in] clr3 32-bit RGBA color of the bottom-right corner of the ellipse
*  @note Switching to and from "circle mode" internally requires an expensive state change. As such, the recommended usage of this feature is to draw all non-circular objects first, then draw all circular objects.
*/
C2D_DrawEllipse :: (x: float, y: float, z: float, w: float, h: float, clr0: u32, clr1: u32, clr2: u32, clr3: u32) -> bool #foreign libcitro2d;

C2D_SpriteSheet_s :: struct {}
C2D_SpriteSheet :: *C2D_SpriteSheet_s;

/** @brief Load a sprite sheet from file
*  @param[in] filename Name of the sprite sheet file (.t3x)
*  @returns Sprite sheet handle
*  @retval NULL Error
*/
C2D_SpriteSheetLoad :: (filename: *u8) -> C2D_SpriteSheet #foreign libcitro2d;

/** @brief Load a sprite sheet from memory
*  @param[in] data Data to load
*  @param[in] size Size of the data to load
*  @returns Sprite sheet handle
*  @retval NULL Error
*/
C2D_SpriteSheetLoadFromMem :: (data: *void, size: size_t) -> C2D_SpriteSheet #foreign libcitro2d;

/** @brief Load sprite sheet from file descriptor
*  @param[in] fd File descriptor used to load data
*  @returns Sprite sheet handle
*  @retval NULL Error
*/
C2D_SpriteSheetFromFD :: (fd: s32) -> C2D_SpriteSheet #foreign libcitro2d;

/** @brief Load sprite sheet from stdio file handle
*  @param[in] f File handle used to load data
*  @returns Sprite sheet handle
*  @retval NULL Error
*/
C2D_SpriteSheetLoadFromHandle :: (f: *FILE) -> C2D_SpriteSheet #foreign libcitro2d;

/** @brief Free a sprite sheet
*  @param[in] sheet Sprite sheet handle
*/
C2D_SpriteSheetFree :: (sheet: C2D_SpriteSheet) -> void #foreign libcitro2d;

/** @brief Retrieves the number of sprites in the specified sprite sheet
*  @param[in] sheet Sprite sheet handle
*  @returns Number of sprites
*/
C2D_SpriteSheetCount :: (sheet: C2D_SpriteSheet) -> size_t #foreign libcitro2d;

/** @brief Retrieves the specified image from the specified sprite sheet
*  @param[in] sheet Sprite sheet handle
*  @param[in] index Index of the image to retrieve
*  @returns Image object
*/
C2D_SpriteSheetGetImage :: (sheet: C2D_SpriteSheet, index: size_t) -> C2D_Image #foreign libcitro2d;

C2D_Sprite :: struct {
    image:  C2D_Image;
    params: C2D_DrawParams;
}

C2D_Font_s :: struct {}
C2D_Font :: *C2D_Font_s;

/** @brief Load a font from a file
* @param[in] filename Name of the font file (.bcfnt)
* @returns Font handle
* @retval NULL Error
*/
C2D_FontLoad :: (filename: *u8) -> C2D_Font #foreign libcitro2d;

/** @brief Load a font from memory
* @param[in] data Data to load
* @param[in] size Size of the data to load
* @returns Font handle
* @retval NULL Error
*/
C2D_FontLoadFromMem :: (data: *void, size: size_t) -> C2D_Font #foreign libcitro2d;

/** @brief Load a font from file descriptor
* @param[in] fd File descriptor used to load data
* @returns Font handle
* @retval NULL Error
*/
C2D_FontLoadFromFD :: (fd: s32) -> C2D_Font #foreign libcitro2d;

/** @brief Load font from stdio file handle
*  @param[in] f File handle used to load data
*  @returns Font handle
*  @retval NULL Error
*/
C2D_FontLoadFromHandle :: (f: *FILE) -> C2D_Font #foreign libcitro2d;

/** @brief Load corresponding font from system archive
*  @param[in] region Region to get font from
*  @returns Font handle
*  @retval NULL Error
*  @remark JPN, USA, EUR, and AUS all use the same font.
*/
C2D_FontLoadSystem :: (region: CFG_Region) -> C2D_Font #foreign libcitro2d;

/** @brief Free a font
* @param[in] font Font handle
*/
C2D_FontFree :: (font: C2D_Font) -> void #foreign libcitro2d;

/** @brief Set a font's texture filter
* @param[in] font Font handle
* @param[in] magFilter the magnification filter
* @param[in] minFilter the minification filter
*/
C2D_FontSetFilter :: (font: C2D_Font, magFilter: GPU_TEXTURE_FILTER_PARAM, minFilter: GPU_TEXTURE_FILTER_PARAM) -> void #foreign libcitro2d;

/** @brief Find the glyph index of a codepoint, or returns the default
* @param[in] font Font to search, or NULL for system font
* @param[in] codepoint Codepoint to search for
* @returns Glyph index
* @retval font->cfnt->finf.alterCharIndex The codepoint does not exist in the font
*/
C2D_FontGlyphIndexFromCodePoint :: (font: C2D_Font, codepoint: u32) -> s32 #foreign libcitro2d;

/** @brief Get character width info for a given index
* @param[in] font Font to read from, or NULL for system font
* @param[in] glyphIndex Index to get the width of
* @returns Width info for glyph
*/
C2D_FontGetCharWidthInfo :: (font: C2D_Font, glyphIndex: s32) -> *charWidthInfo_s #foreign libcitro2d;

/** @brief Calculate glyph position of given index
* @param[in] font Font to read from, or NULL for system font
* @param[out] out Glyph position
* @param[in] glyphIndex Index to get position of
* @param[in] flags Misc flags
* @param[in] scaleX Size to scale in X
* @param[in] scaleY Size to scale in Y
*/
C2D_FontCalcGlyphPos :: (font: C2D_Font, out: *fontGlyphPos_s, glyphIndex: s32, flags: u32, scaleX: float, scaleY: float) -> void #foreign libcitro2d;

/** @brief Get the font info structure associated with the font
* @param[in] font Font to read from, or NULL for the system font
* @returns FINF associated with the font
*/
C2D_FontGetInfo :: (font: C2D_Font) -> *FINF_s #foreign libcitro2d;

C2D_TextBuf_s :: struct {}
C2D_TextBuf :: *C2D_TextBuf_s;

/// Text object.
C2D_Text :: struct {
    buf:   C2D_TextBuf; ///< Buffer associated with the text.
    begin: size_t; ///< Reserved for internal use.
    end:   size_t; ///< Reserved for internal use.
    width: float; ///< Width of the text in pixels, according to 1x scale metrics.
    lines: u32; ///< Number of lines in the text.
    words: u32; ///< Number of words in the text.
    font:  C2D_Font; ///< Font used to draw the text, or NULL for system font
}

C2D :: enum u8 {
    AtBaseline     :: 1;
    WithColor      :: 2;
    AlignLeft      :: 0;
    AlignRight     :: 4;
    AlignCenter    :: 8;
    AlignJustified :: 12;
    AlignMask      :: 12;
    WordWrap       :: 16;
}

/** @brief Creates a new text buffer.
*  @param[in] maxGlyphs Maximum number of glyphs that can be stored in the buffer.
*  @returns Text buffer handle (or NULL on failure).
*/
C2D_TextBufNew :: (maxGlyphs: size_t) -> C2D_TextBuf #foreign libcitro2d;

/** @brief Resizes a text buffer.
*  @param[in] buf Text buffer to resize.
*  @param[in] maxGlyphs Maximum number of glyphs that can be stored in the buffer.
*  @returns New text buffer handle (or NULL on failure).
*  @remarks If successful, old text buffer handle becomes invalid.
*/
C2D_TextBufResize :: (buf: C2D_TextBuf, maxGlyphs: size_t) -> C2D_TextBuf #foreign libcitro2d;

/** @brief Deletes a text buffer.
*  @param[in] buf Text buffer handle.
*  @remarks This also invalidates all text objects previously created with this buffer.
*/
C2D_TextBufDelete :: (buf: C2D_TextBuf) -> void #foreign libcitro2d;

/** @brief Clears all stored text in a buffer.
*  @param[in] buf Text buffer handle.
*/
C2D_TextBufClear :: (buf: C2D_TextBuf) -> void #foreign libcitro2d;

/** @brief Retrieves the number of glyphs stored in a text buffer.
*  @param[in] buf Text buffer handle.
*  @returns The number of glyphs.
*/
C2D_TextBufGetNumGlyphs :: (buf: C2D_TextBuf) -> size_t #foreign libcitro2d;

/** @brief Parses and adds a single line of text to a text buffer.
*  @param[out] text Pointer to text object to store information in.
*  @param[in] buf Text buffer handle.
*  @param[in] str String to parse.
*  @param[in] lineNo Line number assigned to the text (used to calculate vertical position).
*  @remarks Whitespace doesn't add any glyphs to the text buffer and is thus "free".
*  @returns On success, a pointer to the character on which string processing stopped, which
*           can be a newline ('\n'; indicating that's where the line ended), the null character
*           ('\0'; indicating the end of the string was reached), or any other character
*           (indicating the text buffer is full and no more glyphs can be added).
*           On failure, NULL.
*/
C2D_TextParseLine :: (text: *C2D_Text, buf: C2D_TextBuf, str: *u8, lineNo: u32) -> *u8 #foreign libcitro2d;

/** @brief Parses and adds a single line of text to a text buffer.
*  @param[out] text Pointer to text object to store information in.
*  @param[in] font Font to get glyphs from, or null for system font
*  @param[in] buf Text buffer handle.
*  @param[in] str String to parse.
*  @param[in] lineNo Line number assigned to the text (used to calculate vertical position).
*  @remarks Whitespace doesn't add any glyphs to the text buffer and is thus "free".
*  @returns On success, a pointer to the character on which string processing stopped, which
*           can be a newline ('\n'; indicating that's where the line ended), the null character
*           ('\0'; indicating the end of the string was reached), or any other character
*           (indicating the text buffer is full and no more glyphs can be added).
*           On failure, NULL.
*/
C2D_TextFontParseLine :: (text: *C2D_Text, font: C2D_Font, buf: C2D_TextBuf, str: *u8, lineNo: u32) -> *u8 #foreign libcitro2d;

/** @brief Parses and adds arbitrary text (including newlines) to a text buffer.
*  @param[out] text Pointer to text object to store information in.
*  @param[in] buf Text buffer handle.
*  @param[in] str String to parse.
*  @remarks Whitespace doesn't add any glyphs to the text buffer and is thus "free".
*  @returns On success, a pointer to the character on which string processing stopped, which
*           can be the null character ('\0'; indicating the end of the string was reached),
*           or any other character (indicating the text buffer is full and no more glyphs can be added).
*           On failure, NULL.
*/
C2D_TextParse :: (text: *C2D_Text, buf: C2D_TextBuf, str: *u8) -> *u8 #foreign libcitro2d;

/** @brief Parses and adds arbitrary text (including newlines) to a text buffer.
*  @param[out] text Pointer to text object to store information in.
*  @param[in] font Font to get glyphs from, or null for system font
*  @param[in] buf Text buffer handle.
*  @param[in] str String to parse.
*  @remarks Whitespace doesn't add any glyphs to the text buffer and is thus "free".
*  @returns On success, a pointer to the character on which string processing stopped, which
*           can be the null character ('\0'; indicating the end of the string was reached),
*           or any other character (indicating the text buffer is full and no more glyphs can be added).
*           On failure, NULL.
*/
C2D_TextFontParse :: (text: *C2D_Text, font: C2D_Font, buf: C2D_TextBuf, str: *u8) -> *u8 #foreign libcitro2d;

/** @brief Optimizes a text object in order to be drawn more efficiently.
*  @param[in] text Pointer to text object.
*/
C2D_TextOptimize :: (text: *C2D_Text) -> void #foreign libcitro2d;

/** @brief Retrieves the total dimensions of a text object.
*  @param[in] text Pointer to text object.
*  @param[in] scaleX Horizontal size of the font. 1.0f corresponds to the native size of the font.
*  @param[in] scaleY Vertical size of the font. 1.0f corresponds to the native size of the font.
*  @param[out] outWidth (optional) Variable in which to store the width of the text.
*  @param[out] outHeight (optional) Variable in which to store the height of the text.
*/
C2D_TextGetDimensions :: (text: *C2D_Text, scaleX: float, scaleY: float, outWidth: *float, outHeight: *float) -> void #foreign libcitro2d;

/** @brief Draws text using the GPU.
*  @param[in] text Pointer to text object.
*  @param[in] flags Text drawing flags.
*  @param[in] x Horizontal position to draw the text on.
*  @param[in] y Vertical position to draw the text on. If C2D_AtBaseline is not specified (default), this
*               is the top left corner of the block of text; otherwise this is the position of the baseline
*               of the first line of text.
*  @param[in] z Depth value of the text. If unsure, pass 0.0f.
*  @param[in] scaleX Horizontal size of the font. 1.0f corresponds to the native size of the font.
*  @param[in] scaleY Vertical size of the font. 1.0f corresponds to the native size of the font.
*  @remarks The default 3DS system font has a glyph height of 30px, and the baseline is at 25px.
*/
C2D_DrawText :: (text: *C2D_Text, flags: u32, x: float, y: float, z: float, scaleX: float, scaleY: float, __args: ..Any) -> void #foreign libcitro2d;

#scope_file

libctru :: #foreign_system_library,no_dll "libctru";
libcitro3d :: #foreign_system_library,no_dll "libcitro3d";
libcitro2d :: #foreign_system_library,no_dll "libcitro2d";
